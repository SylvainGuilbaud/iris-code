<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Apple Mac OS X for x86-64) 2018.1.5 (Build 659U)" ts="2021-08-31 12:03:57">
<Class name="Demo.ComplexMap.Rule.SemesterBatchRouting">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62770,56249.973895</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.MsgRouter.RoutingEngine" production="Demo.ComplexMap.SemesterProduction">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="" disabled="false">
<constraint name="source" value="Semester_Data_FileService"></constraint>
<constraint name="msgClass" value="Demo.ComplexMap.Semester.Batch"></constraint>
<when condition="1">
<send transform="" target="Semester_Data_FileOperation"></send>
<send transform="Demo.ComplexMap.Transform.SemesterBatchToSemesterSummaryBatch" target="Semester_Summary_FileOperation"></send>
<send transform="Demo.ComplexMap.Transform.SemesterBatchToFixedClassBatch" target="Semester_FixedClassBatch_FileOperation"></send>
<send transform="Demo.ComplexMap.Transform.SemesterBatchToFixedStudentBatch" target="Semester_FixedStudentBatch_FileOperation"></send>
<send transform="" target="Semester_FixedStudent_BatchCreator"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.ComplexMap.Semester.Batch">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Demo.ComplexMap.Semester.SemesterData'
on 2013-01-14 at 13:28:31.377 [2013-01-14 18:28:31.378 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexBatch,Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62836,48511.377826</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Semester">
<Type>Demo.ComplexMap.Semester.SemesterHeader.Record</Type>
<Required>1</Required>
</Property>

<Property name="Students">
<Type>Demo.ComplexMap.Semester.Students</Type>
<Collection>array</Collection>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.SemeD05B.BatchD</DataLocation>
<DefaultData>BatchDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.SemeD05B.BatchD</IdLocation>
<IndexLocation>^Demo.ComplexMap.SemeD05B.BatchI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.SemeD05B.BatchS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="BatchDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Semester</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
</Data>
<Data name="Students">
<Attribute>Students</Attribute>
<Structure>subnode</Structure>
<Subscript>"Students"</Subscript>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Semester.ClassInfo.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.Semester.ClassInfo'
on 2012-12-05 at 17:47:29.005 [2012-12-05 22:47:29.005 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,64049.005461</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="ClassIDIdx">
<Properties>ClassID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClassID">
<Type>%String</Type>
</Property>

<Property name="SectionID">
<Type>%String</Type>
</Property>

<Property name="Title">
<Type>%String</Type>
</Property>

<Property name="Grade">
<Type>%Integer</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.Semester.ClassInfo.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.SemClsI.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.SemClsI.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexMap.SemClsI.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.SemClsI.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClassID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Title</Value>
</Value>
<Value name="5">
<Value>Grade</Value>
</Value>
<Value name="6">
<Value>SectionID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Semester.ClassInfo">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62756,53239.277222</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Semester.ClassInfo" type="delimited" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Semester.ClassInfo.Record" complexBatchManaged="1" label="CLS|" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>;</Separator>
  </Separators>
  <Field name="ClassID" required="0" datatype="%String" index="1"></Field>
  <Field name="SectionID" required="0" datatype="%String"></Field>
  <Field name="Title" required="0" datatype="%String"></Field>
  <Field name="Grade" required="0" datatype="%Integer"></Field>
</Record>
]]></Data>
</XData>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.Semester.ClassInfo.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "CLS|" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(59))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClassID = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.SectionID = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Title = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Grade =  pObject.GradeDisplayToLogical(tCurrString)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("CLS|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($select(pHasTopFields: ##class(Demo.ComplexMap.Semester.ClassInfo.Record).ClassIDLogicalToDisplay(pObject.ClassID), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.ClassInfo.Record).SectionIDLogicalToDisplay(pObject.SectionID), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.ClassInfo.Record).TitleLogicalToDisplay(pObject.Title), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.ClassInfo.Record).GradeLogicalToDisplay(pObject.Grade), 1: ""),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.Semester.ClassInfo.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["CLS|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Semester.SemesterData">
<Description>
Complex RecordMap to represent all the students and the classes they are enrolled in for a given semester.</Description>
<Super>EnsLib.RecordMap.ComplexMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,58569.665507</TimeCreated>

<XData name="ComplexBatch">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<ComplexBatch xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Semester.SemesterData" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Semester.Batch">
  <Header name="Semester" recordMap="Demo.ComplexMap.Semester.SemesterHeader"></Header>
  <RecordSequence name="Students" required="1" repeating="1" minRepeats="1">
    <RecordReference name="Student" required="1" repeating="0" recordMap="Demo.ComplexMap.Semester.Student"></RecordReference>
    <RecordReference name="ClassInfo" required="1" repeating="1" minRepeats="1" recordMap="Demo.ComplexMap.Semester.ClassInfo"></RecordReference>
  </RecordSequence>
</ComplexBatch>
]]></Data>
</XData>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Method name="PutBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject($get(pBatch)) Set tStatus = $$$ERROR($$$ObjectInstanceRequired) Quit
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,"WAE",,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tStatus = ##class(Demo.ComplexMap.Semester.SemesterHeader).PutObject(pIOStream,pBatch.Semester,0)
		If $$$ISERR(tStatus) Quit
		For i=1:1:pBatch.Students.Count() {
			Set tElement = pBatch.Students.GetAt(i)
			If $IsObject(tElement) {
				Set tStatus = tElement.PutSequence(pIOStream)
				If $$$ISERR(tStatus) Quit
			}
		}
		If $$$ISERR(tStatus) Quit
		Do pIOStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	} Catch ex {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pTimeout:%Numeric=-1,*pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,,pTimeout,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set pIOStream.CharEncoding = "UTF-8"
		Set pBatch = ##class(Demo.ComplexMap.Semester.Batch).%New()
		Set pBatch.%Source = pIOStream.Name
		Set tStatus = ##class(Demo.ComplexMap.Semester.SemesterHeader).GetObject(pIOStream,.tHeader,pTimeout)
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Semester","Demo.ComplexMap.Semester.SemesterHeader",$classname()),tStatus) Quit
		Set pBatch.Semester = tHeader
		Set tLookAhead = ""
		If (4 > $length(tLookAhead)) {
			Set tLookAhead = tLookAhead _ pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Students","Demo.ComplexMap.Semester.Students",$classname()),tStatus) Quit
		}
		Set tCount = 0
		While ($extract(tLookAhead,1,4)="STU|") {
			Set tStatus = ..getSeqStudents(pIOStream,.tSequence,.tLookAhead,pBatch,pTimeout)
			Set tCount = tCount + 1
			If $$$ISERR(tStatus) Quit
			Set tStatus = pBatch.Students.SetAt(tSequence,tCount)
			If $$$ISERR(tStatus) Quit
			If (4 > $length(tLookAhead)) {
				Set tLookAhead = tLookAhead _ pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
				If $$$ISERR(tStatus) Quit
			}
		}
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexRepeating,"Students","Demo.ComplexMap.Semester.Students",$classname(),tCount),tStatus) Quit
		If (1 > tCount) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrRepeatMin,1,"Students")
			Quit
		}
	} Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="BATCHCLASS">
<Default>Demo.ComplexMap.Semester.Batch</Default>
</Parameter>

<Method name="getSeqStudents">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIOStream:%IO.DeviceStream,*pSequence:EnsLib.RecordMap.ComplexSequence,&pLookAhead:%String="",pBatch:EnsLib.RecordMap.ComplexBatch,pTimeout:%Numeric=-1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set pSequence = ##class(Demo.ComplexMap.Semester.Students).%New()
		Set tStatus = ##class(Demo.ComplexMap.Semester.Student).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Student","Demo.ComplexMap.Semester.Student",$classname()),tStatus) Quit
		Set pSequence.Student = tObject
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tCount = 0
		While ($extract(pLookAhead,1,4) = "CLS|") {
			Set tStatus = ##class(Demo.ComplexMap.Semester.ClassInfo).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			Set tCount = tCount + 1
			If $$$ISERR(tStatus) Quit
			Set tStatus = pSequence.ClassInfo.SetAt(tObject,tCount)
			If $$$ISERR(tStatus) Quit
			Set pLookAhead = pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexRepeating,"ClassInfo","Demo.ComplexMap.Semester.ClassInfo",$classname(),tCount),tStatus) Quit
		If (1 > tCount) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrRepeatMin,1,"ClassInfo")
			Quit
		}
	}
	Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Semester.SemesterHeader.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.Semester.SemesterHeader'
on 2012-12-05 at 17:06:05.014 [2012-12-05 22:06:05.014 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,61565.014671</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="SemesterIDIdx">
<Properties>SemesterID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="SemesterID">
<Type>%Integer</Type>
</Property>

<Property name="Year">
<Type>%Integer</Type>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="NumWeeks">
<Type>%Integer</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.Semester.SemesterHeader.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.Sem.SH.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.Sem.SH.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexMap.Sem.SH.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.Sem.SH.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>SemesterID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Name</Value>
</Value>
<Value name="5">
<Value>NumWeeks</Value>
</Value>
<Value name="6">
<Value>Year</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Semester.SemesterHeader">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62756,56200.754655</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Semester.SemesterHeader" type="delimited" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Semester.SemesterHeader.Record" complexBatchManaged="1" label="SEM|" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>;</Separator>
  </Separators>
  <Field name="SemesterID" required="0" repeating="0" datatype="%Integer" index="1"></Field>
  <Field name="Year" required="0" repeating="0" datatype="%Integer"></Field>
  <Field name="Name" required="0" repeating="0" datatype="%String"></Field>
  <Field name="NumWeeks" required="0" repeating="0" datatype="%Integer"></Field>
</Record>
]]></Data>
</XData>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.Semester.SemesterHeader.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "SEM|" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(59))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.SemesterID =  pObject.SemesterIDDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Year =  pObject.YearDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Name = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.NumWeeks =  pObject.NumWeeksDisplayToLogical(tCurrString)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("SEM|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($select(pHasTopFields: ##class(Demo.ComplexMap.Semester.SemesterHeader.Record).SemesterIDLogicalToDisplay(pObject.SemesterID), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.SemesterHeader.Record).YearLogicalToDisplay(pObject.Year), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.SemesterHeader.Record).NameLogicalToDisplay(pObject.Name), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.SemesterHeader.Record).NumWeeksLogicalToDisplay(pObject.NumWeeks), 1: ""),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.SemesterHeader.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["SEM|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Semester.Student.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.Semester.Student'
on 2012-12-05 at 17:06:05.349 [2012-12-05 22:06:05.349 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,61565.349338</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="StudentIDIdx">
<Properties>StudentID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="StudentID">
<Type>%Integer</Type>
</Property>

<Property name="LastName">
<Type>%String</Type>
</Property>

<Property name="FirstName">
<Type>%String</Type>
</Property>

<Property name="MiddleName">
<Type>%String</Type>
</Property>

<Property name="Grade">
<Type>%Integer</Type>
</Property>

<Property name="Email">
<Type>%String</Type>
</Property>

<Property name="Phone">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.Semester.Student.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.SemStud.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.SemStud.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexMap.SemStud.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.SemStud.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>StudentID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>FirstName</Value>
</Value>
<Value name="5">
<Value>MiddleName</Value>
</Value>
<Value name="6">
<Value>Grade</Value>
</Value>
<Value name="7">
<Value>Email</Value>
</Value>
<Value name="8">
<Value>Phone</Value>
</Value>
<Value name="9">
<Value>LastName</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Semester.Student">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62756,53062.393163</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Semester.Student" type="delimited" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Semester.Student.Record" complexBatchManaged="1" label="STU|" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>;</Separator>
  </Separators>
  <Field name="StudentID" required="0" repeating="0" datatype="%Integer" index="1"></Field>
  <Field name="LastName" required="0" repeating="0" datatype="%String"></Field>
  <Field name="FirstName" required="0" repeating="0" datatype="%String"></Field>
  <Field name="MiddleName" required="0" repeating="0" datatype="%String"></Field>
  <Field name="Grade" required="0" repeating="0" datatype="%Integer"></Field>
  <Field name="Email" required="0" repeating="0" datatype="%String"></Field>
  <Field name="Phone" required="0" repeating="0" datatype="%String"></Field>
</Record>
]]></Data>
</XData>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.Semester.Student.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "STU|" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(59))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.StudentID =  pObject.StudentIDDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.LastName = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.FirstName = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.MiddleName = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Grade =  pObject.GradeDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Email = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Phone = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("STU|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).StudentIDLogicalToDisplay(pObject.StudentID), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).LastNameLogicalToDisplay(pObject.LastName), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).FirstNameLogicalToDisplay(pObject.FirstName), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).MiddleNameLogicalToDisplay(pObject.MiddleName), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).GradeLogicalToDisplay(pObject.Grade), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).EmailLogicalToDisplay(pObject.Email), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Semester.Student.Record).PhoneLogicalToDisplay(pObject.Phone), 1: ""),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.Semester.Student.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["STU|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Semester.Students">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Demo.ComplexMap.Semester.SemesterData'
on 2013-01-14 at 13:28:31.441 [2013-01-14 18:28:31.441 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexSequence,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62836,48511.440436</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Student">
<Type>Demo.ComplexMap.Semester.Student.Record</Type>
<Required>1</Required>
</Property>

<Property name="ClassInfo">
<Type>Demo.ComplexMap.Semester.ClassInfo.Record</Type>
<Collection>array</Collection>
<Required>1</Required>
</Property>

<Method name="PutSequence">
<FormalSpec>pIOStream:%IO.DeviceStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If $IsObject(..Student) {
			Set tStatus = ##class(Demo.ComplexMap.Semester.Student).PutObject(pIOStream,..Student,0)
			If $$$ISERR(tStatus) Quit
		}
		For i=1:1:..ClassInfo.Count() {
			Set tElement = ..ClassInfo.GetAt(i)
			If $IsObject(tElement) {
				Set tStatus = ##class(Demo.ComplexMap.Semester.ClassInfo).PutObject(pIOStream,tElement,0)
				If $$$ISERR(tStatus) Quit
			}
			Set tStatus = ..ClassInfo.%UnSwizzleAt(i)
			If $$$ISERR(tStatus) Quit
		}
		If $$$ISERR(tStatus) Quit
	}
	Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Trigger name="OnDeleteTrigger">
<Code>	Set %ok = ##class(Demo.ComplexMap.Semester.Students).%OnDelete($$$oidForm({ID}))</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.SD05B.StudentsD</DataLocation>
<DefaultData>StudentsDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.SD05B.StudentsD</IdLocation>
<IndexLocation>^Demo.ComplexMap.SD05B.StudentsI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.SD05B.StudentsS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ClassInfo">
<Attribute>ClassInfo</Attribute>
<Structure>subnode</Structure>
<Subscript>"ClassInfo"</Subscript>
</Data>
<Data name="StudentsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Student</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterData">
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,53894.978099</TimeCreated>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.ClassBatch">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Demo.ComplexMap.SemesterFixed.ClassMap'
on 2012-12-06 at 17:59:50.300 [2012-12-06 22:59:50.300 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexBatch,Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64790.30003</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Semester">
<Type>Demo.ComplexMap.SemesterFixed.Semester.Record</Type>
<Required>1</Required>
</Property>

<Property name="Classes">
<Type>Demo.ComplexMap.SemesterFixed.ClassInfo.Record</Type>
<Collection>array</Collection>
<Parameter name="MINREPEATS" value="1"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMapSFix.ClassBatchD</DataLocation>
<DefaultData>ClassBatchDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMapSFix.ClassBatchD</IdLocation>
<IndexLocation>^Demo.ComplexMapSFix.ClassBatchI</IndexLocation>
<StreamLocation>^Demo.ComplexMapSFix.ClassBatchS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="ClassBatchDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Semester</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
</Data>
<Data name="Classes">
<Attribute>Classes</Attribute>
<Structure>subnode</Structure>
<Subscript>"Classes"</Subscript>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.ClassInfo.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.SemesterFixed.ClassInfo'
on 2012-12-06 at 17:59:13.223 [2012-12-06 22:59:13.223 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64753.223592</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="ClassIDIdx">
<Properties>ClassID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClassID">
<Type>%String</Type>
<Parameter name="MAXLEN" value="15"/>
</Property>

<Property name="SectionID">
<Type>%String</Type>
<Parameter name="MAXLEN" value="10"/>
</Property>

<Property name="Title">
<Type>%String</Type>
<Parameter name="MAXLEN" value="40"/>
</Property>

<Property name="Grade">
<Type>%String</Type>
<Parameter name="MAXLEN" value="3"/>
</Property>

<Property name="StudentCount">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="999"/>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.SemFix.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.SemFix.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexMap.SemFix.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.SemFix.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClassID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Title</Value>
</Value>
<Value name="5">
<Value>Grade</Value>
</Value>
<Value name="6">
<Value>StudentCount</Value>
</Value>
<Value name="7">
<Value>SectionID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.ClassInfo">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Demo.ComplexMap.SemesterFixed.ClassInfo'
on 2015-10-29 at 10:48:06.106 [2015-10-29 15:48:06.106 UTC]
by user UnknownUser</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,67807.028168</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.SemesterFixed.ClassInfo.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "CLS|" } 
	Set tMaxLen = 73 + $length(tRecLabel)
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, tMaxLen, pTimeout, $char(13,10), tRecLabel, .pLookAhead, .tExtra)
	If $$$ISERR(tStatus) Quit tStatus
	Set pLookAhead = $get(tExtra)
	Set tIgnoreEarlyTerminator = 0
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tCurrPos = 1
	Set tNewChunk = 1
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,15,"","","ClassID",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.ClassID = pObject.ClassIDDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,10,"","","SectionID",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.SectionID = pObject.SectionIDDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,40,"","","Title",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Title = pObject.TitleDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,5,"","","Grade",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Grade = pObject.GradeDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,3,"","","StudentCount",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.StudentCount = pObject.StudentCountDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("CLS|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo.Record).ClassIDLogicalToDisplay(pObject.ClassID), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 15 > tLen {
		Set tPadding = $get(pPadArray(15 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (15 - tLen + 1)) = ""
			Set pPadArray(15-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo.Record).SectionIDLogicalToDisplay(pObject.SectionID), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 10 > tLen {
		Set tPadding = $get(pPadArray(10 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (10 - tLen + 1)) = ""
			Set pPadArray(10-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo.Record).TitleLogicalToDisplay(pObject.Title), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 40 > tLen {
		Set tPadding = $get(pPadArray(40 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (40 - tLen + 1)) = ""
			Set pPadArray(40-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo.Record).GradeLogicalToDisplay(pObject.Grade), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 5 > tLen {
		Set tPadding = $get(pPadArray(5 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (5 - tLen + 1)) = ""
			Set pPadArray(5-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo.Record).StudentCountLogicalToDisplay(pObject.StudentCount), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 3 > tLen {
		Set tPadding = $get(pPadArray(3 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (3 - tLen + 1)) = ""
			Set pPadArray(3-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.SemesterFixed.ClassInfo.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["CLS|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["fixedwidth"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.SemesterFixed.ClassInfo" type="fixedwidth" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.SemesterFixed.ClassInfo.Record" complexBatchManaged="1" label="CLS|" paddingChars="\x20" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Field name="ClassID" required="0" datatype="%String" width="15" index="1">
  </Field>
  <Field name="SectionID" required="0" datatype="%String" width="10">
  </Field>
  <Field name="Title" required="0" datatype="%String" width="40">
  </Field>
  <Field name="Grade" required="0" datatype="%String" width="5" repeating="0">
  </Field>
  <Field name="StudentCount" required="0" datatype="%Integer" width="3">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.ClassMap">
<Super>EnsLib.RecordMap.ComplexMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64783.614286</TimeCreated>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<XData name="ComplexBatch">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<ComplexBatch xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.SemesterFixed.ClassMap" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.SemesterFixed.ClassBatch">
  <Header name="Semester" recordMap="Demo.ComplexMap.SemesterFixed.Semester"></Header>
  <RecordReference name="Classes" required="0" repeating="1" minRepeats="1" recordMap="Demo.ComplexMap.SemesterFixed.ClassInfo"></RecordReference>
</ComplexBatch>
]]></Data>
</XData>

<Parameter name="BATCHCLASS">
<Default>Demo.ComplexMap.SemesterFixed.ClassBatch</Default>
</Parameter>

<Method name="PutBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject($get(pBatch)) Set tStatus = $$$ERROR($$$ObjectInstanceRequired) Quit
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,"WAE",,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.Semester).PutObject(pIOStream,pBatch.Semester,0)
		If $$$ISERR(tStatus) Quit
		For i=1:1:pBatch.Classes.Count() {
			Set tElement = pBatch.Classes.GetAt(i)
			If $IsObject(tElement) {
				Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo).PutObject(pIOStream,tElement,0)
				If $$$ISERR(tStatus) Quit
			}
		}
		If $$$ISERR(tStatus) Quit
		Do pIOStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	} Catch ex {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pTimeout:%Numeric=-1,*pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,,pTimeout,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set pIOStream.CharEncoding = "UTF-8"
		Set pBatch = ##class(Demo.ComplexMap.SemesterFixed.ClassBatch).%New()
		Set pBatch.%Source = pIOStream.Name
		Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.Semester).GetObject(pIOStream,.tHeader,pTimeout)
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Semester","Demo.ComplexMap.SemesterFixed.Semester",$classname()),tStatus) Quit
		Set pBatch.Semester = tHeader
		Set tLookAhead = ""
		If (4 > $length(tLookAhead)) {
			Set tLookAhead = pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tCount = 0
		While ($extract(tLookAhead,1,4) = "CLS|") {
			Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.ClassInfo).GetObject(pIOStream,.tObject,pTimeout,.tLookAhead)
			Set tCount = tCount + 1
			If $$$ISERR(tStatus) Quit
			Set tStatus = pBatch.Classes.SetAt(tObject,tCount)
			If $$$ISERR(tStatus) Quit
			Set tLookAhead = pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexRepeating,"Classes","Demo.ComplexMap.SemesterFixed.ClassInfo",$classname(),tCount),tStatus) Quit
		If (1 > tCount) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrRepeatMin,1,"Classes")
			Quit
		}
	} Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.Semester.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.SemesterFixed.Semester'
on 2012-12-06 at 17:55:25.784 [2012-12-06 22:55:25.784 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64525.784001</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="SemesterIDIdx">
<Properties>SemesterID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="SemesterID">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="9999"/>
</Property>

<Property name="Year">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="9999"/>
</Property>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="10"/>
</Property>

<Property name="NumWeeks">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="99"/>
</Property>

<Property name="RecordCount">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="99999"/>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.SemesterFixed.Semester.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexSFix.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexSFix.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexSFix.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexSFix.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>SemesterID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Name</Value>
</Value>
<Value name="5">
<Value>NumWeeks</Value>
</Value>
<Value name="6">
<Value>RecordCount</Value>
</Value>
<Value name="7">
<Value>Year</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.Semester">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64222.677246</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.SemesterFixed.Semester" type="fixedwidth" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.SemesterFixed.Semester.Record" complexBatchManaged="1" label="SEM|" paddingChars="\x20" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Field name="SemesterID" required="0" datatype="%Integer" width="4" index="1"></Field>
  <Field name="Year" required="0" datatype="%Integer" width="4"></Field>
  <Field name="Name" required="0" datatype="%String" width="10"></Field>
  <Field name="NumWeeks" required="0" datatype="%Integer" width="2"></Field>
  <Field name="RecordCount" required="0" datatype="%Integer" width="5"></Field>
</Record>
]]></Data>
</XData>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.SemesterFixed.Semester.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "SEM|" } 
	Set tMaxLen = 25 + $length(tRecLabel)
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, tMaxLen, pTimeout, $char(13,10), tRecLabel, .pLookAhead, .tExtra)
	If $$$ISERR(tStatus) Quit tStatus
	Set pLookAhead = $get(tExtra)
	Set tIgnoreEarlyTerminator = 0
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tCurrPos = 1
	Set tNewChunk = 1
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,4,"","","SemesterID",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.SemesterID = pObject.SemesterIDDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,4,"","","Year",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Year = pObject.YearDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,10,"","","Name",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Name = pObject.NameDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,2,"","","NumWeeks",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.NumWeeks = pObject.NumWeeksDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,5,"","","RecordCount",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.RecordCount = pObject.RecordCountDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("SEM|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Semester.Record).SemesterIDLogicalToDisplay(pObject.SemesterID), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 4 > tLen {
		Set tPadding = $get(pPadArray(4 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (4 - tLen + 1)) = ""
			Set pPadArray(4-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Semester.Record).YearLogicalToDisplay(pObject.Year), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 4 > tLen {
		Set tPadding = $get(pPadArray(4 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (4 - tLen + 1)) = ""
			Set pPadArray(4-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Semester.Record).NameLogicalToDisplay(pObject.Name), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 10 > tLen {
		Set tPadding = $get(pPadArray(10 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (10 - tLen + 1)) = ""
			Set pPadArray(10-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Semester.Record).NumWeeksLogicalToDisplay(pObject.NumWeeks), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 2 > tLen {
		Set tPadding = $get(pPadArray(2 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (2 - tLen + 1)) = ""
			Set pPadArray(2-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Semester.Record).RecordCountLogicalToDisplay(pObject.RecordCount), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 5 > tLen {
		Set tPadding = $get(pPadArray(5 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (5 - tLen + 1)) = ""
			Set pPadArray(5-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.SemesterFixed.Semester.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["SEM|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["fixedwidth"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.Student.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.SemesterFixed.Student'
on 2012-12-06 at 17:46:52.455 [2012-12-06 22:46:52.455 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64012.4557</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="StudentIDIdx">
<Properties>StudentID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="StudentID">
<Type>%String</Type>
<Parameter name="MAXLEN" value="9"/>
</Property>

<Property name="LastName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="25"/>
</Property>

<Property name="FirstName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="20"/>
</Property>

<Property name="MiddleName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="20"/>
</Property>

<Property name="Grade">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="99"/>
</Property>

<Property name="Email">
<Type>%String</Type>
<Parameter name="MAXLEN" value="40"/>
</Property>

<Property name="Phone">
<Type>%String</Type>
<Parameter name="MAXLEN" value="20"/>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexSFix.StuRecD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexSFix.StuRecD</IdLocation>
<IndexLocation>^Demo.ComplexSFix.StuRecI</IndexLocation>
<StreamLocation>^Demo.ComplexSFix.StuRecS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>StudentID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>FirstName</Value>
</Value>
<Value name="5">
<Value>MiddleName</Value>
</Value>
<Value name="6">
<Value>Grade</Value>
</Value>
<Value name="7">
<Value>Email</Value>
</Value>
<Value name="8">
<Value>Phone</Value>
</Value>
<Value name="9">
<Value>LastName</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.Student">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,67561.704113</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.SemesterFixed.Student" type="fixedwidth" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.SemesterFixed.Student.Record" complexBatchManaged="1" label="STU|" paddingChars="\x20" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Field name="StudentID" required="0" datatype="%String" width="9" index="1"></Field>
  <Field name="LastName" required="0" datatype="%String" width="25"></Field>
  <Field name="FirstName" required="0" datatype="%String" width="20"></Field>
  <Field name="MiddleName" required="0" datatype="%String" width="20"></Field>
  <Field name="Grade" required="0" datatype="%Integer" width="2"></Field>
  <Field name="Email" required="0" datatype="%String" width="40"></Field>
  <Field name="Phone" required="0" datatype="%String" width="20"></Field>
</Record>
]]></Data>
</XData>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.SemesterFixed.Student.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "STU|" } 
	Set tMaxLen = 136 + $length(tRecLabel)
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, tMaxLen, pTimeout, $char(13,10), tRecLabel, .pLookAhead, .tExtra)
	If $$$ISERR(tStatus) Quit tStatus
	Set pLookAhead = $get(tExtra)
	Set tIgnoreEarlyTerminator = 0
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tCurrPos = 1
	Set tNewChunk = 1
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,9,"","","StudentID",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.StudentID = pObject.StudentIDDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,25,"","","LastName",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.LastName = pObject.LastNameDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,20,"","","FirstName",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.FirstName = pObject.FirstNameDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,20,"","","MiddleName",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.MiddleName = pObject.MiddleNameDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,2,"","","Grade",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Grade = pObject.GradeDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,40,"","","Email",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Email = pObject.EmailDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,20,"","","Phone",tIgnoreEarlyTerminator)
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.Phone = pObject.PhoneDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("STU|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).StudentIDLogicalToDisplay(pObject.StudentID), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 9 > tLen {
		Set tPadding = $get(pPadArray(9 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (9 - tLen + 1)) = ""
			Set pPadArray(9-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).LastNameLogicalToDisplay(pObject.LastName), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 25 > tLen {
		Set tPadding = $get(pPadArray(25 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (25 - tLen + 1)) = ""
			Set pPadArray(25-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).FirstNameLogicalToDisplay(pObject.FirstName), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 20 > tLen {
		Set tPadding = $get(pPadArray(20 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (20 - tLen + 1)) = ""
			Set pPadArray(20-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).MiddleNameLogicalToDisplay(pObject.MiddleName), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 20 > tLen {
		Set tPadding = $get(pPadArray(20 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (20 - tLen + 1)) = ""
			Set pPadArray(20-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).GradeLogicalToDisplay(pObject.Grade), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 2 > tLen {
		Set tPadding = $get(pPadArray(2 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (2 - tLen + 1)) = ""
			Set pPadArray(2-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).EmailLogicalToDisplay(pObject.Email), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 40 > tLen {
		Set tPadding = $get(pPadArray(40 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (40 - tLen + 1)) = ""
			Set pPadArray(40-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.ComplexMap.SemesterFixed.Student.Record).PhoneLogicalToDisplay(pObject.Phone), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 20 > tLen {
		Set tPadding = $get(pPadArray(20 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (20 - tLen + 1)) = ""
			Set pPadArray(20-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.SemesterFixed.Student.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["STU|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["fixedwidth"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.StudentBatch">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Demo.ComplexMap.SemesterFixed.StudentMap'
on 2012-12-06 at 18:01:20.705 [2012-12-06 23:01:20.705 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexBatch,Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64880.705839</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Semester">
<Type>Demo.ComplexMap.SemesterFixed.Semester.Record</Type>
<Required>1</Required>
</Property>

<Property name="Students">
<Type>Demo.ComplexMap.SemesterFixed.Student.Record</Type>
<Collection>array</Collection>
<Parameter name="MINREPEATS" value="1"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexSFix.StudentBatchD</DataLocation>
<DefaultData>StudentBatchDefaultData</DefaultData>
<IdLocation>^Demo.ComplexSFix.StudentBatchD</IdLocation>
<IndexLocation>^Demo.ComplexSFix.StudentBatchI</IndexLocation>
<StreamLocation>^Demo.ComplexSFix.StudentBatchS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="StudentBatchDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Semester</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
</Data>
<Data name="Students">
<Attribute>Students</Attribute>
<Structure>subnode</Structure>
<Subscript>"Students"</Subscript>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.StudentBatchProcess">
<Description>
Business Process that constructs a Demo.ComplexMap.SemesterFixed.StudentBatch based on an incoming Demo.ComplexMap.Semester.Batch, and sends it on to a file output operation.</Description>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62836,38048.312509</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Demo.ComplexMap.Semester.Batch' response='Ens.Response' height='2250' width='2000' >
<context>
<property name='StudentBatch' type='Demo.ComplexMap.SemesterFixed.StudentBatch' instantiate='1' >
</property>
<property name='SourceStudent' type='Demo.ComplexMap.Semester.Student.Record' instantiate='0' >
</property>
<property name='TargetStudent' type='Demo.ComplexMap.SemesterFixed.Student.Record' instantiate='0' >
</property>
<property name='Key' type='%String' instantiate='0' >
<parameters>
<parameter name='MAXLEN'  value='50' />
</parameters>
</property>
<property name='TempStudents' type='Demo.ComplexMap.Semester.Students' instantiate='0' >
</property>
</context>
<sequence xend='200' yend='750' >
<assign name="Copy %Source" property="context.StudentBatch.%Source" value="request.%Source" action="set" xpos='200' ypos='250' />
<transform name='Transform Semester Header' class='Demo.ComplexMap.Transform.SemesterToFixedSemester' source='request.Semester' target='context.StudentBatch.Semester' xpos='200' ypos='350' />
<assign name="Set RecordCount" property="context.StudentBatch.Semester.RecordCount" value="request.Students.Count()" action="set" xpos='200' ypos='450' />
<foreach name='For each Student' property='request.Students' key='context.Key' xpos='200' ypos='550' xend='200' yend='2000' >
<assign name="Get Students from request" property="context.TempStudents" value="request.Students.GetAt(context.Key)" action="set" xpos='200' ypos='250' />
<if name='TempStudents' condition='$IsObject(context.TempStudents)' xpos='200' ypos='350' xend='200' yend='1900' >
<true>
<assign name="Get actual Student" property="context.SourceStudent" value="context.TempStudents.Student" action="set" xpos='335' ypos='500' />
<assign name="Create TargetStudent" property="context.TargetStudent" value="##class(Demo.ComplexMap.SemesterFixed.Student.Record).%New()" action="set" xpos='335' ypos='600' />
<assign name="Set StudentID" property="context.TargetStudent.StudentID" value="context.SourceStudent.StudentID" action="set" xpos='335' ypos='700' />
<assign name="Set LastName" property="context.TargetStudent.LastName" value="context.SourceStudent.LastName" action="set" xpos='335' ypos='800' />
<assign name="Set FirstName" property="context.TargetStudent.FirstName" value="context.SourceStudent.FirstName" action="set" xpos='335' ypos='900' />
<assign name="Set MiddleName" property="context.TargetStudent.MiddleName" value="context.SourceStudent.MiddleName" action="set" xpos='335' ypos='1000' />
<assign name="Set Grade" property="context.TargetStudent.Grade" value="context.SourceStudent.Grade" action="set" xpos='335' ypos='1100' />
<assign name="Set Email" property="context.TargetStudent.Email" value="context.SourceStudent.Email" action="set" xpos='335' ypos='1200' />
<assign name="Set Phone" property="context.TargetStudent.Phone" value="context.SourceStudent.Phone" action="set" xpos='335' ypos='1300' />
<assign name="Add TargetStudent to batch" property="context.StudentBatch.Students" value="context.TargetStudent" action="set" key="context.Key" xpos='335' ypos='1400' />
<assign name="Reset TargetStudent" property="context.TargetStudent" value="&quot;&quot;" action="set" xpos='335' ypos='1500' />
<assign name="Reset SourceStudent" property="context.SourceStudent" value="&quot;&quot;" action="set" xpos='335' ypos='1600' />
<assign name="Reset TempStudents" property="context.TempStudents" value="&quot;&quot;" action="set" xpos='335' ypos='1700' />
<assign name="UnSwizzle source student" property="status" value="request.Students.%UnSwizzleAt(context.Key)" action="set" xpos='335' ypos='1800' />
</true>
</if>
</foreach>
<call name='Send StudentBatch' target='@process.BatchOperation' async='0' xpos='200' ypos='650' >
<request type='Demo.ComplexMap.SemesterFixed.StudentBatch' >
<assign property="callrequest" value="context.StudentBatch" action="set" />
</request>
<response type='Ens.Response' />
</call>
</sequence>
</process>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>BatchOperation:Basic</Default>
</Parameter>

<Property name="BatchOperation">
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>StudentBatchProcessDefaultData</DefaultData>
<Data name="StudentBatchProcessDefaultData">
<Structure>listnode</Structure>
<Subscript>"StudentBatchProcess"</Subscript>
<Value name="1">
<Value>BatchOperation</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.SemesterFixed.StudentMap">
<Super>EnsLib.RecordMap.ComplexMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64877.986599</TimeCreated>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<XData name="ComplexBatch">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<ComplexBatch xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.SemesterFixed.StudentMap" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.SemesterFixed.StudentBatch">
  <Header name="Semester" recordMap="Demo.ComplexMap.SemesterFixed.Semester"></Header>
  <RecordReference name="Students" required="0" repeating="1" minRepeats="1" recordMap="Demo.ComplexMap.SemesterFixed.Student"></RecordReference>
</ComplexBatch>
]]></Data>
</XData>

<Parameter name="BATCHCLASS">
<Default>Demo.ComplexMap.SemesterFixed.StudentBatch</Default>
</Parameter>

<Method name="PutBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject($get(pBatch)) Set tStatus = $$$ERROR($$$ObjectInstanceRequired) Quit
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,"WAE",,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.Semester).PutObject(pIOStream,pBatch.Semester,0)
		If $$$ISERR(tStatus) Quit
		For i=1:1:pBatch.Students.Count() {
			Set tElement = pBatch.Students.GetAt(i)
			If $IsObject(tElement) {
				Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.Student).PutObject(pIOStream,tElement,0)
				If $$$ISERR(tStatus) Quit
			}
		}
		If $$$ISERR(tStatus) Quit
		Do pIOStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	} Catch ex {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pTimeout:%Numeric=-1,*pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,,pTimeout,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set pIOStream.CharEncoding = "UTF-8"
		Set pBatch = ##class(Demo.ComplexMap.SemesterFixed.StudentBatch).%New()
		Set pBatch.%Source = pIOStream.Name
		Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.Semester).GetObject(pIOStream,.tHeader,pTimeout)
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Semester","Demo.ComplexMap.SemesterFixed.Semester",$classname()),tStatus) Quit
		Set pBatch.Semester = tHeader
		Set tLookAhead = ""
		If (4 > $length(tLookAhead)) {
			Set tLookAhead = pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tCount = 0
		While ($extract(tLookAhead,1,4) = "STU|") {
			Set tStatus = ##class(Demo.ComplexMap.SemesterFixed.Student).GetObject(pIOStream,.tObject,pTimeout,.tLookAhead)
			Set tCount = tCount + 1
			If $$$ISERR(tStatus) Quit
			Set tStatus = pBatch.Students.SetAt(tObject,tCount)
			If $$$ISERR(tStatus) Quit
			Set tLookAhead = pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexRepeating,"Students","Demo.ComplexMap.SemesterFixed.Student",$classname(),tCount),tStatus) Quit
		If (1 > tCount) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrRepeatMin,1,"Students")
			Quit
		}
	} Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.SemesterProduction">
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62756,60182.982118</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.ComplexMap.SemesterProduction" LogGeneralTraceEvents="false">
  <Description>Sample Production to illustrate the use of Complex Maps. NOTE: The source file, ComplexMap_Semester_Data.txt, as well as sample output files, should be located in [install_dir]/dev/ComplexMap/.</Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Semester_Data_FileService" Category="" ClassName="EnsLib.RecordMap.Service.ComplexBatchFileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="ComplexMap">Demo.ComplexMap.Semester.SemesterData</Setting>
    <Setting Target="Host" Name="TargetConfigNames">Semester_Data_Router</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\in\</Setting>
    <Setting Target="Adapter" Name="FileSpec">ComplexMap_Semester_Data*.txt</Setting>
    <Setting Target="Adapter" Name="Charset">UTF-8</Setting>
  </Item>
  <Item Name="Semester_Data_Router" Category="" ClassName="EnsLib.MsgRouter.RoutingEngine" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Validation"></Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.ComplexMap.Rule.SemesterBatchRouting</Setting>
  </Item>
  <Item Name="Semester_Data_FileOperation" Category="" ClassName="EnsLib.RecordMap.Operation.ComplexBatchFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="ComplexMap">Demo.ComplexMap.Semester.SemesterData</Setting>
    <Setting Target="Host" Name="Filename">Semester_Data_Passthrough_%Q.txt</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out\</Setting>
    <Setting Target="Adapter" Name="Charset">UTF-8</Setting>
  </Item>
  <Item Name="Semester_Summary_FileOperation" Category="" ClassName="EnsLib.RecordMap.Operation.ComplexBatchFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out\</Setting>
    <Setting Target="Host" Name="ComplexMap">Demo.ComplexMap.Summary.SemesterSummary</Setting>
    <Setting Target="Host" Name="Filename">Semester_Summary_%Q.txt</Setting>
    <Setting Target="Adapter" Name="Charset">UTF-8</Setting>
  </Item>
  <Item Name="Semester_FixedClassBatch_FileOperation" Category="" ClassName="EnsLib.RecordMap.Operation.ComplexBatchFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Write out fixed width batches containing classes." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="ComplexMap">Demo.ComplexMap.SemesterFixed.ClassMap</Setting>
    <Setting Target="Host" Name="Filename">Semester_FixedClass_%Q.txt</Setting>
    <Setting Target="Adapter" Name="Charset">UTF-8</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out\</Setting>
  </Item>
  <Item Name="Semester_FixedStudentBatch_FileOperation" Category="" ClassName="EnsLib.RecordMap.Operation.ComplexBatchFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Write out fixed width batches containing students." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="ComplexMap">Demo.ComplexMap.SemesterFixed.StudentMap</Setting>
    <Setting Target="Host" Name="Filename">Semester_FixedStudent_%Q.txt</Setting>
    <Setting Target="Adapter" Name="Charset">UTF-8</Setting>
    <Setting Target="Adapter" Name="FilePath">c:\Practice\out\</Setting>
  </Item>
  <Item Name="Semester_FixedStudent_BatchCreator" Category="" ClassName="Demo.ComplexMap.SemesterFixed.StudentBatchProcess" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="BatchOperation">Semester_FixedStudentBatch_FileOperation</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.ComplexMap.Summary.SemesterHeader.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.Summary.SemesterHeader'
on 2012-12-05 at 17:47:28.213 [2012-12-05 22:47:28.213 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,64048.213085</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="SemesterIDIdx">
<Properties>SemesterID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="SemesterID">
<Type>%Integer</Type>
</Property>

<Property name="Year">
<Type>%Integer</Type>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="NumWeeks">
<Type>%Integer</Type>
</Property>

<Property name="NumberStudents">
<Type>%Integer</Type>
</Property>

<Property name="AverageGPA">
<Type>%Numeric</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.Sum5E5C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.Sum5E5C.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexMap.Sum5E5C.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.Sum5E5C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>SemesterID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Name</Value>
</Value>
<Value name="5">
<Value>NumWeeks</Value>
</Value>
<Value name="6">
<Value>NumberStudents</Value>
</Value>
<Value name="7">
<Value>AverageGPA</Value>
</Value>
<Value name="8">
<Value>Year</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Summary.SemesterHeader">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62770,55651.47551</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Summary.SemesterHeader" type="delimited" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Summary.SemesterHeader.Record" complexBatchManaged="1" label="SES|" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>;</Separator>
  </Separators>
  <Field name="SemesterID" required="0" datatype="%Integer" index="1"></Field>
  <Field name="Year" required="0" datatype="%Integer"></Field>
  <Field name="Name" required="0" datatype="%String"></Field>
  <Field name="NumWeeks" required="0" datatype="%Integer"></Field>
  <Field name="NumberStudents" required="0" datatype="%Integer"></Field>
  <Field name="AverageGPA" required="0" datatype="%Numeric"></Field>
</Record>
]]></Data>
</XData>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.Summary.SemesterHeader.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "SES|" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(59))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.SemesterID =  pObject.SemesterIDDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Year =  pObject.YearDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Name = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.NumWeeks =  pObject.NumWeeksDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.NumberStudents =  pObject.NumberStudentsDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.AverageGPA =  pObject.AverageGPADisplayToLogical(tCurrString)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("SES|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($select(pHasTopFields: ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).SemesterIDLogicalToDisplay(pObject.SemesterID), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).YearLogicalToDisplay(pObject.Year), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).NameLogicalToDisplay(pObject.Name), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).NumWeeksLogicalToDisplay(pObject.NumWeeks), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).NumberStudentsLogicalToDisplay(pObject.NumberStudents), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.SemesterHeader.Record).AverageGPALogicalToDisplay(pObject.AverageGPA), 1: ""),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.Summary.SemesterHeader.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["SES|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Summary.SemesterSummary">
<Super>EnsLib.RecordMap.ComplexMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62770,55982.689547</TimeCreated>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="BATCHCLASS">
<Default>Demo.ComplexMap.Summary.SummaryBatch</Default>
</Parameter>

<XData name="ComplexBatch">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<ComplexBatch xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Summary.SemesterSummary" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Summary.SummaryBatch">
  <Header name="Semester" recordMap="Demo.ComplexMap.Summary.SemesterHeader"></Header>
  <RecordSequence name="Students" required="1" repeating="1" minRepeats="1">
    <RecordReference name="Student" required="1" repeating="0" recordMap="Demo.ComplexMap.Summary.Student"></RecordReference>
    <RecordReference name="ClassInfo" required="1" repeating="1" minRepeats="1" recordMap="Demo.ComplexMap.Semester.ClassInfo"></RecordReference>
  </RecordSequence>
</ComplexBatch>
]]></Data>
</XData>

<Method name="PutBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject($get(pBatch)) Set tStatus = $$$ERROR($$$ObjectInstanceRequired) Quit
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,"WAE",,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tStatus = ##class(Demo.ComplexMap.Summary.SemesterHeader).PutObject(pIOStream,pBatch.Semester,0)
		If $$$ISERR(tStatus) Quit
		For i=1:1:pBatch.Students.Count() {
			Set tElement = pBatch.Students.GetAt(i)
			If $IsObject(tElement) {
				Set tStatus = tElement.PutSequence(pIOStream)
				If $$$ISERR(tStatus) Quit
			}
		}
		If $$$ISERR(tStatus) Quit
		Do pIOStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	} Catch ex {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pTimeout:%Numeric=-1,*pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,,pTimeout,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set pIOStream.CharEncoding = "UTF-8"
		Set pBatch = ##class(Demo.ComplexMap.Summary.SummaryBatch).%New()
		Set pBatch.%Source = pIOStream.Name
		Set tStatus = ##class(Demo.ComplexMap.Summary.SemesterHeader).GetObject(pIOStream,.tHeader,pTimeout)
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Semester","Demo.ComplexMap.Summary.SemesterHeader",$classname()),tStatus) Quit
		Set pBatch.Semester = tHeader
		Set tLookAhead = ""
		If (4 > $length(tLookAhead)) {
			Set tLookAhead = tLookAhead _ pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Students","Demo.ComplexMap.Summary.Students",$classname()),tStatus) Quit
		}
		Set tCount = 0
		While ($extract(tLookAhead,1,4)="STS|") {
			Set tStatus = ..getSeqStudents(pIOStream,.tSequence,.tLookAhead,pBatch,pTimeout)
			Set tCount = tCount + 1
			If $$$ISERR(tStatus) Quit
			Set tStatus = pBatch.Students.SetAt(tSequence,tCount)
			If $$$ISERR(tStatus) Quit
			If (4 > $length(tLookAhead)) {
				Set tLookAhead = tLookAhead _ pIOStream.Read(4-$length(tLookAhead),pTimeout,.tStatus)
				If $$$ISERR(tStatus) Quit
			}
		}
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexRepeating,"Students","Demo.ComplexMap.Summary.Students",$classname(),tCount),tStatus) Quit
		If (1 > tCount) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrRepeatMin,1,"Students")
			Quit
		}
	} Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="getSeqStudents">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIOStream:%IO.DeviceStream,*pSequence:EnsLib.RecordMap.ComplexSequence,&pLookAhead:%String="",pBatch:EnsLib.RecordMap.ComplexBatch,pTimeout:%Numeric=-1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set pSequence = ##class(Demo.ComplexMap.Summary.Students).%New()
		Set tStatus = ##class(Demo.ComplexMap.Summary.Student).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Student","Demo.ComplexMap.Summary.Student",$classname()),tStatus) Quit
		Set pSequence.Student = tObject
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tCount = 0
		While ($extract(pLookAhead,1,4) = "CLS|") {
			Set tStatus = ##class(Demo.ComplexMap.Semester.ClassInfo).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			Set tCount = tCount + 1
			If $$$ISERR(tStatus) Quit
			Set tStatus = pSequence.ClassInfo.SetAt(tObject,tCount)
			If $$$ISERR(tStatus) Quit
			Set pLookAhead = pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexRepeating,"ClassInfo","Demo.ComplexMap.Semester.ClassInfo",$classname(),tCount),tStatus) Quit
		If (1 > tCount) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrRepeatMin,1,"ClassInfo")
			Quit
		}
	}
	Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Summary.Student.Record.Name">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.Summary.Student'
on 2012-12-05 at 17:47:28.562 [2012-12-05 22:47:28.562 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,64048.562264</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Family">
<Type>%String</Type>
</Property>

<Property name="Given">
<Type>%String</Type>
</Property>

<Property name="Middle">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>NameState</State>
<StreamLocation>^Demo.ComplexMap.SummaC2B6.NameS</StreamLocation>
<Data name="NameState">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>Family</Value>
</Value>
<Value name="2">
<Value>Given</Value>
</Value>
<Value name="3">
<Value>Middle</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Summary.Student.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.ComplexMap.Summary.Student'
on 2012-12-05 at 17:47:28.581 [2012-12-05 22:47:28.581 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,64048.581273</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="StudentIDIdx">
<Properties>StudentID</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="StudentID">
<Type>%Integer</Type>
</Property>

<Property name="Name">
<Type>Demo.ComplexMap.Summary.Student.Record.Name</Type>
</Property>

<Property name="Grade">
<Type>%Integer</Type>
</Property>

<Property name="Email">
<Type>%String</Type>
</Property>

<Property name="Phone">
<Type>%String</Type>
</Property>

<Property name="NumberClasses">
<Type>%Integer</Type>
</Property>

<Property name="GPA">
<Type>%Numeric</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Demo.ComplexMap.Summary.Student.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.Sum86EC.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.Sum86EC.RecordD</IdLocation>
<IndexLocation>^Demo.ComplexMap.Sum86EC.RecordI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.Sum86EC.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>StudentID</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Grade</Value>
</Value>
<Value name="5">
<Value>Email</Value>
</Value>
<Value name="6">
<Value>Phone</Value>
</Value>
<Value name="7">
<Value>NumberClasses</Value>
</Value>
<Value name="8">
<Value>GPA</Value>
</Value>
<Value name="9">
<Value>Name</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Summary.Student">
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62770,55927.838086</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.ComplexMap.Summary.Student" type="delimited" char_encoding="UTF-8" targetClassname="Demo.ComplexMap.Summary.Student.Record" complexBatchManaged="1" label="STS|" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>;</Separator>
    <Separator>,</Separator>
  </Separators>
  <Field name="StudentID" required="0" datatype="%Integer" index="1"></Field>
  <Composite name="Name" required="0">
    <Field name="Name.Family" required="0" datatype="%String"></Field>
    <Field name="Name.Given" required="0" datatype="%String"></Field>
    <Field name="Name.Middle" required="0" datatype="%String"></Field>
  </Composite>
  <Field name="Grade" required="0" datatype="%Integer"></Field>
  <Field name="Email" required="0" datatype="%String"></Field>
  <Field name="Phone" required="0" datatype="%String"></Field>
  <Field name="NumberClasses" required="0" datatype="%Integer"></Field>
  <Field name="GPA" required="0" datatype="%Numeric"></Field>
</Record>
]]></Data>
</XData>

<Parameter name="OBJECTNAME">
<Default>Demo.ComplexMap.Summary.Student.Record</Default>
</Parameter>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "STS|" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(59),$char(44))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.StudentID =  pObject.StudentIDDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set tStrings(tStrings) = tCurrString
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(44), 1)
	Set tStrings = tStrings + 1
	Set pObject.Name.Family = tStrings(tStrings)
	Set tStrings = tStrings - 1
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(44), 2)
	Set tStrings = tStrings + 1
	Set pObject.Name.Given = tStrings(tStrings)
	Set tStrings = tStrings - 1
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(44), 3)
	Set tStrings = tStrings + 1
	Set pObject.Name.Middle = tStrings(tStrings)
	Set tStrings = tStrings - 1
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Grade =  pObject.GradeDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Email = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Phone = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.NumberClasses =  pObject.NumberClassesDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.GPA =  pObject.GPADisplayToLogical(tCurrString)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write("STS|",,.tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($select(pHasTopFields: ##class(Demo.ComplexMap.Summary.Student.Record).StudentIDLogicalToDisplay(pObject.StudentID), 1: ""),0)
	Do pStream.Write($char(59),0)
	Do pStream.Write(##class(Demo.ComplexMap.Summary.Student.Record.Name).FamilyLogicalToDisplay(pObject.Name.Family),0)
	Do pStream.Write($char(44) _ ##class(Demo.ComplexMap.Summary.Student.Record.Name).GivenLogicalToDisplay(pObject.Name.Given),0)
	Do pStream.Write($char(44) _ ##class(Demo.ComplexMap.Summary.Student.Record.Name).MiddleLogicalToDisplay(pObject.Name.Middle),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.Student.Record).GradeLogicalToDisplay(pObject.Grade), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.Student.Record).EmailLogicalToDisplay(pObject.Email), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.Student.Record).PhoneLogicalToDisplay(pObject.Phone), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.Student.Record).NumberClassesLogicalToDisplay(pObject.NumberClasses), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.ComplexMap.Summary.Student.Record).GPALogicalToDisplay(pObject.GPA), 1: ""),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.ComplexMap.Summary.Student.Record")=""
	Set pClasses("Demo.ComplexMap.Summary.Student.Record.Name")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["STS|"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ComplexMap.Summary.Students">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Demo.ComplexMap.Summary.SemesterSummary'
on 2012-12-05 at 17:47:28.550 [2012-12-05 22:47:28.550 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexSequence,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,64048.550894</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Student">
<Type>Demo.ComplexMap.Summary.Student.Record</Type>
<Required>1</Required>
</Property>

<Property name="ClassInfo">
<Type>Demo.ComplexMap.Semester.ClassInfo.Record</Type>
<Collection>array</Collection>
<Required>1</Required>
</Property>

<Method name="PutSequence">
<FormalSpec>pIOStream:%IO.DeviceStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If $IsObject(..Student) {
			Set tStatus = ##class(Demo.ComplexMap.Summary.Student).PutObject(pIOStream,..Student,0)
			If $$$ISERR(tStatus) Quit
		}
		For i=1:1:..ClassInfo.Count() {
			Set tElement = ..ClassInfo.GetAt(i)
			If $IsObject(tElement) {
				Set tStatus = ##class(Demo.ComplexMap.Semester.ClassInfo).PutObject(pIOStream,tElement,0)
				If $$$ISERR(tStatus) Quit
			}
			Set tStatus = ..ClassInfo.%UnSwizzleAt(i)
			If $$$ISERR(tStatus) Quit
		}
		If $$$ISERR(tStatus) Quit
	}
	Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Trigger name="OnDeleteTrigger">
<Code>	Set %ok = ##class(Demo.ComplexMap.Summary.Students).%OnDelete($$$oidForm({ID}))
</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMap.S46EE.StudentsD</DataLocation>
<DefaultData>StudentsDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMap.S46EE.StudentsD</IdLocation>
<IndexLocation>^Demo.ComplexMap.S46EE.StudentsI</IndexLocation>
<StreamLocation>^Demo.ComplexMap.S46EE.StudentsS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ClassInfo">
<Attribute>ClassInfo</Attribute>
<Structure>subnode</Structure>
<Subscript>"ClassInfo"</Subscript>
</Data>
<Data name="StudentsDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Student</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Summary.SummaryBatch">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Demo.ComplexMap.Summary.SemesterSummary'
on 2012-12-05 at 17:47:28.204 [2012-12-05 22:47:28.204 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexBatch,Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62796,64048.204214</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="Semester">
<Type>Demo.ComplexMap.Summary.SemesterHeader.Record</Type>
<Required>1</Required>
</Property>

<Property name="Students">
<Type>Demo.ComplexMap.Summary.Students</Type>
<Collection>array</Collection>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.ComplexMpSum.SummaryBatchD</DataLocation>
<DefaultData>SummaryBatchDefaultData</DefaultData>
<IdLocation>^Demo.ComplexMpSum.SummaryBatchD</IdLocation>
<IndexLocation>^Demo.ComplexMpSum.SummaryBatchI</IndexLocation>
<StreamLocation>^Demo.ComplexMpSum.SummaryBatchS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="Students">
<Attribute>Students</Attribute>
<Structure>subnode</Structure>
<Subscript>"Students"</Subscript>
</Data>
<Data name="SummaryBatchDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Semester</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ComplexMap.Transform.CreateClassBatch">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64977.643692</TimeCreated>
<DependsOn>Demo.ComplexMap.Semester.Batch,Demo.ComplexMap.SemesterFixed.ClassBatch</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.ComplexMap.Semester.Batch' targetClass='Demo.ComplexMap.SemesterFixed.ClassBatch' create='new' language='objectscript' >
<subtransform class='Demo.ComplexMap.Transform.SemesterToFixedSemester' targetObj='target.Semester' sourceObj='source.Semester' >
<annotation>This simple transform is executed as a subtransform as we need to perform the same action in Demo.ComplexMap.Transform.CreateStudentBatch.</annotation>
</subtransform>
<foreach property='source.Students()' key='k1' >
<foreach property='source.Students.(k1).ClassInfo()' key='k2' >
<if condition='&apos;$data(classMap(source.Students.GetValueAt(k1).ClassInfo.GetValueAt(k2).ClassID,source.Students.GetValueAt(k1).ClassInfo.GetValueAt(k2).SectionID))' >
<true>
<assign value='source.Students.(k1).ClassInfo.(k2).ClassID' property='target.Classes.(k2).ClassID' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).SectionID' property='target.Classes.(k2).SectionID' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).Title' property='target.Classes.(k2).Title' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).Grade' property='target.Classes.(k2).Grade' action='set' />
<assign value='1' property='classMap(source.Students.GetValueAt(k1).ClassInfo.GetValueAt(k2).ClassID,source.Students.GetValueAt(k1).ClassInfo.GetValueAt(k2).SectionID)' action='set' />
</true>
</if>
</foreach>
<code>
<![CDATA[ Set tSC = source.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit
 Set tSC = target.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit]]]]><![CDATA[></code>
</foreach>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.ComplexMap.Transform.SemesterBatchToFixedClassBatch">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,64977.643692</TimeCreated>
<DependsOn>Demo.ComplexMap.Semester.Batch,Demo.ComplexMap.SemesterFixed.ClassBatch</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.ComplexMap.Semester.Batch' targetClass='Demo.ComplexMap.SemesterFixed.ClassBatch' create='new' language='objectscript' >
<subtransform class='Demo.ComplexMap.Transform.SemesterToFixedSemester' targetObj='target.Semester' sourceObj='source.Semester' >
<annotation>This simple transform is executed as a subtransform as we need to perform the same action in Demo.ComplexMap.Transform.CreateStudentBatch.</annotation>
</subtransform>
<assign value='0' property='Count' action='set' />
<foreach property='source.Students()' key='k1' >
<foreach property='source.Students.(k1).ClassInfo()' key='k2' >
<if condition='&apos;$data(classMap(source.Students.GetAt(k1).ClassInfo.GetAt(k2).ClassID,source.Students.GetAt(k1).ClassInfo.GetAt(k2).SectionID))' >
<true>
<assign value='Count + 1' property='Count' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).ClassID' property='target.Classes.(Count).ClassID' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).SectionID' property='target.Classes.(Count).SectionID' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).Title' property='target.Classes.(Count).Title' action='set' />
<assign value='source.Students.(k1).ClassInfo.(k2).Grade' property='target.Classes.(Count).Grade' action='set' />
<assign value='1' property='target.Classes.(Count).StudentCount' action='set' />
<assign value='Count' property='classMap(source.Students.GetAt(k1).ClassInfo.GetAt(k2).ClassID,source.Students.GetAt(k1).ClassInfo.GetAt(k2).SectionID)' action='set' />
</true>
<false>
<assign value='classMap(source.Students.GetAt(k1).ClassInfo.GetAt(k2).ClassID,source.Students.GetAt(k1).ClassInfo.GetAt(k2).SectionID)' property='index' action='set' />
<assign value='target.Classes.(index).StudentCount + 1' property='target.Classes.(index).StudentCount' action='set' />
<assign value='target.Classes.(index).Grade + source.Students.(k1).ClassInfo.(k2).Grade' property='target.Classes.(index).Grade' action='set' />
</false>
</if>
</foreach>
<code>
<![CDATA[ Set tSC = source.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit]]]]><![CDATA[></code>
</foreach>
<foreach property='target.Classes()' key='k3' >
<assign value='..Round(target.Classes.(k3).Grade / target.Classes.(k3).StudentCount,1)' property='target.Classes.(k3).Grade' action='set' >
<annotation>Compute average grade for each class.</annotation>
</assign>
</foreach>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.ComplexMap.Transform.SemesterBatchToFixedStudentBatch">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62798,59561.884295</TimeCreated>
<DependsOn>Demo.ComplexMap.Semester.Batch,Demo.ComplexMap.SemesterFixed.StudentBatch</DependsOn>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.ComplexMap.Semester.Batch' targetClass='Demo.ComplexMap.SemesterFixed.StudentBatch' create='new' language='objectscript' >
<assign value='source.%Source' property='target.%Source' action='set' />
<subtransform class='Demo.ComplexMap.Transform.SemesterToFixedSemester' targetObj='target.Semester' sourceObj='source.Semester' />
<assign value='source.Students.Count()' property='target.Semester.RecordCount' action='set' />
<foreach property='source.Students()' key='k1' >
<assign value='source.Students.(k1).Student.StudentID' property='target.Students.(k1).StudentID' action='set' />
<assign value='source.Students.(k1).Student.LastName' property='target.Students.(k1).LastName' action='set' />
<assign value='source.Students.(k1).Student.FirstName' property='target.Students.(k1).FirstName' action='set' />
<assign value='source.Students.(k1).Student.MiddleName' property='target.Students.(k1).MiddleName' action='set' />
<assign value='source.Students.(k1).Student.Grade' property='target.Students.(k1).Grade' action='set' />
<assign value='source.Students.(k1).Student.Email' property='target.Students.(k1).Email' action='set' />
<assign value='source.Students.(k1).Student.Phone' property='target.Students.(k1).Phone' action='set' />
<code>
<![CDATA[ Set tSC = source.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit
 Set tSC = target.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit]]]]><![CDATA[></code>
</foreach>
</transform>
]]></Data>
</XData>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>
</Class>


<Class name="Demo.ComplexMap.Transform.SemesterBatchToSemesterSummaryBatch">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62770,56384.269643</TimeCreated>
<DependsOn>Demo.ComplexMap.Semester.Batch,Demo.ComplexMap.Summary.SummaryBatch</DependsOn>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.ComplexMap.Semester.Batch' targetClass='Demo.ComplexMap.Summary.SummaryBatch' create='new' language='objectscript' >
<assign value='source.%Source' property='target.%Source' action='set' />
<assign value='source.Semester.SemesterID' property='target.Semester.SemesterID' action='set' />
<assign value='source.Semester.Year' property='target.Semester.Year' action='set' />
<assign value='source.Semester.Name' property='target.Semester.Name' action='set' />
<assign value='source.Semester.NumWeeks' property='target.Semester.NumWeeks' action='set' />
<assign value='0' property='totalClasses' action='set' >
<annotation>Counter for the total number of classes in the semester.</annotation>
</assign>
<assign value='0' property='totalStudents' action='set' />
<assign value='0' property='totalGPA' action='set' >
<annotation>Local variable to store the sum of the GPAs we see.</annotation>
</assign>
<foreach property='source.Students()' key='k1' >
<assign value='totalStudents + 1' property='totalStudents' action='set' />
<assign value='0' property='studentClasses' action='set' />
<assign value='0' property='studentGPA' action='set' />
<assign value='source.Students.(k1).Student.StudentID' property='target.Students.(k1).Student.StudentID' action='set' />
<assign value='source.Students.(k1).Student.LastName' property='target.Students.(k1).Student.Name.Family' action='set' />
<assign value='source.Students.(k1).Student.FirstName' property='target.Students.(k1).Student.Name.Given' action='set' />
<assign value='source.Students.(k1).Student.MiddleName' property='target.Students.(k1).Student.Name.Middle' action='set' />
<assign value='source.Students.(k1).Student.Grade' property='target.Students.(k1).Student.Grade' action='set' />
<assign value='source.Students.(k1).Student.Email' property='target.Students.(k1).Student.Email' action='set' />
<assign value='source.Students.(k1).Student.Phone' property='target.Students.(k1).Student.Phone' action='set' />
<foreach property='source.Students.(k1).ClassInfo()' key='k2' >
<assign value='source.Students.(k1).ClassInfo.(k2)' property='target.Students.(k1).ClassInfo.(k2)' action='set' />
<assign value='studentClasses + 1' property='studentClasses' action='set' />
<assign value='studentGPA + source.Students.(k1).ClassInfo.(k2).Grade' property='studentGPA' action='set' />
</foreach>
<assign value='studentClasses' property='target.Students.(k1).Student.NumberClasses' action='set' />
<assign value='..Round(studentGPA / studentClasses,1)' property='target.Students.(k1).Student.GPA' action='set' />
<assign value='totalClasses + studentClasses' property='totalClasses' action='set' />
<assign value='totalGPA + studentGPA' property='totalGPA' action='set' />
<code>
<annotation>Ensure that we don&#39;t keep unnecessary object references in memory</annotation>
<![CDATA[ Set tSC = source.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit]]]]><![CDATA[></code>
</foreach>
<assign value='totalStudents' property='target.Semester.NumberStudents' action='set' />
<assign value='..Round(totalGPA / totalClasses,1)' property='target.Semester.AverageGPA' action='set' />
</transform>
]]></Data>
</XData>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>
</Class>


<Class name="Demo.ComplexMap.Transform.SemesterToFixedSemester">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62797,65109.640551</TimeCreated>
<DependsOn>Demo.ComplexMap.Semester.SemesterHeader.Record,Demo.ComplexMap.SemesterFixed.Semester.Record</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.ComplexMap.Semester.SemesterHeader.Record' targetClass='Demo.ComplexMap.SemesterFixed.Semester.Record' create='new' language='objectscript' >
<assign value='source.%Source' property='target.%Source' action='set' />
<assign value='source.SemesterID' property='target.SemesterID' action='set' />
<assign value='source.Year' property='target.Year' action='set' />
<assign value='source.Name' property='target.Name' action='set' />
<assign value='source.NumWeeks' property='target.NumWeeks' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.ComplexMap.Transform.SummarizeSemesterBatch">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62770,56384.269643</TimeCreated>
<DependsOn>Demo.ComplexMap.Semester.Batch,Demo.ComplexMap.Summary.SummaryBatch</DependsOn>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.ComplexMap.Semester.Batch' targetClass='Demo.ComplexMap.Summary.SummaryBatch' create='new' language='objectscript' >
<assign value='source.%Source' property='target.%Source' action='set' />
<assign value='source.Semester.SemesterID' property='target.Semester.SemesterID' action='set' />
<assign value='source.Semester.Year' property='target.Semester.Year' action='set' />
<assign value='source.Semester.Name' property='target.Semester.Name' action='set' />
<assign value='source.Semester.NumWeeks' property='target.Semester.NumWeeks' action='set' />
<assign value='0' property='totalClasses' action='set' >
<annotation>Counter for the total number of classes in the semester.</annotation>
</assign>
<assign value='0' property='totalStudents' action='set' />
<assign value='0' property='totalGPA' action='set' >
<annotation>Local variable to store the sum of the GPAs we see.</annotation>
</assign>
<foreach property='source.Students()' key='k1' >
<assign value='totalStudents + 1' property='totalStudents' action='set' />
<assign value='0' property='studentClasses' action='set' />
<assign value='0' property='studentGPA' action='set' />
<assign value='source.Students.(k1).Student.StudentID' property='target.Students.(k1).Student.StudentID' action='set' />
<assign value='source.Students.(k1).Student.LastName' property='target.Students.(k1).Student.Name.Family' action='set' />
<assign value='source.Students.(k1).Student.FirstName' property='target.Students.(k1).Student.Name.Given' action='set' />
<assign value='source.Students.(k1).Student.MiddleName' property='target.Students.(k1).Student.Name.Middle' action='set' />
<assign value='source.Students.(k1).Student.Grade' property='target.Students.(k1).Student.Grade' action='set' />
<assign value='source.Students.(k1).Student.Email' property='target.Students.(k1).Student.Email' action='set' />
<assign value='source.Students.(k1).Student.Phone' property='target.Students.(k1).Student.Phone' action='set' />
<foreach property='source.Students.(k1).ClassInfo()' key='k2' >
<assign value='source.Students.(k1).ClassInfo.(k2)' property='target.Students.(k1).ClassInfo.(k2)' action='set' />
<assign value='studentClasses + 1' property='studentClasses' action='set' />
<assign value='studentGPA + source.Students.(k1).ClassInfo.(k2).Grade' property='studentGPA' action='set' />
</foreach>
<assign value='studentClasses' property='target.Students.(k1).Student.NumberClasses' action='set' />
<assign value='..Round(studentGPA / studentClasses,1)' property='target.Students.(k1).Student.GPA' action='set' />
<assign value='totalClasses + studentClasses' property='totalClasses' action='set' />
<assign value='totalGPA + studentGPA' property='totalGPA' action='set' />
<code>
<annotation>Ensure that we don&#39;t keep unnecessary object references in memory</annotation>
<![CDATA[ Set tSC = source.Students.%UnSwizzleAt(k1)
 If $$$ISERR(tSC) Quit]]]]><![CDATA[></code>
</foreach>
<assign value='totalStudents' property='target.Semester.NumberStudents' action='set' />
<assign value='..Round(totalGPA / totalClasses,1)' property='target.Semester.AverageGPA' action='set' />
</transform>
]]></Data>
</XData>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>
</Class>


<Class name="Demo.CustomSearchTable.Sample">
<Description><![CDATA[
This is a sample CustomSearchTable to demonstrate the some of the primary features of 
custom search tables by showing possible indexing strategies for the <class>Ens.StreamContainer</class> class.<br/>
The SearchTable implements a multi-index approach to indexing the first 12 characters of the
target Stream property using bitmap indices on <property>%FirstFour</property>, <property>%SecondFour</property> and
<property>%ThirdFour</property>. The underlying properties start with the "%" character so they are not
directly exposed to users as options - instead, the Stream12 virtual property is listed as an indexed property
in <method>GetVirtualPropertyList</method>(), so users can search on the first 12 characters. The actual search implementation
is in the <method>OnProcessCondition</method>() callback so that the indices are used by the SQL engine. <br/>
The Stream250Early and Stream250Late virtual properties demonstrate the two options available for retrieving and displaying
the first 250 characters of the stream without needing to index the contents of the stream. 
The Stream250Early property is fetched "Early" because it is fetched using an SQL stored procedure during the SQL processing of results
and any conditions on the property are applied by the SQL engine. The Stream250Late property is fetched "Late" because it is 
fetched using a COS callback after the SQL engine has constructed a result set, so any conditions are applied as the COS code iterates
over the results produced using standard SQL. Both properties are listed as non-indexed virtual properties in 
<method>GetVirtualPropertyList</method>(), and the code to actually fetch the values is implemented in <method>GetVirtualProperty</method>().]]></Description>
<Super>Ens.CustomSearchTable</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62304,60720.273674</TimeCreated>

<Parameter name="DOCCLASS">
<Description><![CDATA[
This class is intended to index <class>Ens.StreamContainer</class> messages.
The <class>EnsLib.File.PassthroughService</class> and <class>EnsLib.FTP.PassthroughService</class>
services send these messages, so you can experiment by indexing messages as sent by these services.]]></Description>
<Default>Ens.StreamContainer</Default>
</Parameter>

<Property name="OrigFilename">
<Description>
OrigFilename is stored as a non-indexed property of the SearchTable class.
This is somewhat redundant, but means that SQL operations which display this value
don't need to load data from the original data location when the SearchTable is used
to perform comparisons in a query.</Description>
<Type>%String</Type>
</Property>

<Property name="Type">
<Description>
Type describes the type of stream referenced in the Stream property of the StreamContainer.
It is a short text code, so lends itself to creating a bitmap index -- see the Type for details.
The property is also declared with EXACT collation to ensure that any character-based matches
are peformed using exact matching and NOT the default of uppercase matching.</Description>
<Type>%String</Type>
<Parameter name="COLLATION" value="EXACT"/>
</Property>

<Index name="Type">
<Description><![CDATA[
The Type index is declared as a bitmap index as the <property>Type</property> property contains a short character
code, so it is very efficient to match on specific values for this field.]]></Description>
<Type>bitmap</Type>
<Properties>Type</Properties>
</Index>

<Property name="%FirstFour">
<Description>
%FirstFour is intended to capture the first four characters of the StreamContainer's Stream contents.
The property demonstrates how properties which start with "%" are not displayed to the user, but may be used
when constructing queries. The four character restriction is imposed to allow the First bitmap 
index to be created on only these characters.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="4"/>
</Property>

<Index name="First">
<Description>
This is a bitmap index on the first four characters of the stream's contents. It is intended to be used in 
conjunction with the Second and Third indices to find the first 12 characters of
stream contents very efficiently. The eventual goal is to use a virtual property which relies on these indices
to construct rapid searches on the underlying data without needing expensive reads of the entire stream from disk.</Description>
<Type>bitmap</Type>
<Properties>%FirstFour</Properties>
</Index>

<Property name="%SecondFour">
<Description>
%SecondFour is intended to capture the second four characters of the StreamContainer's Stream contents.
The property demonstrates how properties which start with "%" are not displayed to the user, but may be used
when constructing queries. The four character restriction is imposed to allow the Second bitmap
index to be created on only these characters.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="4"/>
</Property>

<Index name="Second">
<Description>
This is a bitmap index on the second four characters of the stream's contents. It is intended to be used in 
conjunction with the First and Third indices to find the first 12 characters of
stream contents very efficiently. The eventual goal is to use a virtual property which relies on these indices
to construct rapid searches on the underlying data without needing expensive reads of the entire stream from disk.</Description>
<Type>bitmap</Type>
<Properties>%SecondFour</Properties>
</Index>

<Property name="%ThirdFour">
<Description>
%ThirdFour is intended to capture the third four characters of the StreamContainer's Stream contents.
The property demonstrates how properties which start with "%" are not displayed to the user, but may be used
when constructing queries. The four character restriction is imposed to allow the Third bitmap
index to be created on only these characters.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="4"/>
</Property>

<Index name="Third">
<Description>
This is a bitmap index on the third four characters of the stream's contents. It is intended to be used in 
conjunction with the First and Second indices to find the first 12 characters of
stream contents very efficiently. The eventual goal is to use a virtual property which relies on these indices
to construct rapid searches on the underlying data without needing expensive reads of the entire stream from disk.</Description>
<Type>bitmap</Type>
<Properties>%ThirdFour</Properties>
</Index>

<Method name="OnProcessCondition">
<Description><![CDATA[
Callback invoked by the Message Viewer UI whenever a condition for a CustomSearchTable
is selected. <var>pProperty</var> specifies the property name to be retrieved. Note: <var>pProperty</var> may be
the empty string when adding a SearchTable for the first time. Ensure that the code in this method handles this case.
<var>pDisplayOnly</var> indicates whether the user has selected the property as a display-only field. If <var>pDisplayOnly</var>
is true, the values for the value and operator supplied in <var>pValue</var> and <var>pOperator</var>, respectively,
should be ignored and no conditions should be added to the WHERE clause. If <var>pDisplayOnly</var> is false,
users should make use of the GetSQLCondition() API in <class>EnsPortal.MsgFilter.Assistant</class> to produce
valid SQL WHERE conditions based on the supplied arguments. <var>pTableName</var> specifies the name of the table to
use in the FROM clause, and <var>pTableInFrom</var> indicates whether the table is already present in the FROM clause.
<var>pSelectAsName</var> is the alias which should be used for the column in the eventual resultset.
The <var>pSelect</var>, <var>pFrom</var> and <var>pWhere</var> arguments are strings which determine which subclauses (if any)
should be added to the corresponding sections of the overall SQL query, and can be modified as needed while in this callback. The
<var>pSQLFetch</var> flag indicates whether the value will be completely fetched by the supplied SQL terms. By default, ALL virtual
properties will only be retrieved using ObjectScript AFTER the main SQL results have been produced. The purpose of this is to allow
the post-SQL filter code to load all encountered virtual properties using the <method>GetVirtualProperties</method>() API.
Users should override this behaviour when indices are available in this class to improve the fetch performance of the generated query.
In a similar vein, users may want to delay retrieval of non-indexed standard properties until after the SQL phase is complete, though
this is not necessarily more efficient.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pProperty:%String,pOperator:%String,pValue:%String,pTableName:%String,pTableInFrom:%Boolean,pSelectAsName:%String,pDisplayOnly:%Boolean=0,&pSelect:%String,&pFrom:%String,&pWhere:%String,&pSQLFetch:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Ensure the source table has been added to the FROM clause as we reference the table in the SELECT clause
	If 'pTableInFrom {
		Set pFrom = pFrom _ $select(pFrom = "": "", 1: ", ") _ pTableName
	}
	If (pProperty = "Stream12") {
		// Indicate that all processing will occur in the SQL query
		Set pSQLFetch = 1
		// Add the properties to the SELECT clause
		Set pSelect = "("_pTableName_".%FirstFour || "_pTableName_".%SecondFour || "_pTableName_".%ThirdFour) As "_pSelectAsName
		If 'pDisplayOnly {
			// Get the requested values
			Set tValOne = $extract(pValue,1,4)
			Set tValTwo = $extract(pValue,5,8)
			Set tValThree = $extract(pValue,9,12)
		
			// Use the GetSQLCondition() helper method in EnsPortal.MsgFilter.Assistant to get a valid WHERE subclause for each comparison
			Set tWhere(1) = ##class(EnsPortal.MsgFilter.Assistant).GetSQLCondition(pOperator,pTableName_".%FirstFour",tValOne)
			Set tWhere(2) = ##class(EnsPortal.MsgFilter.Assistant).GetSQLCondition(pOperator,pTableName_".%SecondFour",tValTwo)
			Set tWhere(3) = ##class(EnsPortal.MsgFilter.Assistant).GetSQLCondition(pOperator,pTableName_".%ThirdFour",tValThree)
			// Add the conditions to the WHERE clause
			For i=1:1:3 {
				Set pWhere = pWhere _ $select(pWhere = "": "", tWhere(i) = "": "", 1: " AND ") _ tWhere(i)
			}
		}
	}
	ElseIf (pProperty = "Stream250Early") {
		// Override the default behaviour for virtual properties and fetch the data using the Stored Procedure API.
		Set pSQLFetch = 1
		Set tProc = "Ens.CustomSearchTable_GetVirtualPropertyProc('"_$classname()_"',head.MessageBodyId,'Stream250Early')"
		Set pSelect = tProc _ " As " _ pSelectAsName
		// Add conditions if needed
		If 'pDisplayOnly {
			Set tWhere = ##class(EnsPortal.MsgFilter.Assistant).GetSQLCondition(pOperator,tProc,pValue)
			If tWhere '= "" Set pWhere = pWhere _ $select(pWhere = "": "", 1: " AND ") _ tWhere
		}
	}
	ElseIf (pProperty = "StreamType") || (pProperty = "Stream250Late"){
		// The default behaviour for virtual properties to add a clause where we SELECT NULL As SearchTable_Alias
		// So we don't need to do anything for this case.
	}
	// We can also modify the way standard fields are fetched, as this method is invoked for ALL requested types.
	// By default, Type and OriginalFilename will be fetched directly using SQL references against the table.
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetVirtualPropertyList">
<Description><![CDATA[
We provide a number of virtual properties in this class.
Stream12 is a virtual property which represents the first 12 characters of the stream, which are indexed.
Stream250Early and Stream250Late both represent the first 250 characters of the stream which are not indexed.
Stream250Early is a virtual property which is fetched via a stored procedure during SQL execution, while
Stream250Late is a virtual property which is fetched via the <method>GetVirtualProperties</method>() API.
StreamType is a virtual property which represents the actual stream type and is fetched via the <method>GetVirtualProperties()</method> API.
For both of the last two properties, code is needed in <method>OnProcessCondition</method>() to indicate that
the property should not be fetched via SQL.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pIndexedVirtualProperties:%List,*pVirtualProperties:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pIndexedVirtualProperties = $lb("Stream12")
	Set pVirtualProperties = $lb("Stream250Early","Stream250Late","StreamType")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetVirtualProperty">
<Description><![CDATA[
API to retrieve a named virtual property for a given document ID.
If a virtual property is specified in <method>GetVirtualPropertyList</method>(), this
method should be updated to implement retrieval code for the property. Note that if
<method>GetVirtualProperties</method>() is overridden, this method may not be called for value retrieval.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDocID:%String,pPropName:%String,*pPropValue:%String,&pUserArgs]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pPropValue = ""
	If (pPropName = "Stream250Early") || (pPropName = "Stream250Late") {
		Set tContainer = ##class(Ens.StreamContainer).%OpenId(pDocID)
		If $IsObject(tContainer) && $IsObject(tContainer.Stream) {
			Set pPropValue = tContainer.Stream.Read(250)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnIndexDoc">
<Description><![CDATA[
Callback which should be implemented by users to populate the CustomSearchTable
supplied in <var>Ens.CustomSearchTable</var> based on <var>pDocObj</var>. Note that
the DocId property is prepopulated, so doesn't need to be reset. If the user doesn't
want a particular CustomSearchTable instance to be saved, the user can set <var>pSearchTable</var>
to the empty string (i.e. "") to prevent the indexing framework from saving an entry to disk.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj:Ens.StreamContainer,pSearchTable:Demo.CustomSearchTable.Sample</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSearchTable.OrigFilename = pDocObj.OriginalFilename
	Set pSearchTable.Type = pDocObj.Type
	Do pDocObj.Stream.Rewind()
	Set tTwelve = pDocObj.Stream.Read(12)
	Do pDocObj.Stream.Rewind()
	Set pSearchTable.%FirstFour = $extract(tTwelve,1,4)
	Set pSearchTable.%SecondFour = $extract(tTwelve,5,8)
	Set pSearchTable.%ThirdFour = $extract(tTwelve,9,12)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetVirtualProperties">
<Description><![CDATA[
Override of the base implementation of GetVirtualProperties(). We only load the
target <class>Ens.StreamContainer</class> object once when retrieving multiple
values for the instance.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocID:%String,pPropNames:%List,*pPropValues:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pPropValues = ""
	If $listlength($get(pPropNames)) = 0 Quit tSC
	Set tContainer = ##class(Ens.StreamContainer).%OpenId(pDocID)
	If $IsObject(tContainer) {
		Do tContainer.Stream.Rewind()
		Set tFirst250 = $select($listfind(pPropNames,"Stream250Late") || $listfind(pPropNames,"Stream250Early"): tContainer.Stream.Read(250), 1: "")
		For i=1:1:$ll(pPropNames) {
			Set tProp = $lg(pPropNames,i)
			Set $li(pPropValues,i) = $case(tProp,
										"StreamType": $classname(tContainer.Stream),
										"Stream250Early": tFirst250,
										"Stream250Late": tFirst250,
										: "")
		}
		Do tContainer.Stream.Rewind()
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.CustomSearchTable.SampleD</DataLocation>
<DefaultData>SampleDefaultData</DefaultData>
<IdLocation>^Demo.CustomSearchTable.SampleD</IdLocation>
<IndexLocation>^Demo.CustomSearchTable.SampleI</IndexLocation>
<StreamLocation>^Demo.CustomSearchTable.SampleS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="SampleDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DocId</Value>
</Value>
<Value name="3">
<Value>OrigFilename</Value>
</Value>
<Value name="4">
<Value>Type</Value>
</Value>
<Value name="5">
<Value>%FirstFour</Value>
</Value>
<Value name="6">
<Value>%SecondFour</Value>
</Value>
<Value name="7">
<Value>%ThirdFour</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.BatchedDocument">
<Description>
Stores Session id's and DICOM document id's for batch transfer
of DICOM images from AsyncRouterDispatcher to AsyncRouterFiler
so the filer can send all messages from a given session within
the same association context.
Entries of images sent to the target system successfully will
be updated with a DocumentStatus of 'Delivered'</Description>
<Super>%Persistent</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64212,43978.326505</TimeCreated>

<Property name="SessionId">
<Type>%String</Type>
<SqlColumnNumber>2</SqlColumnNumber>
</Property>

<Property name="FilerConfigName">
<Type>%String</Type>
<SqlColumnNumber>3</SqlColumnNumber>
</Property>

<Property name="DICOMDocumentId">
<Type>%String</Type>
<SqlColumnNumber>4</SqlColumnNumber>
</Property>

<Property name="DICOMMessageId">
<Type>%String</Type>
<SqlColumnNumber>5</SqlColumnNumber>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="AffectedSOPInstanceUID">
<Type>%String</Type>
<SqlColumnNumber>6</SqlColumnNumber>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="DocumentStatus">
<Type>%String</Type>
<InitialExpression>"Queued"</InitialExpression>
<SqlColumnNumber>7</SqlColumnNumber>
<Parameter name="VALUELIST" value=",Queued,Ignored,Sent,Delivered,Errored"/>
</Property>

<Property name="Remark">
<Type>%String</Type>
<SqlColumnNumber>8</SqlColumnNumber>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="Created">
<Type>Ens.DataType.UTC</Type>
<SqlColumnNumber>9</SqlColumnNumber>
</Property>

<Property name="LastUpdated">
<Type>Ens.DataType.UTC</Type>
<SqlColumnNumber>10</SqlColumnNumber>
</Property>

<Index name="idxFilerConfigName">
<Type>bitmap</Type>
<Properties>FilerConfigName</Properties>
</Index>

<Index name="idxAffectedSOPInstanceUID">
<Properties>AffectedSOPInstanceUID</Properties>
</Index>

<Index name="idxSessionId">
<Properties>SessionId</Properties>
</Index>

<Index name="idxDocumentStatus">
<Type>bitmap</Type>
<Properties>DocumentStatus</Properties>
</Index>

<Method name="%OnBeforeSave">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Save</METHOD> method to 
provide notification that the object is being saved. It is called before 
any data is written to disk.

<P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.

<P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.]]></Description>
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If insert {
		Set ..Created=$$$timeUTC
	} Else {
		
		Set ..LastUpdated=$$$timeUTC
	}
   Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.DICOM.BatchedDocumentD</DataLocation>
<DefaultData>BatchedDocumentDefaultData</DefaultData>
<IdLocation>^Demo.DICOM.BatchedDocumentD</IdLocation>
<IndexLocation>^Demo.DICOM.BatchedDocumentI</IndexLocation>
<StreamLocation>^Demo.DICOM.BatchedDocumentS</StreamLocation>
<Data name="BatchedDocumentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>SessionId</Value>
</Value>
<Value name="3">
<Value>FilerConfigName</Value>
</Value>
<Value name="4">
<Value>DICOMDocumentId</Value>
</Value>
<Value name="5">
<Value>DICOMMessageId</Value>
</Value>
<Value name="6">
<Value>AffectedSOPInstanceUID</Value>
</Value>
<Value name="7">
<Value>DocumentStatus</Value>
</Value>
<Value name="8">
<Value>Remark</Value>
</Value>
<Value name="9">
<Value>Created</Value>
</Value>
<Value name="10">
<Value>LastUpdated</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Operation.File">
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62370,40767.163239</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This is the directory where the local files will be stored</Description>
<Default>FileStorageDirectory</Default>
</Parameter>

<Property name="FileStorageDirectory">
<Description>
This is the directory where the incoming DICOM files will be stored</Description>
<Type>%String</Type>
<InitialExpression>"/"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Method name="OnMessage">
<Description>
This is the default message handler.  All request types not declared in the message map are delivered here</Description>
<FormalSpec>pRequest:%Library.Persistent,*pResponse:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tFile As EnsLib.DICOM.File
	#dim tFileName As %String
	try {
		
		#; We should only ever see DICOM Documents here
		$$$ASSERT(pRequest.%Extends("EnsLib.DICOM.Document"))
		
		#; Create a DICOM File from the DICOM document
		Set tSC=##class(EnsLib.DICOM.File).CreateFromDocument(pRequest,.tFile)
		If $$$ISERR(tSC) Quit
		
		#; Create a unique filename
		Set tFileName=..NewFilename(..FileStorageDirectory)
		
		#; Create a new file with a unique name and the dcm extension in the target directory
		Set tSC=tFile.Save(tFileName)
		
	} catch(e) {
		Set tSC=e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="NewFilename">
<Description>
Create a new file name within the specified directory</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>dir</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(%File).NormalizeDirectory(dir)_(##class(%FileBinaryStream).NewFileName("dcm"))
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Process.AsyncRouterDispatcher">
<Description><![CDATA[
<class>Demo.DICOM.Process.AsyncRouterDispatcher</class> acts as the target AET for other AET's
sending DICOM images using a DICOM C-STORE-Req. 
All images sent within an DICOM association context are stored. Once the association
is released by the sending AET, a signal message containing the session id
is sent to all configured DICOM Router/filers asynchronously (outside the DICOM
protocol). The files will then forward the stored images to the configured targets.
This allows for routing of DICOM images to multiple targets where the transfer to 
each individual target happens within a single association. This approach avoids 
performance issues when studies/series with lots of images are routed to multiple targets.]]></Description>
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64210,37728</TimeCreated>

<Parameter name="SETTINGS">
<Default><![CDATA[FilerConfigNames:Basic:selector?multiSelect=1&context={Ens.ContextSearch/ProductionItems?productionName=@productionId&className=Demo.DICOM.Process.AsyncRouterFiler},RuleClass:Basic:selector?context={Ens.ContextSearch/SubclassOf?class=Demo.DICOM.Util.AbstractRoutingRule&abstract=0},StoreIgnoredEntries:Basic]]></Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>ENSDEMO</Default>
</Parameter>

<Property name="FilerConfigNames">
<Description>
This is the (comma separated) list of configuration names of the router filer process(es)</Description>
</Property>

<Property name="RuleClass">
<Description>
DICOM Routing Class to be used for evaluation if individual images are to be sent to the specified filer(s).</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="StoreIgnoredEntries">
<Description>
If set to TRUE, status entries of DICOM documents not being sent to the target filer will be stored with a Document Status of 'Ignored'</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="OnMessage">
<Description>
Messages received here are instances of EnsLib.DICOM.Document sent to this process by the service.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tCounter As %Integer
	#dim tMsgType,tFilerName As %String
	#dim tOutput As EnsLib.DICOM.Document
	#dim tDCMBatch As Demo.DICOM.BatchedDocument
	#dim tRouteToFiler As %Boolean=1
	#dim tReason As %String=""
	
	Do {
		
		#; We should only ever see DICOM Documents here
		$$$ASSERT(pInput.%Extends("EnsLib.DICOM.Document"))
		
 		#; If its a document sent from the service
 		If pSourceConfigName=..ServiceDuplexName {
	 		
	 		If pInput.%Extends("EnsLib.DICOM.Document") {
	 		
				#; Get the CommandField, it contains the type of request and should ALWAYS be present
				Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
				If $$$ISERR(tSC) Quit	
				
				#; We should only ever see DICOM store requests here
				$$$ASSERT(tMsgType="C-STORE-RQ")

				#; Here we walk through the filer names and store the document id for each one.
				For tCounter=1:1:$Length(..FilerConfigNames,",") {
					
					#; Get one filer name
					Set tFilerName=$Piece(..FilerConfigNames,",",tCounter)
					
					#; Don't send to an empty filer
					If tFilerName'="" {
						
						#; Call RuleClass if it is specified
						If ..RuleClass'="" {
							If ##class(%Dictionary.CompiledClass).%ExistsId(..RuleClass) && ##class(%Dictionary.CompiledMethod).%ExistsId(..RuleClass_"||SendToTargetFiler") {
								
								Set tSC=$Classmethod(..RuleClass,"SendToTargetFiler",pInput,tFilerName,.tRouteToFiler, .tReason)
								If $$$ISERR(tSC) Quit
							} Else {
								
								Set tSC = $$$ERROR($$$GeneralError,$$$FormatText($$$Text("Invalid Rule Class specified. Routing method '%1' not defined"),..RuleClass_"||SendToTargetFiler"))
								Quit
							}
						}

						If tRouteToFiler || ..StoreIgnoredEntries {
							#; Store the document id as entry in Demo_DICOM.BatchedDocument
							Set tDCMBatch=##class(Demo.DICOM.BatchedDocument).%New()
							Set tDCMBatch.DICOMDocumentId=pInput.%Id()
							Set tDCMBatch.SessionId=..%SessionId
							Set tDCMBatch.FilerConfigName=tFilerName
							Set tDCMBatch.AffectedSOPInstanceUID=pInput.GetValueAt("CommandSet.AffectedSOPInstanceUID",,.tSC)
							Set tDCMBatch.DICOMMessageId=pInput.GetValueAt("CommandSet.MessageID",,.tSC)
							
							If 'tRouteToFiler {
								Set tDCMBatch.DocumentStatus="Ignored"
							
							}
							Set tDCMBatch.Remark=tReason
							
							Set tSC=tDCMBatch.%Save()
							
							#; Need to check status from loop above
							If $$$ISERR(tSC) Quit
						}
						
					}
				}
				If $$$ISERR(tSC) Quit
				
				#; We need to create a C-STORE-RSP and send to the modality
				Set tSC=..CreateStorageResponse(pInput,.tOutput)
				If $$$ISERR(tSC) Quit
				
				#; We HAVE created an output object
				$$$ASSERT($IsObject(tOutput))
				
				#; Send the reply back to the service ( don't want a response )
				Set tSC=..SendRequestAsync(..ServiceDuplexName,tOutput,0)
				If $$$ISERR(tSC) Quit

			}
		} 
	 		
	} while (0)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateStorageResponse">
<Description>
Create a storage response DICOM message</Description>
<FormalSpec>pDocIn:EnsLib.DICOM.Document,*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tTemp As %String
	
	Try {
		
		#; Create an instance of a DICOM Document to form the response
		Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New()
		If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
		
		#; Need to copy over the AffectedSOPClassUID (mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPClassUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPClassUID")
		If $$$ISERR(tSC) Quit
		
		#; Set the CommandField, this is a Storage Response
		Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-STORE-RSP"),"CommandSet.CommandField")
		If $$$ISERR(tSC) Quit
		
		#; And indicate the message id being responded to by copying over the originating message id
		Set tTemp=pDocIn.GetValueAt("CommandSet.MessageID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.MessageIDBeingRespondedTo")
		If $$$ISERR(tSC) Quit
		 
		#; Need to copy over the affected SOP instance id
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPInstanceUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPInstanceUID")
		If $$$ISERR(tSC) Quit
		
		#; Need to copy over the transfer syntax
		Set pDocOut.DataSet.TransferSyntax=pDocIn.DataSet.TransferSyntax
		
		#; Finally set a success status
		Set tSC=pDocOut.SetValueAt(0,"CommandSet.Status") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationErrored">
<Description>
This callback is called by the framework when an assocation encounters an error</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Errored</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Don't ignore the error, this will cause the BP to terminate
	Quit pInput.Status
]]></Implementation>
</Method>

<Method name="OnAssociationAborted">
<Description>
This callback is called by the framework when an association is aborted</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Aborted</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Don't ignore the error, this will cause the BP to terminate
	Quit $$$ERROR($$$EnsDICOMPeerRequestedAbort)
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tCommandAbort As EnsLib.DICOM.Command.Abort
        
    #; Form an abort message
    Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
    
    #; Send it to the operation
    Do ..AbortAssociation(..ServiceDuplexName,tCommandAbort)
    
    #; Still send any DICOM documents which have been received along to the filers 
	Do ..SendToFilers()
	
	#; Don't ignore the error, this will cause the BP to terminate
	Quit pErrorStatus
]]></Implementation>
</Method>

<Method name="OnAssociationReleased">
<Description>
This callback is called by the framework when an Association is released</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Released</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Association release is the trigger for sending the signal message to the filers
	Quit ..SendToFilers()
]]></Implementation>
</Method>

<Method name="SendToFilers">
<Description>
Send a signal message containing the session id to all configured DICOM filers asynchronously</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status=$$$OK
	#dim ex As %Exception.AbstractException
	#dim tRequest As Ens.StringRequest
	#dim tSessionId As %String
	#dim tCounter As %Integer
	#dim tCount As %Integer=0
	
	Try {
				
		Set tSessionId=..%SessionId
		
		#; Here we walk through the filer names and send the sessionId to each one that has DICOM documents to be sent.
		For tCounter=1:1:$Length(..FilerConfigNames,",") {
			
			#; Get one filer name
			Set tFilerName=$Piece(..FilerConfigNames,",",tCounter)
			
			#; Don't send to an empty filer
			If tFilerName'="" {

				#; Are there DICOM documents to be sent?
				&sql(SELECT count(*) into :tCount from Demo_DICOM.BatchedDocument where SessionId=:tSessionId and DocumentStatus='Queued' and FilerConfigName=:tFilerName)
				If tCount > 0 {
					
					Set tRequest=##class(Ens.StringRequest).%New()
					Set tRequest.StringValue=..%SessionId
			
					#; Send the request to the named filer ( don't want a reply )
					Set tSC=..SendRequestAsync(tFilerName,tRequest,0)
					If $$$ISERR(tSC) Quit
				}
			}
		}
		
	} Catch ex {
		Set tSC=ex.AsStatus()	
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnGetConnections">
<Description>
Return an array of connections for drawing lines on the config diagram</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Do ##super(.pArray,pItem)
	If pItem.GetModifiedSetting("FilerConfigNames",.tValue) {
		For i=1:1:$L(tValue,",") {
			Set tOne=$ZStrip($P(tValue,",",i),"<>W")
			Continue:""=tOne
			Set pArray(tOne)=""
		}
	}
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>AsyncRouterDispatcherDefaultData</DefaultData>
<Data name="AsyncRouterDispatcherDefaultData">
<Subscript>"AsyncRouterDispatcher"</Subscript>
<Value name="1">
<Value>FilerConfigNames</Value>
</Value>
<Value name="2">
<Value>RuleClass</Value>
</Value>
<Value name="3">
<Value>StoreIgnoredEntries</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.AsyncRouterFiler">
<Description>
Acts as the StorageSCU for a target image server (e.g. a PACS)
Invoked by sending a signal message, then
sends all DICOM message with status 'Queued' it finds in Demo.DICOM.BatchedDocument for 
the current session within a single DICOM association.</Description>
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64210,37728</TimeCreated>

<Parameter name="SETTINGS">
<Default>OperationDuplexName,RemoveCompletedEntries,RetryCount,-FailureTimeout</Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>ENSDEMO</Default>
</Parameter>

<Property name="RemoveCompletedEntries">
<Description>
If set to TRUE, status entries of DICOM documents sent to the 
target system successfully will be deleted from 
Demo.DICOM.BatchedDocument upon successful completion instead of being stored 
with a DocumentStatus of 'Delivered'</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="OperationDuplexName">
<Description>
This is the name of the operation providing storage</Description>
</Property>

<Property name="CurrentState">
<Description>
In this demo, the process is ever in one of two states, the Operation is connected or not.</Description>
<Type>%String</Type>
<InitialExpression>"NotConnected"</InitialExpression>
</Property>

<Property name="CurrentSessionId">
<Description>
This is the Session Id of the DICOM messages being sent</Description>
<Type>%String</Type>
</Property>

<Property name="RetryCount">
<Description><![CDATA[
This is the number of times to retry after the association with the PACS system encounters an error. </br>
-1 means never give up.]]></Description>
<Type>%Integer</Type>
<InitialExpression>3</InitialExpression>
</Property>

<Method name="OnMessage">
<Description>
Messages received here are primarily instances of EnsLib.DICOM.Document sent to this
process by the RouterDispatcher Process or RouterFiler config items.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tSQL,tMsgType, tSOPInstanceUID, tErrorComment As %String
	#dim tStoreStatus, tBatchEntryId As %Integer
	#dim tRS As %SQL.StatementResult
	#dim tBatchEntry As Demo.DICOM.BatchedDocument
	#dim ex As %Exception.AbstractException
	
	Try {
		Do {
			If (pInput.%Extends("Ens.StringRequest")) {
				
				#; This the initial request of a new session
				Set ..CurrentSessionId = pInput.StringValue
				
				If ..CurrentState="NotConnected" {
					
	 				$$$TRACE($$$Text("Establishing association"))			
					Set tSC=..EstablishAssociation(..OperationDuplexName)				
				
				}  ElseIf ..CurrentState="OperationConnected" {
								
		 			#; The Operation is connected
	 				$$$TRACE($$$Text("Operation is connected"))
	 				
	 				#; Process first unsent DICOM document, we will be called back with the C-Store-Response
	 				Set tSC=..ProcessNextDicomDocument(..CurrentSessionId)
	 				If $$$ISERR(tSC) Quit
	 				
	 			}
			} ElseIf(pInput.%Extends("Ens.AlarmResponse")) {
				
				#; We are retrying
	 			$$$TRACE($$$Text("Re-establishing association"))			
				Set tSC=..EstablishAssociation(..OperationDuplexName)				
				
			} ElseIf (pInput.%Extends("EnsLib.DICOM.Document")) {
				
				#; Handle DICOM Documents here
				If (pSourceConfigName=..OperationDuplexName) {
					
					#; We have received a document from the operation
					Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
					If $$$ISERR(tSC) Quit
				
					#; Should only EVER get a C-STORE-RSP
					$$$ASSERT(tMsgType="C-STORE-RSP")
					
					Set tStoreStatus=pInput.GetValueAt("CommandSet.Status",,.tSC)
					If $$$ISERR(tSC) Quit
					
					#; Try to get entry for the AffectedSOPInstanceUID
					Set tSOPInstanceUID=pInput.GetValueAt("CommandSet.AffectedSOPInstanceUID",,.tSC)
					If $$$ISERR(tSC) Quit
					
					#; Retrieve first DICOM document to which this document is a response
					Set tSQL="SELECT TOP 1 ID, SessionId, DICOMDocumentId,DocumentStatus from Demo_DICOM.BatchedDocument where SessionId=? and DocumentStatus='Sent' and FilerConfigName=? and AffectedSOPInstanceUID=?"
					Set tRS=##class(%SQL.Statement).%ExecDirect(,tSQL, ..CurrentSessionId, ..%ConfigName, tSOPInstanceUID)
					If tRS.%SQLCODE && (tRS.%SQLCODE '= 100) {
						Set tSC = $$$ERROR($$$SQLCode, tRS.%SQLCODE, tRS.%Message)
						Quit
					}
					
					If tRS.%Next() {
						Set tBatchEntryId=tRS.%Get("ID")
						Set tBatchEntry=##class(Demo.DICOM.BatchedDocument).%OpenId(tBatchEntryId)	
					
						#; A non zero status means something went wrong with the store
						If tStoreStatus'=0 {
							
							#; Get the ErrorComment
							Set tErrorComment = $$$FormatText($$$Text("Error: '%1'"),pInput.GetValueAt("CommandSet.ErrorComment",,.tSC))
							If $$$ISERR(tSC) Quit

							If $IsObject(tBatchEntry) {
								Set tBatchEntry.Remark=tErrorComment
								Set tBatchEntry.DocumentStatus="Errored"
								Set tSC=tBatchEntry.%Save()
								If $$$ISERR(tSC) Quit
							}
							
							#; Log the error information
							$$$LOGWARNING($$$FormatText($$$Text("Error in storing DICOM document with ID %1 (TableID=%2) : %3"),tBatchEntry.DICOMDocumentId,tBatchEntryId,tErrorComment))
							
						} Else {

							If $IsObject(tBatchEntry) {
								#; Mark entry as 'Delivered' for now, may remove later upon completion of the batch if RemoveCompletedEntries is set to true
								Set tBatchEntry.DocumentStatus="Delivered"
								#; Clear any previous remarks
								Set tBatchEntry.Remark=""
								Set tSC=tBatchEntry.%Save()
								If $$$ISERR(tSC) Quit
								
							} Else {
								// TODO: entry not found - should never happen

							}
						}
					}
					
					#; Process next unsent DICOM document, we will be called back again with the C-Store-Response
	 				Set tSC=..ProcessNextDicomDocument(..CurrentSessionId)
	 				If $$$ISERR(tSC) Quit
					
				}
				
			} Else {
				$$$ASSERT(0)
			}
			
		} while (0)
	} Catch ex {		
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ProcessNextDicomDocument">
<FormalSpec>pSessionId</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim ex As %Exception.AbstractException
	#dim tSC As %Status=$$$OK
	#dim tRS As %SQL.StatementResult
	#dim tSQL,tMsgType As %String
	#dim tBatchEntry As Demo.DICOM.BatchedDocument
	#dim tDoc As EnsLib.DICOM.Document
	
	Try {
		#; Retrieve first DICOM documents from the current session with Status='Queued' or Status='Sent' (meaning encountered an error last time and we are in a retry loop)
		Set tSQL="SELECT TOP 1 ID, SessionId, DICOMDocumentId,DocumentStatus from Demo_DICOM.BatchedDocument where SessionId=? and (DocumentStatus='Queued' or DocumentStatus='Sent') and FilerConfigName=? order by ID"
		Set tRS=##class(%SQL.Statement).%ExecDirect(,tSQL, pSessionId, ..%ConfigName)
		If tRS.%SQLCODE && (tRS.%SQLCODE '= 100) {
			Set tSC = $$$ERROR($$$SQLCode, tRS.%SQLCODE, tRS.%Message)
			Quit
		}

		#; Release association if there are no more DICOM documents to process
		If 'tRS.%Next() {
			#; Now close the association with the operation, we will be called back at OnAssociationReleased()
			$$$TRACE($$$Text("Releasing association"))
			Set tSC=..ReleaseAssociation(..OperationDuplexName)
			If $$$ISERR(tSC) Quit
			
			If ..RemoveCompletedEntries {
				#; Remove entries from table now that all documents in the session have been successfully delivered
				Set tSQL="DELETE from Demo_DICOM.BatchedDocument where SessionId=? and DocumentStatus='Delivered' and FilerConfigName=?"
				Set tRS=##class(%SQL.Statement).%ExecDirect(,tSQL, pSessionId, ..%ConfigName)
				If tRS.%SQLCODE && (tRS.%SQLCODE '= 100) {
					$$$LOGWARNING($$$FormatText($$$Text("Error in removing Demo.DICOM.BatchedDocument entries for successfully sent documents : %1"),$System.Status.GetErrorText($$$ERROR($$$SQLCode, tRS.%SQLCODE, tRS.%Message))))
				}
			}

		} Else {
			
			#; Process message
			$$$TRACE($$$FormatText($$$Text("Processing DICOM document with ID: %1 (TableID=%2)"),tRS.%Get("DICOMDocumentId"),tRS.%Get("ID")))

			Set tBatchEntry=##class(Demo.DICOM.BatchedDocument).%OpenId(tRS.%Get("ID"))			
			$$$ASSERT($IsObject(tBatchEntry))
			
			Set tDoc=##class(EnsLib.DICOM.Document).%OpenId(tBatchEntry.DICOMDocumentId)
				
			#; Get the CommandField, it contains the type of request, it should ALWAYS be present
			Set tMsgType=$$$MsgTyp2Str(tDoc.GetValueAt("CommandSet.CommandField",,.tSC))
			If $$$ISERR(tSC) Quit

			#; We are only handling storage requests at present
			$$$ASSERT(tMsgType="C-STORE-RQ")

			#; We can forward the document to the operation
			Set tSC=..SendRequestAsync(..OperationDuplexName,tDoc,0)
			If $$$ISERR(tSC) Quit
			Set tBatchEntry.DocumentStatus="Sent"
			Set tSC=tBatchEntry.%Save()
			
		}		
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationEstablished">
<Description>
This call back is called by the framework when an Association is established</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Established</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	
	If pSourceConfigName=..OperationDuplexName {
		
		#; The association with the operation has been completed, operation is now connected
		Set ..CurrentState="OperationConnected"
				
	 	#; The Operation is connected
		$$$TRACE($$$Text("Operation is connected"))
		
		#; Process first unsent DICOM document, we will be called back with the C-Store-Response
		Set tSC=..ProcessNextDicomDocument(..CurrentSessionId)
	} 
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationReleased">
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Released</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$ASSERT(pSourceConfigName=..OperationDuplexName)
        
    #; The association between this process and the operation has been released, so we are now not connected to the operation
    Set ..CurrentState="OperationNotConnected"
    
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tCommandAbort As EnsLib.DICOM.Command.Abort
	#dim tSQL,tErrorMsg As %String
	#dim tAlert As Ens.AlertRequest
	#dim tSessionId As %String = ..CurrentSessionId
	#dim tFilerName As %String = ..%ConfigName
	#dim tRS As %SQL.StatementResult
	#dim tCount,SQLCODE,tSqlCode As %Integer
	
    #; If we are in conversation with the operation, we need to tell the operation to ABORT its association
    If ..CurrentState="OperationConnected" {
        
        #; Form an abort message
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the operation
        Do ..AbortAssociation(..OperationDuplexName,tCommandAbort)
        
        #; The operation is disconnected after the abort
        Set ..CurrentState="NotConnected"
    }
    
	#; Are there DICOM documents that haven't been delivered?
	&sql(SELECT count(*) into :tCount from Demo_DICOM.BatchedDocument where SessionId=:tSessionId and (DocumentStatus='Queued' or DocumentStatus='Sent') and FilerConfigName=:tFilerName)
    Set tSqlCode = SQLCODE	
    	
    #; If there are/might be any undelivered documents, re-queue all documents from this session so that the entire batch can be resent
    If (tSqlCode && (tSqlCode'=100)) || (tCount'=0) {
		Set tSQL="UPDATE Demo_DICOM.BatchedDocument (DocumentStatus,Remark) VALUES ('Queued',?) where SessionId=? and (DocumentStatus='Delivered' or DocumentStatus='Errored' or DocumentStatus='Sent') and FilerConfigName=?"
		Set tRS=##class(%SQL.Statement).%ExecDirect(,tSQL, $$$Text("Re-queued after error encountered in filer"),tSessionId, ..%ConfigName)
		If tRS.%SQLCODE && (tRS.%SQLCODE '= 100) {
			Set pErrorStatus = $$$ADDSC(pErrorStatus,$$$ERROR($$$SQLCode, tRS.%SQLCODE, tRS.%Message))
		}
    }
    
    #; Form the alert message
    Set tAlert = ##class(Ens.AlertRequest).%New()
    If tSqlCode && (tSqlCode'=100) {
    	Set tErrorMsg = $$$FormatText($$$Text("Filer '%1' errored in Session %2 with an unknown number of undelivered DICOM document(s)."),tFilerName,tSessionId) 
    } ElseIf tCount'=0 {
    	Set tErrorMsg = $$$FormatText($$$Text("Filer '%1' errored in Session %2 with %3 undelivered DICOM document(s)."),tFilerName,tSessionId,tCount) 
    } Else {
    	Set tErrorMsg = $$$FormatText($$$Text("Filer '%1' errored in Session %2."),tFilerName,tSessionId) 
    }
    Set tErrorMsg = tErrorMsg_$C(13,10,13,10)_$$$FormatText($$$Text("Error status: %1"),##class(%SYSTEM.Status).GetErrorText(pErrorStatus))
    Set tAlert.AlertText = tErrorMsg
    
    #; Send it to the alert processor
    Do ..SendAlert(tAlert)
    
	#; Don't ignore the error, this will cause the BP to terminate
	Quit pErrorStatus
]]></Implementation>
</Method>

<Method name="OnAssociationErrored">
<Description>
This callback is called by the framework when an assocation encounters an error</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Errored</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..RetryOrTerminate(pInput.Status)
]]></Implementation>
</Method>

<Method name="OnAssociationRejected">
<Description>
This callback is called by the framework when an Association is rejected</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Rejected</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tRejectReason As %String
	
	#; The Operation is disconnected
	Set ..CurrentState="NotConnected"
	
	#; Identify the reject reason and return the appropriate error 
	Set tRejectReason = ##class(EnsLib.DICOM.Util.Encoding).REJECTREASON2EYE(pInput.Source,pInput.Reason)
	Quit $$$ERROR($$$EnsDICOMPeerRejectedAssociation,pSourceConfigName,tRejectReason)
]]></Implementation>
</Method>

<Method name="OnAssociationAborted">
<Description>
This callback is called by the framework when an association is aborted</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Aborted</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..RetryOrTerminate($$$ERROR($$$EnsDICOMPeerRequestedAbort))
]]></Implementation>
</Method>

<Method name="RetryOrTerminate">
<Description>
This method is called by OnAssociationErrored and OnAssociationAborted to determine what should be done after an error is encountered. 
Returns status $$$OK if retrying, otherwise it returns the error status</Description>
<FormalSpec>pError</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tTimeout As %Integer
	
	#; If there are retries remaining, decrease RetryCount and trigger wakeup call
    If ..RetryCount'=0 {
	    Set ..RetryCount=..RetryCount-1
	    
        #; The operation has become disconnected
        Set ..CurrentState="NotConnected"

	    #; Demonstrate Retry Logic, we will trigger a wakeup call and check for that in OnMessage()
	    Set tTimeout = +..RetryInterval
	    If tTimeout <= 0 Set tTimeout = 2
        Set tSC=..ScheduleWakeupCall(tTimeout)
        
        $$$LOGWARNING($$$FormatText($$$Text("Entering retry loop after association errored with status '%1'"),##class(%SYSTEM.Status).GetErrorText(pError))) 
    } Else {
        #; Failed after all retries
        Set tSC=pError
    }

	#; Don't ignore the error, this will cause the BP to terminate
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnDetermineTransferSyntax">
<Description>
This callback permits the transfer syntax to be overriden</Description>
<FormalSpec>*pTransferSyntax</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pTransferSyntax=""
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>AsyncRouterFilerDefaultData</DefaultData>
<Data name="AsyncRouterFilerDefaultData">
<Subscript>"AsyncRouterFiler"</Subscript>
<Value name="1">
<Value>RemoveCompletedEntries</Value>
</Value>
<Value name="2">
<Value>OperationDuplexName</Value>
</Value>
<Value name="3">
<Value>CurrentState</Value>
</Value>
<Value name="4">
<Value>CurrentSessionId</Value>
</Value>
<Value name="5">
<Value>RetryCount</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.Modality">
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62888,63578.273904</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This parameter names the operation used to provide storage</Description>
<Default>OperationDuplexName</Default>
</Parameter>

<Property name="CurrentState">
<Description>
This keeps track of the current state of the process</Description>
<Type>%String</Type>
<InitialExpression>"OperationNotConnected"</InitialExpression>
</Property>

<Property name="OperationDuplexName">
<Description>
This is the name of the operation providing connectivity</Description>
</Property>

<Property name="ResponseCount">
<Description>
This is the count of incoming responses</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Request">
<Description>
Request</Description>
<Type>EnsLib.DICOM.Document</Type>
</Property>

<Property name="RequestType">
<Description>
Request Type (this can be "FIND" or "ECHO")</Description>
<Type>%String</Type>
<InitialExpression>"FIND"</InitialExpression>
</Property>

<Property name="CancelThreshold">
<Description>
This specifies the number of C-FIND-RSP records to be recieved before sending a CANCEL</Description>
<Type>%Integer</Type>
<InitialExpression>5</InitialExpression>
</Property>

<Method name="OnMessage">
<Description>
Messages received here are instances of EnsLib.DICOM.Document sent to this
process by the service or operation config items. In this demo, the process is ever
in one of two states, the Operation is connected or not.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim tMsgType As %String
    #dim tOutput As EnsLib.DICOM.Document
    do {
        
        #; If its a document sent from the service
        If pSourceConfigName'=..OperationDuplexName {
            
            if (..CurrentState="OperationNotConnected") {
                
                Do ..TraceMessage("connecting")
                
                #; We will be called back at OnAssociationEstablished()
                Set tSC=..EstablishAssociation(..OperationDuplexName)
                
            } else {
               
                Do ..TraceMessage("in progress - ignored")
            }
               
        } elseif pSourceConfigName=..OperationDuplexName {
            
            #; We have received a document from the operation
            Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
            If $$$ISERR(tSC) Quit
            
            #; Should only EVER get an C-FIND-RSP
            $$$ASSERT((tMsgType="C-FIND-RSP")||(tMsgType="C-ECHO-RSP"))
            
            Do ..TraceMessage("received response")
            
            Set tLast=pInput.GetValueAt("CommandSet.Status",,.tSC)
            If $$$ISERR(tSC) Quit
            
            If tMsgType="C-ECHO-RSP" Set tLast=0
            
            If tLast'=0 {
                
                Set ..ResponseCount=..ResponseCount+1
                
                If ..ResponseCount=..CancelThreshold {
                    
                    Set tSC=..CreateCancelRequest(.tCancelRequest)
                    If $$$ISERR(tSC) Quit
                    
                     #; No response required    
                    Set tSC=..SendRequestAsync(..OperationDuplexName,tCancelRequest,0)
                }
     
                Do ..TraceMessage("more find responses to come")  
                 
            } else {
                
                Do ..TraceMessage("received last response")
                
                Set tSC=..ReleaseAssociation(..OperationDuplexName)
            }
        }
    } while (0)
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationEstablished">
<Description>
This method is called by the framework on successful establishment of an association</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Established</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    try {
    
        $$$ASSERT(pSourceConfigName=..OperationDuplexName)
        
        Do ..TraceMessage("connected")
        
        Set ..ResponseCount = 0
        
        #; The association with the operation has been completed, operation is now connected
        Set ..CurrentState="OperationConnected"
        
        #; Send the find request
        Do ..TraceMessage("sending request")
                
        If ..RequestType="FIND" {
            
            #; Create a Generic Find Request
            Set tSC=..CreateFindRequest(.tRequest)
        } else {
            
            #; Create an Echo Request
            Set tSC=..CreateEchoRequest(.tRequest)
        }
        If $$$ISERR(tSC) Quit
        
        #; Stash the find request. When sent, the adapter will update the message id
        #; which is needed if we want to send a cancel
        Set ..Request=tRequest
            
        #; No response required    
        Set tSC=..SendRequestAsync(..OperationDuplexName,tRequest,0) 
    
    } catch(e) {
        Set tSC=e.AsStatus()
    }

    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationReleased">
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Released</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    
    $$$ASSERT(pSourceConfigName=..OperationDuplexName)
    
    Do ..TraceMessage("disconnected")
        
    #; The association between this process and the operation has been released, so we are now
    #; not connected to the operation
    Set ..CurrentState="OperationNotConnected"
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; If we are in conversation with the operation, we neet to tell the operation to ABORT its association
    If ..CurrentState="OperationConnected" {
        
        #; Form an abort message
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the operation
        Do ..AbortAssociation(..OperationDuplexName,tCommandAbort)
    }
    Quit pErrorStatus
]]></Implementation>
</Method>

<Method name="OnAssociationErrored">
<Description>
This callback is called by the framework when an assocation encounters an error</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Errored</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Don't ignore the error, this will cause the BP to terminate
    Quit pInput.Status
]]></Implementation>
</Method>

<Method name="OnAssociationAborted">
<Description>
This callback is called by the framework when an association is aborted</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Aborted</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..TraceMessage("peer aborted association")
    
    Set ..CurrentState="OperationNotConnected"
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAssociationRejected">
<Description>
This callback is called by the framework when an Association is rejected</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Rejected</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..TraceMessage("peer rejected association")
    
    Set ..CurrentState="OperationNotConnected"
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="TraceMessage">
<Description>
Write a message to the console</Description>
<FormalSpec>pMessage:%String</FormalSpec>
<Implementation><![CDATA[
    #dim tIO
    Set tIO=$IO Use $Principal $$$TRACE(pMessage) Use tIO
]]></Implementation>
</Method>

<Method name="CreateCancelRequest">
<Description>
Create a Cancel Request</Description>
<FormalSpec>*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status =$$$OK
    #dim tTemp As %String
    
    try {
    
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit

        #; Now create an instance of a message to indicate that the find process is complete
        Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
        If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
        
        #; Set the CommandField, this is a C-CANCEL Request
        Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-CANCEL-RQ"),"CommandSet.CommandField")
        If $$$ISERR(tSC) Quit
        
        #; Pick out the message Id of the request that we want to cancel
        Set tMsgId=..Request.GetValueAt("CommandSet.MessageID",,.tSC)
        If $$$ISERR(tSC) Quit
        
        #; And plug it into the cancel request
        Set tSC=pDocOut.SetValueAt(tMsgId,"CommandSet.MessageIDBeingRespondedTo") If $$$ISERR(tSC) Quit
        If $$$ISERR(tSC) Quit
        
    } catch {
        Set tSC=$$$EnsSystemError
    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="CreateEchoRequest">
<Description>
Create an Echo Request</Description>
<FormalSpec>*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status =$$$OK
    #dim tTemp As %String
    
    try {
	    
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
    
        #; Now create an instance of a message to indicate that the find process is complete
        Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
        If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
        
        Set tSC=pDocOut.SetValueAt("1.2.840.10008.1.1","CommandSet.AffectedSOPClassUID")
        If $$$ISERR(tSC) Quit
        
        #; Set the CommandField, this is a C-ECHO Request
        Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-ECHO-RQ"),"CommandSet.CommandField")
        If $$$ISERR(tSC) Quit
        
    } catch {
        Set tSC=$$$EnsSystemError
    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="CreateFindRequest">
<Description>
Create a Find Request</Description>
<FormalSpec>*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status =$$$OK
    #dim tTemp As %String
    
    try {
    
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
        
        #; Now create an instance of a message to indicate that the find process is complete
        Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
        If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
        
        #; We will be performing a find at patient level
        Set tSC=pDocOut.SetValueAt("1.2.840.10008.5.1.4.1.2.1.1","CommandSet.AffectedSOPClassUID")
        If $$$ISERR(tSC) Quit
        
        #; Set the CommandField, this is a C-FIND Request
        Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-FIND-RQ"),"CommandSet.CommandField")
        If $$$ISERR(tSC) Quit
        
        #; Set the priority
        Set tSC = pDocOut.SetValueAt(0,"CommandSet.Priority")
        If $$$ISERR(tSC) Quit
    
        Set tSC = pDocOut.SetValueAt("PATIENT","DataSet.QueryRetrieveLevel")
        If $$$ISERR(tSC) Quit
    
        Set tSC = pDocOut.SetValueAt("","DataSet.PatientID")
        If $$$ISERR(tSC) Quit
            
        Set tSC = pDocOut.SetValueAt("","DataSet.SOPInstanceUID")
        If $$$ISERR(tSC) Quit
        
        Set tSC = pDocOut.SetValueAt("","DataSet.StudyInstanceUID")
        If $$$ISERR(tSC) Quit
        
        Set tSC = pDocOut.SetValueAt("","DataSet.SeriesInstanceUID")
        If $$$ISERR(tSC) Quit
        
    } catch {
        Set tSC=$$$EnsSystemError
    }
    Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ModalityDefaultData</DefaultData>
<Data name="ModalityDefaultData">
<Subscript>"Modality"</Subscript>
<Value name="1">
<Value>CurrentState</Value>
</Value>
<Value name="2">
<Value>OperationDuplexName</Value>
</Value>
<Value name="3">
<Value>ResponseCount</Value>
</Value>
<Value name="4">
<Value>Request</Value>
</Value>
<Value name="5">
<Value>RequestType</Value>
</Value>
<Value name="6">
<Value>CancelCount</Value>
</Value>
<Value name="7">
<Value>CancelThreshold</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.RouterDispatcher">
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61102,65382.716582</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This parameter lists the (comma seperated ) names of the RouterFiler business processes</Description>
<Default>FilerConfigNames</Default>
</Parameter>

<Property name="FilerConfigNames">
<Description>
This is the list of configuration names of the router filer process(es)</Description>
</Property>

<Property name="ActiveFilers">
<Description>
This is a list of router filer processes which we have sent documents to and have not yet received a response from</Description>
<Type>%String</Type>
<Collection>list</Collection>
</Property>

<Property name="ResponseStatus">
<Description>
This property stores the Status returned in C-STORE-RSP from the filers so that we can send the same Status to the modality</Description>
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ErrorComment">
<Description>
This property stores ErrorComment returned in the C-STORE-RSP from the filers so that we can send the same ErrorComment to the modality </Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="64"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="Abort">
<Description>
This property records whether the filers returned an errored message, in which case we should send an Abort back to the modality</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="OnGetConnections">
<Description>
Return an array of connections for drawing lines on the config diagram</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Do ##super(.pArray,pItem)
	If pItem.GetModifiedSetting("FilerConfigNames",.tValue) {
		For i=1:1:$L(tValue,",") { Set tOne=$ZStrip($P(tValue,",",i),"<>W")  Continue:""=tOne  Set pArray(tOne)="" }
	}
]]></Implementation>
</Method>

<Method name="OnMessage">
<Description>
Messages received here are instances of EnsLib.DICOM.Document sent to this
process by the service or operation config items. In this demo, the process is ever
in one of two states, the Operation is connected or not.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tCounter As %Integer
	#dim tMsgType,tFilerName As %String
	
	do {
		
		#; We should only ever see DICOM Documents here
		$$$ASSERT(pInput.%Extends("EnsLib.DICOM.Document"))
		
 		#; If it's a document sent from the service
 		If pSourceConfigName=..ServiceDuplexName {
	 		
	 		If pInput.%Extends("EnsLib.DICOM.Document") {
	 		
				#; Get the CommandField, it contains the type of request and should ALWAYS be present
				Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
				If $$$ISERR(tSC) Quit	
				
				#; We should only ever see DICOM store requests here
				$$$ASSERT(tMsgType="C-STORE-RQ")
												
				#; Here we walk through the filer names and send the document to each.
				For tCounter=1:1:$Length(..FilerConfigNames,",") {
					
					#; Get one filer name
					Set tFilerName=$Piece(..FilerConfigNames,",",tCounter)
					
					#; Don't send to an empty filer
					If tFilerName'="" {
						
						#; Note: If the input document requires changes then you should Clone() the document before modifying and sending
						#; the clone to the filer

						#; Forward the C-STORE-RQ to the named filer ( don't wait for the reply before sending to other filers )
						Set tSC=..SendRequestAsync(tFilerName,pInput,1)
						If $$$ISERR(tSC) Quit
						
						#; Add the named filer to the list of filers from which we are awaiting a response
						Set tSC = ..ActiveFilers.Insert(tFilerName)
						If $$$ISERR(tSC) Quit
					}
				}

				#; Need to check status from loop above
				If $$$ISERR(tSC) Quit
			}
		} 
	 		
	} while (0)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnResponse">
<Description>
Handle a 'Response'</Description>
<FormalSpec><![CDATA[request:Ens.Request,&response:Ens.Response,callrequest:Ens.Request,callresponse:Ens.Response,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tKey,tMsgType,tStatus As %String
	#dim tOutput As EnsLib.DICOM.Document
	#dim ex As %Exception.SystemException

	Try {
		
		#; Check to see if this is one of the responses we are waiting for
		Set tKey = ..ActiveFilers.Find(..%CurrentResponseHeader.SourceConfigName)
		If ((""'=tKey) && callrequest.%Extends("EnsLib.DICOM.Document")) {
			
			#; Remove this filer from the list of filers we're waiting on
			Do ..ActiveFilers.RemoveAt(tKey)

			#; process the response
			If $IsObject(callresponse) && callresponse.%Extends("EnsLib.DICOM.Document") {
				
				#; Get the CommandField, it contains the type of request and should ALWAYS be present
				Set tMsgType=$$$MsgTyp2Str(callresponse.GetValueAt("CommandSet.CommandField",,.tSC))
				If $$$ISERR(tSC) Quit	
					
				#; We should only ever see DICOM store responses here
				$$$ASSERT(tMsgType="C-STORE-RSP")
				If (tMsgType '= "C-STORE-RSP") {
					Set ..Abort = 1
					Quit
				}
				
				#; Get the Status	
				Set tStatus=callresponse.GetValueAt("CommandSet.Status",,.tSC)
				If $$$ISERR(tSC) Quit
				
				#; If the response status is an error, store it now so we can send it back to the modality once we have received all the responses	
				If 0'=tStatus {
					Set ..ResponseStatus = tStatus
					
					#; Get the ErrorComment
					Set ..ErrorComment=callresponse.GetValueAt("CommandSet.ErrorComment",,.tSC)
					If $$$ISERR(tSC) Quit

				}
			} Else {
				#; We should only ever see C-STORE-RSP messages from the filers.  Anything else means  
				#; there was an error somewhere upstream, so we should send an ABORT back to the modality 
				Set ..Abort = 1
				
				If $$$ISERR(..%CurrentResponseHeader.ErrorStatus) {
				    #; Log the Error Status so we can see what happened
	    			$$$LOGSTATUS(..%CurrentResponseHeader.ErrorStatus)
				}

			}
									
			#; If this was the final response from the filers, send response to the modality
			If (0 = ..ActiveFilers.Size) {
								
				If ..Abort {
			        #; Form an abort message
			        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
			        
			        #; Send it to the service
			        Set tSC = ..AbortAssociation(..ServiceDuplexName,tCommandAbort)
			        
				} Else {
								
					#; We need to create a C-STORE-RSP and send to the modality
					Set tSC = ..CreateStorageResponse(callrequest,.tOutput,..ResponseStatus,..ErrorComment)
					If $$$ISERR(tSC) Quit
					
					#; We HAVE created an output object
					$$$ASSERT($IsObject(tOutput))
					
					#; Send the reply back to the service ( don't want a response )
					Set tSC=..SendRequestAsync(..ServiceDuplexName,tOutput,0)
				}
								
				#; Clear out status values
				Set ..ResponseStatus = 0
				Set ..ErrorComment = ""
				Set ..Abort = 0
			}
			
		} Else {
			Set tSC = ##super(request,response,callrequest,callresponse,pCompletionKey)
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateStorageResponse">
<Description>
Create a storage response DICOM message</Description>
<FormalSpec>pDocIn:EnsLib.DICOM.Document,*pDocOut:EnsLib.DICOM.Document,pStatus:%String=0,pComment:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tTemp As %String
	try {
		
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
		
		#; Create an instance of a DICOM Document to form the response
		Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
		If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
		
		#; Need to copy over the AffectedSOPClassUID (mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPClassUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPClassUID")
		If $$$ISERR(tSC) Quit
		
		#; Set the CommandField, this is a Storage Response
		Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-STORE-RSP"),"CommandSet.CommandField")
		If $$$ISERR(tSC) Quit
		
		#; And indicate the message id being responded to by copying over the originating message id
		Set tTemp=pDocIn.GetValueAt("CommandSet.MessageID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.MessageIDBeingRespondedTo")
		If $$$ISERR(tSC) Quit
		 
		#; Need to copy over the affected SOP instance id
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPInstanceUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPInstanceUID")
		If $$$ISERR(tSC) Quit
		
		#; Need to copy over the transfer syntax
		Set pDocOut.DataSet.TransferSyntax=pDocIn.DataSet.TransferSyntax
		
		#; Set the status to the value returned from the filers
		Set tSC=pDocOut.SetValueAt(pStatus,"CommandSet.Status")
		If $$$ISERR(tSC) Quit
		
		#; Set the ErrorComment if one was returned from the filers
		If ""'=pComment {
			Set tSC=pDocOut.SetValueAt(pComment,"CommandSet.ErrorComment")
			If $$$ISERR(tSC) Quit
		}
		
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>RouterDispatcherDefaultData</DefaultData>
<Data name="RouterDispatcherDefaultData">
<Subscript>"RouterDispatcher"</Subscript>
<Value name="1">
<Value>FilerConfigNames</Value>
</Value>
<Value name="2">
<Value>ActiveFilers</Value>
</Value>
<Value name="3">
<Value>ResponseStatus</Value>
</Value>
<Value name="4">
<Value>ErrorComment</Value>
</Value>
<Value name="5">
<Value>Abort</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.RouterFiler">
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61102,65382.716582</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This parameter names the operation used to provide storage</Description>
<Default>OperationDuplexName</Default>
</Parameter>

<Property name="OperationDuplexName">
<Description>
This is the name of the operation providing storage</Description>
</Property>

<Property name="CurrentState">
<Type>%String</Type>
<InitialExpression>"NotConnected"</InitialExpression>
</Property>

<Property name="CurrentDocument">
<Type>EnsLib.DICOM.Document</Type>
</Property>

<Method name="OnMessage">
<Description>
Messages received here are primarily instances of EnsLib.DICOM.Document sent to this
process by the RouterDispatcher Process or RouterFiler config items.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tMsgType As %String
	#dim tStoreStatus As %Integer
	do {
		
		#; Handle DICOM Documents here
		If (pInput.%Extends("EnsLib.DICOM.Document")) {
			
			if (pSourceConfigName'=..OperationDuplexName) {
				
				If ..CurrentState="NotConnected" {
				
					#; Store the current document
					Set ..CurrentDocument=pInput
					
					Set tSC=..EstablishAssociation(..OperationDuplexName)
				
				}  elseif ..CurrentState="OperationConnected" {
	 			
		 			#; The Operation is connected
	 			
			 		#; Get the CommandField, it contains the type of request, it should ALWAYS be present
					Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
					If $$$ISERR(tSC) Quit
		
					#; We are only handling storage requests at present
					$$$ASSERT(tMsgType="C-STORE-RQ")
		
		 			#; We can forward the document to the operation
					Set tSC=..SendRequestAsync(..OperationDuplexName,pInput,0) 
	 			}
	 			
			} else {
				
				#; We have received a document from the operation
				Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
				If $$$ISERR(tSC) Quit
			
				#; Should only EVER get a C-STORE-RSP
				$$$ASSERT(tMsgType="C-STORE-RSP")
				
				#; Send the reply back to the dispatcher ( don't want a response )
				Set tSC = ..Reply(pInput)
				If $$$ISERR(tSC) Quit

				#; Now close the Association with the operation, we will be called back at
				#; OnAssociationReleased()
				Set tSC=..ReleaseAssociation(..OperationDuplexName)
				
				Set tStoreStatus=pInput.GetValueAt("CommandSet.Status",,.tSC)
				If $$$ISERR(tSC) Quit
				
				If tStoreStatus'=0 {
					
					#; May want to log an error status here, as a non zero status means
					#; something went wrong with the store
				}
			}
			
		} else {
			$$$ASSERT(0)
		}
		
	} while (0)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; If we are in conversation with the operation, we neet to tell the operation to ABORT its association
    If ..CurrentState="OperationConnected" {
        
        #; Form an abort message
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the operation
        Do ..AbortAssociation(..OperationDuplexName,tCommandAbort)
    }
    Quit pErrorStatus
]]></Implementation>
</Method>

<Method name="OnAssociationErrored">
<Description>
This callback is called by the framework when an assocation encounters an error</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Errored</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Don't ignore the error, this will cause the BP to terminate
	Quit pInput.Status
]]></Implementation>
</Method>

<Method name="OnAssociationRejected">
<Description>
This callback is called by the framework when an Association is rejected</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Rejected</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..CurrentState="NotConnected"
	
	Quit $$$ERROR($$$EnsDICOMPeerRejectedAssociation)
]]></Implementation>
</Method>

<Method name="OnAssociationEstablished">
<Description>
This call back is called by the framework when an Association is established</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Established</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	If pSourceConfigName=..OperationDuplexName {
		
		#; The association with the operation has been completed, operation is now connected
		Set ..CurrentState="OperationConnected"
	
		#; Call the OnMessage() with the saved document ( if we have it )
		if ($IsObject(..CurrentDocument)) {
			Set tSC=..OnMessage(..ServiceDuplexName,..CurrentDocument)
		}	
	} 
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationAborted">
<Description>
This callback is called by the framework when an association is aborted</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Aborted</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..CurrentState="NotConnected"
	
	Quit $$$ERROR($$$EnsDICOMPeerRequestedAbort)
]]></Implementation>
</Method>

<Method name="OnDetermineTransferSyntax">
<Description>
This callback permits the transfer syntax to be overriden</Description>
<FormalSpec>*pTransferSyntax</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT($IsObject(..CurrentDocument))

	Set pTransferSyntax=..CurrentDocument.DataSet.TransferSyntax
	
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>RouterFilerDefaultData</DefaultData>
<Data name="RouterFilerDefaultData">
<Subscript>"RouterFiler"</Subscript>
<Value name="1">
<Value>OriginatingMessageID</Value>
</Value>
<Value name="2">
<Value>DocumentFromService</Value>
</Value>
<Value name="3">
<Value>CurrentState</Value>
</Value>
<Value name="4">
<Value>OperationDuplexName</Value>
</Value>
<Value name="5">
<Value>MessageID</Value>
</Value>
<Value name="6">
<Value>CurrentDocument</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.Storage">
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61102,65382.716582</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This parameter names the operation used to provide storage</Description>
<Default>OperationDuplexName</Default>
</Parameter>

<Property name="OriginatingMessageID">
<Description>
This keeps track of the OriginatingMessageID</Description>
<Type>%Integer</Type>
</Property>

<Property name="DocumentFromService">
<Description>
This is the incoming document from the business Sservice</Description>
<Type>EnsLib.DICOM.Document</Type>
</Property>

<Property name="CurrentState">
<Description>
This keeps track of the current state of the process</Description>
<Type>%String</Type>
<InitialExpression>"OperationNotConnected"</InitialExpression>
</Property>

<Property name="OperationDuplexName">
<Description>
This is the name of the operation providing storage</Description>
</Property>

<Method name="OnMessage">
<Description>
Messages received here are instances of EnsLib.DICOM.Document sent to this
process by the service or operation config items. In this demo, the process is ever
in one of two states, the Operation is connected or not.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim tMsgType As %String
    do {
       
        #; We should only ever see DICOM Documents here
        $$$ASSERT(pInput.%Extends("EnsLib.DICOM.Document"))
        
        #; If its a document sent from the service
        If pSourceConfigName=..ServiceDuplexName {
            
            #; If the operation has not been connected yet
            If ..CurrentState="OperationNotConnected" {
                
                #; We are in the process of establishing the connection to the operation,
                #; Keep hold of the incoming document
                Set ..DocumentFromService=pInput
                
            } elseif ..CurrentState="OperationConnected" {
                
                #; The Operation is connected
                
                #; Get the CommandField, it contains the type of request, it should ALWAYS be present
                Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
                If $$$ISERR(tSC) Quit
        
                #; We are only handling storage requests at present
                $$$ASSERT(tMsgType="C-STORE-RQ")
        
                #; Record the originating message id because this will be updated when we
                #; send the message out to the operation
                Set ..OriginatingMessageID=pInput.GetValueAt("CommandSet.MessageID",,.tSC)
                If $$$ISERR(tSC) $$$LOGSTATUS(tSC) Quit
                
                #; We can forward the document to the operation
                Set tSC=..SendRequestAsync(..OperationDuplexName,pInput,0)
            }
            
        } elseif pSourceConfigName=..OperationDuplexName {
            
            #; We have received a document from the operation
            Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
            If $$$ISERR(tSC) Quit
            
            #; Should only EVER get a C-STORE-RSP
            $$$ASSERT(tMsgType="C-STORE-RSP")
        
            #; Update the message id being responded to
            Set tSC=pInput.SetValueAt(..OriginatingMessageID,"CommandSet.MessageIDBeingRespondedTo") 
            $$$ASSERT('$$$ISERR(tSC))
            
            #; Need to copy over the transfer syntax
            If ..DocumentFromService.DataSet.TransferSyntax'="" {
                Set pInput.DataSet.TransferSyntax=..DocumentFromService.DataSet.TransferSyntax
            }

            #; Send the reply back to the service
            Set tSC=..SendRequestAsync(..ServiceDuplexName,pInput,0) 
            If $$$ISERR(tSC) Quit
            
            #; Finished with this document
            Set ..DocumentFromService="",..OriginatingMessageID=""
        }
    } while (0)
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationEstablished">
<Description>
This method is called by the framework on successful establishment of an association</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Established</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    
    If pSourceConfigName=..OperationDuplexName {
        
        #; The association with the operation has been completed, operation is now connected
        Set ..CurrentState="OperationConnected"
    
        #; Call the OnMessage() with he saved document ( if we have it )
        if ($IsObject(..DocumentFromService)) {
            Set tSC=..OnMessage(..ServiceDuplexName,..DocumentFromService)
        }
        
    } else {
        
        #; Need to establish an associaton with the operation (we will be called back here at 
        #; OnAssociationEstablished()
        Set tSC=..EstablishAssociation(..OperationDuplexName)
    }
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationReleased">
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Released</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    
    If pSourceConfigName=..ServiceDuplexName {
        
        #; The association between the modality and service has been released
        If ..CurrentState="OperationConnected" {
            
            #; The operation is connected we want to releaste the association
            Set tSC=..ReleaseAssociation(..OperationDuplexName)
        }
    } else {
        
        #; The association between this process and the operation has been released, so we are now
        #; not connected to the operation
        Set ..CurrentState="OperationNotConnected"
    }
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationRejected">
<Description>
This callback is called by the framework when an Association is rejected</Description>
<Final>1</Final>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Rejected</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC,tStatus As %Status = $$$OK
    #dim tCommandAbort As EnsLib.DICOM.Command.Abort
    
    try {
        
        #; Only interested in Association being rejected by the operation
        If pSourceConfigName=..OperationDuplexName {
        
            #; Form an error message to get it logged
            Set tStatus=$$$EnsError($$$EnsDICOMPeerRejectedAssociation)
            
            #; Form an Abort message with reason
            Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEPROVIDER,$$$ABORTREASONNOTSPECIFIED)
    
            #; Send it the the Service
            Set tSC=..AbortAssociation(..ServiceDuplexName,tCommandAbort)
        }
    
    } catch {
        Set tSC=$$$EnsSystemError
    }
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationErrored">
<Description>
This callback is called by the framework when an association encounters an error</Description>
<Final>1</Final>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Errored</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim tCommandAbort As EnsLib.DICOM.Command.Abort
    
    #; Log the Error Status So we can see what happened
    $$$LOGSTATUS(pInput.Status)
    
    #; Need to send an Abort command to the counterpart
    If pSourceConfigName = ..ServiceDuplexName {
        
        #; Form a command
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the operation
        Set tSC=..AbortAssociation(..OperationDuplexName,tCommandAbort)
    } else {
        
        #; Form a command
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEPROVIDER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the service
        Set tSC=..AbortAssociation(..ServiceDuplexName,tCommandAbort)
    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationAborted">
<Description>
This callback is called by the framework when an association is aborted</Description>
<Final>1</Final>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Aborted</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim tCommand As EnsLib.DICOM.Command.Abort
    
    #; Need to send an Abort command to the counterpart
    Set tCommand=##class(EnsLib.DICOM.Command.Abort).%New(pInput.Source,pInput.Reason)
    
    If pSourceConfigName=..ServiceDuplexName {
        
        #; Send an abort to the operation
        Set tSC=..AbortAssociation(..OperationDuplexName,tCommand)
    } else {
        #; Send an abort to the service
        Set tSC=..AbortAssociation(..ServiceDuplexName,tCommand)
    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Form an abort message
    Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEPROVIDER,$$$ABORTREASONNOTSPECIFIED)
    
    #; Send it to the service
    Do ..AbortAssociation(..ServiceDuplexName,tCommandAbort)
    
    #; If we are in conversation with the operation, we neet to tell the operation to ABORT its association
    If ..CurrentState="OperationConnected" {
        
        #; Form an abort message
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the operation
        Do ..AbortAssociation(..OperationDuplexName,tCommandAbort)
    }
    Quit pErrorStatus
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>StorageDefaultData</DefaultData>
<Data name="StorageDefaultData">
<Subscript>"Storage"</Subscript>
<Value name="1">
<Value>OriginatingMessageID</Value>
</Value>
<Value name="2">
<Value>DocumentFromService</Value>
</Value>
<Value name="3">
<Value>DocumentFromOperation</Value>
</Value>
<Value name="4">
<Value>CurrentState</Value>
</Value>
<Value name="5">
<Value>OperationDuplexName</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.StorageFile">
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61102,65382.716582</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This parameter names the operation used to provide storage</Description>
<Default>OperationDuplexName</Default>
</Parameter>

<Property name="OriginatingMessageID">
<Description>
This keeps track of the OriginatingMessageID</Description>
<Type>%Integer</Type>
</Property>

<Property name="DocumentFromService">
<Description>
This is the incoming document from the business Sservice</Description>
<Type>EnsLib.DICOM.Document</Type>
</Property>

<Property name="CurrentState">
<Description>
This keeps track of the current state of the process</Description>
<Type>%String</Type>
<InitialExpression>"OperationNotConnected"</InitialExpression>
</Property>

<Property name="OperationDuplexName">
<Description>
This is the name of the operation providing storage</Description>
</Property>

<Property name="RetryCount">
<Description>
This is defines the number of times a storage operation should be retried</Description>
<Type>%Integer</Type>
<InitialExpression>3</InitialExpression>
</Property>

<Method name="OnMessage">
<Description>
Messages received here are instances of EnsLib.DICOM.Document sent to this
process by the service or operation config items. In this demo, the process is ever
in one of two states, the Operation is connected or not.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim tMsgType As %String
    do {
        
        If pInput.%Extends("Ens.AlarmResponse") {
            
            #; We are retrying, simulate 1st call
            
            #; Make sure we have a document
            Set pInput=..DocumentFromService
            
            $$$ASSERT(..CurrentState="OperationNotConnected")
        }
            
        #; If its a document sent from the service
        If pSourceConfigName'=..OperationDuplexName {
            
            #; If the operation has not been connected yet
            If ..CurrentState="OperationNotConnected" {
                
                #; We need to establish a connection to the operation,
                #; Keep hold of the incoming document
                Set ..DocumentFromService=pInput
                
                #; We will be called back at OnAssociationEstablished()
                Set tSC=..EstablishAssociation(..OperationDuplexName)
                
            } elseif ..CurrentState="OperationConnected" {
                
                #; The Operation is connected
                
                #; Get the CommandField, it contains the type of request, it should ALWAYS be present
                Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
                If $$$ISERR(tSC) Quit
        
                #; We are only handling storage requests at present
                $$$ASSERT(tMsgType="C-STORE-RQ")
        
                #; We can forward the document to the operation
                Set tSC=..SendRequestAsync(..OperationDuplexName,pInput,0) 
            }
            
        } elseif pSourceConfigName=..OperationDuplexName {
            
            #; We have received a document from the operation
            Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
            If $$$ISERR(tSC) Quit
            
            #; Should only EVER get a C-STORE-RSP
            $$$ASSERT(tMsgType="C-STORE-RSP")

            #; Now close the Association with the operation, we will be called back at
            #; OnAssociationReleased()
            Set tSC=..ReleaseAssociation(..OperationDuplexName)
            
            #; Finished with this document
            Set ..DocumentFromService="",..OriginatingMessageID=""
        }
    } while (0)
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationEstablished">
<Description>
This method is called by the framework on successful establishment of an association</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Established</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    
    If pSourceConfigName=..OperationDuplexName {
        
        #; The association with the operation has been completed, operation is now connected
        Set ..CurrentState="OperationConnected"
    
        #; Call the OnMessage() with he saved document ( if we have it )
        if ($IsObject(..DocumentFromService)) {
            Set tSC=..OnMessage(..ServiceDuplexName,..DocumentFromService)
        }   
    }
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationReleased">
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Released</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    
    $$$ASSERT(pSourceConfigName=..OperationDuplexName)
        
    #; The association between this process and the operation has been released, so we are now
    #; not connected to the operation
    Set ..CurrentState="OperationNotConnected"
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; If we are in conversation with the operation, we neet to tell the operation to ABORT its association
    If ..CurrentState="OperationConnected" {
        
        #; Form an abort message
        Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEUSER,$$$ABORTREASONNOTSPECIFIED)
        
        #; Send it to the operation
        Do ..AbortAssociation(..OperationDuplexName,tCommandAbort)
    }
    Quit pErrorStatus
]]></Implementation>
</Method>

<Method name="OnAssociationErrored">
<Description>
This callback is called by the framework when an assocation encounters an error</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Errored</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    
    #; Demonstrate Retry Logic, we will trigger a wakeup call and check for that in OnMessage()
    Set ..RetryCount=..RetryCount-1
    
    If ..RetryCount'=0 {
        Set tSC=..ScheduleWakeupCall(2)
    } else {
        #; Failed after all retries
        Set tSC=pInput.Status
    }
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnAssociationAborted">
<Description>
This callback is called by the framework when an association is aborted</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Aborted</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ..CurrentState="OperationNotConnected"
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAssociationRejected">
<Description>
This callback is called by the framework when an Association is rejected</Description>
<FormalSpec>pSourceConfigName:%String,pInput:EnsLib.DICOM.Notify.Rejected</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ..CurrentState="OperationNotConnected"
    Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>StorageFileDefaultData</DefaultData>
<Data name="StorageFileDefaultData">
<Subscript>"StorageFile"</Subscript>
<Value name="1">
<Value>OriginatingMessageID</Value>
</Value>
<Value name="2">
<Value>DocumentFromService</Value>
</Value>
<Value name="3">
<Value>CurrentState</Value>
</Value>
<Value name="4">
<Value>OperationDuplexName</Value>
</Value>
<Value name="5">
<Value>RetryCount</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.StorageLocal">
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61102,65382.716582</TimeCreated>

<Method name="OnMessage">
<Description>
Messages received here are instances of EnsLib.DICOM.Document sent to this
process by the service. The received DICOM file will be sent to the operation for persisting
in the file system. If all is well a C-STORE-RSP is sent to the service to indicate to the DICOM
peer that the storage was successful. If an error occurs the Association with the DICOM peer will
be aborted, indicating that the storage was not successful.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tMsgType,tMsgId As %String
	#dim tOutput As EnsLib.DICOM.Document
	
	Try {
		
		#; We should only ever see DICOM Documents here
		$$$ASSERT(pInput.%Extends("EnsLib.DICOM.Document"))
		
		#; We only ever get DICOM Documents from the Service
		$$$ASSERT(pSourceConfigName=..ServiceDuplexName)
		 	
 		#; Get the CommandField, it contains the type of request, it should ALWAYS be present
		Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
		If $$$ISERR(tSC) Quit

		#; We are only handling Storage Requests
		$$$ASSERT(tMsgType="C-STORE-RQ")

		#; Record the originating message id
		Set tMsgId=pInput.GetValueAt("CommandSet.MessageID",,.tSC)
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC) Quit
		
		#; We can forward the document to the operation
		Set tSC=..SendRequestSync("Demo.DICOM.Operation.File",pInput)
		If $$$ISERR(tSC) Quit
			
		#; We need to send a reply to the service in all cases, so create an appropriate response
		Set tSC=..CreateStorageResponse(pInput,.tOutput)
		If $$$ISERR(tSC) Quit
		
		#; Send the reply back to the service ( don't want a response )
		Set tSC=..SendRequestAsync(..ServiceDuplexName,tOutput,0)
		If $$$ISERR(tSC) Quit
		
		#; Stop the private session to ensure each message gets its own session				
		Set tSC=..StopPrivateSession(..ServiceDuplexName)
		If $$$ISERR(tSC) Quit
		
	} catch (e) {
		Set tSC=e.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateStorageResponse">
<Description>
Create a storage response DICOM message</Description>
<FormalSpec>pDocIn:EnsLib.DICOM.Document,*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tTemp As %String
	try {
		
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
		
		#; Create an instance of a DICOM Document to form the response
		Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
		If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
		
		#; Need to copy over the AffectedSOPClassUID (mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPClassUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPClassUID") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; Set the CommandField, this is a Storage Response
		Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-STORE-RSP"),"CommandSet.CommandField")
		If $$$ISERR(tSC) Quit
		
		#; And indicate the message id being responded to by copying over the originating message id
		Set tTemp=pDocIn.GetValueAt("CommandSet.MessageID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.MessageIDBeingRespondedTo") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		 
		#; Need to copy over the affected SOP instance id
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPInstanceUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPInstanceUID") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; Need to copy over the transfer syntax
		Set pDocOut.DataSet.TransferSyntax=pDocIn.DataSet.TransferSyntax
		
		#; Finally set a success status
		Set tSC=pDocOut.SetValueAt(0,"CommandSet.Status") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when an error response is received
Returning the same error will cause the BusinessProcess to set its status to error and close down
Returning $$$OK from this method causes the BusinessProcess to recover from this error</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Form an abort command
	Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEPROVIDER,$$$ABORTREASONNOTSPECIFIED)
		
	#; Send it to the service, this tells the peer that the storage was not successful
	Do ..AbortAssociation(..ServiceDuplexName,tCommandAbort)
	
	#; Want to continue offering the service, even if this instance failed
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.DICOM.Process.WorkList">
<Description>
This class demonstrates how to handle DICOM C-FIND-RQ and respond with worklist entries</Description>
<Super>EnsLib.DICOM.Process</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61102,65382.716582</TimeCreated>

<Parameter name="SETTINGS">
<Description>
This parameter influences the number of worklist entries returned by a C-FIND-RQ</Description>
<Default>NumberOfWorkListEntries</Default>
</Parameter>

<Property name="NumberOfWorkListEntries">
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="OriginatingMessageID">
<Description>
This keeps track of the OriginatingMessageID</Description>
<Type>%Integer</Type>
</Property>

<Property name="DocumentFromService">
<Description>
This is the incoming document from the business Sservice</Description>
<Type>EnsLib.DICOM.Document</Type>
</Property>

<Property name="ReplyCounter">
<Description>
This keeps track of the number of replies sent to the worklist request</Description>
<Type>%Integer</Type>
</Property>

<Property name="StudyInstanceCounter">
<Description>
This provides a unique counter to disambiguate StudyInstances</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
// --------------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Method name="OnMessage">
<Description>
This method handles the C-FIND-RQ and C-CANCEL-RQ messages. The find request asks for a query to be performed using the criteria
specified in the request's data-set. The query *may* take significant time and produce many results so individual matches are reported
in one or more messages. The protocol requires that all messages bar the last one have their status set to 'Pending'. This
indicates to the client that there is more data coming. The last message has a status of 'Success' which means that the query
has finished. In this example, the selection criteria are ignored and 'dummy' patient records are returned. A production 
implementation would necessarily be more complex.</Description>
<FormalSpec>pSourceConfigName:%String,pInput:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tMsgType As %String
	#dim tReply As EnsLib.DICOM.Document
	do {
		
		If pInput.%Extends("EnsLib.DICOM.Document") {
	 		
			#; Get the CommandField, it contains the type of request and should ALWAYS be present
			Set tMsgType=$$$MsgTyp2Str(pInput.GetValueAt("CommandSet.CommandField",,.tSC))
			If $$$ISERR(tSC) Quit

			If tMsgType="C-FIND-RQ" {
			
				#; The incoming document is the source document
				Set ..DocumentFromService=pInput
		
				#; Send the required number of responses
				Set ..ReplyCounter=..NumberOfWorkListEntries
				
				#; Initialize the Study Instance Counter
				Set ..StudyInstanceCounter=0
		
				#; Set a timer, will get called back immediately
				Set tSC=..ScheduleWakeupCall(0)
			
			} elseif tMsgType="C-CANCEL-RQ" {
				
				#; We received a cancel, record that fact
				Set ..ReplyCounter=0
				
			} elseif tMsgType="N-CREATE-RQ" {
				
				Set tSC=..CreateNCreateResponse(pInput,.tReply)
				If $$$ISERR(tSC) Quit
				
				#; Send the reply back to the service ( don't want a response )
				Set tSC=..SendRequestAsync(..ServiceDuplexName,tReply,0)
				
			} else {
				Set tSC=$$$ERROR($$$EnsDICOMUnexpectedMessage,tMsgType)
			}
			
		} elseif pInput.%Extends("Ens.AlarmResponse") {
		
			If ..ReplyCounter=0 
			{
				#; No more to send, create and send a final respnse
				Set tSC=..CreateFinalFindResponse(..DocumentFromService,.tReply)
				If $$$ISERR(tSC) Quit
			
				#; Send the reply back to the service ( don't want a response )
				Set tSC=..SendRequestAsync(..ServiceDuplexName,tReply,0)
			
			} else {
			
				#; More to send, create and send an intermediate response
				Set tSC=..CreateIntermediateFindResponse(..DocumentFromService,.tReply)
				If $$$ISERR(tSC) Quit
			
				#; Send the reply back to the service ( don't want a response )
				Set tSC=..SendRequestAsync(..ServiceDuplexName,tReply,0)
			
				#; Decrement the reply counter
				Set ..ReplyCounter=..ReplyCounter-1
				
				#; Set the timer so we are called back again, we use 1 second here
				#; so that the user of the demo has a chance send a cancel request. In
				#; a production implementation this should be set to 0 seconds
				Set tSC=..ScheduleWakeupCall(1)
			}
			
		} else {
			
			#; We are not expecting any other messages here
			$$$ASSERT(0)
		}
 		
	} while (0)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when any error occurs. Returning the same error will cause the BusinessProcess to set its
status to error and close down</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tCommandAbort=##class(EnsLib.DICOM.Command.Abort).%New($$$ABORTSOURCESERVICEPROVIDER,$$$ABORTREASONNOTSPECIFIED)
	Do ..AbortAssociation(..ServiceDuplexName,tCommandAbort)
	Quit pErrorStatus
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// -----------------------------------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Method name="CreateIntermediateFindResponse">
<Description>
Create an Intermediate find response</Description>
<FormalSpec>pDocIn:EnsLib.DICOM.Document,*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tTemp As %String
	try {
		
		#; Increment the study instance counter
		Set ..StudyInstanceCounter=..StudyInstanceCounter+1
		
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
		
		#; Now create an instance of a message to form the response
		Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
		If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
		
		#; Need to copy over the AffectedSOPClassUID (mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPClassUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPClassUID") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; And indicate the message id being responded to
		Set tTemp=pDocIn.GetValueAt("CommandSet.MessageID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.MessageIDBeingRespondedTo") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		 
		#; Set the CommandField, this is a Find Response
		Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-FIND-RSP"),"CommandSet.CommandField")
		If $$$ISERR(tSC) Quit
		
		#; Set the Status to 'Pending'. A Find response consists of multiple messages, each message that has worklist
		#; data should be sent with a status set to pending. The final message should contain no dataset and should have its
		#; status set to 'Success'
		/* 65281 = "Pending: Optional Keys Supported" */
		Set tSC=pDocOut.SetValueAt(65281,"CommandSet.Status") If $$$ISERR(tSC) Quit
					
		#; Need to copy over the transfer syntax
		Set pDocOut.DataSet.TransferSyntax=pDocIn.DataSet.TransferSyntax
		
		#; Now build the dataset. A real implementation would examine the request's dataset to determine and
		#; act upon the request matching criteria. Here we will just build a dummy worklist entry by way of an example
		
		Set tSC=pDocOut.SetValueAt("80372376","DataSet.AccessionNumber") 
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("Patient"_$Random(100)_"^Name","DataSet.PatientName")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("43171525","DataSet.PatientID")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("1.2.40.0.13.0.192.168.1.3.13594894.1206712911593."_..StudyInstanceCounter,"DataSet.StudyInstanceUID")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("RequestedProcedureDescription","DataSet.RequestedProcedureDescription")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("OT","DataSet.ScheduledProcedureStepSequence[1].Modality")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("StationAET","DataSet.ScheduledProcedureStepSequence[1].ScheduledStationAETitle")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("20080328","DataSet.ScheduledProcedureStepSequence[1].ScheduledProcedureStepStartDate")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("100151.000","DataSet.ScheduledProcedureStepSequence[1].ScheduledProcedureStepStartTime")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("ScheduledProcedureStepDescription","DataSet.ScheduledProcedureStepSequence[1].ScheduledProcedureStepDescription")
		If $$$ISERR(tSC)
		Set tSC=pDocOut.SetValueAt("80871868","DataSet.ScheduledProcedureStepSequence[1].ScheduledProcedureStepID")
		If $$$ISERR(tSC) Quit
		Set tSC=pDocOut.SetValueAt("91249028","DataSet.RequestedProcedureID")
		If $$$ISERR(tSC) Quit
		
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateFinalFindResponse">
<Description>
Create a Final Find Response</Description>
<FormalSpec>pDocIn:EnsLib.DICOM.Document,*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status =$$$OK
	#dim tTemp As %String
	
	try {
	
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
		
		#; Now create an instance of a message to indicate that the find process is complete
		Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
		If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
		
		#; Need to copy over the AffectedSOPClassUID (mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPClassUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPClassUID") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; And indicate the message id being responded to ( mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.MessageID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.MessageIDBeingRespondedTo") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; Set the CommandField, this is a Find Response
		Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("C-FIND-RSP"),"CommandSet.CommandField")
		If $$$ISERR(tSC) Quit
		
		#; Need to copy over the transfer syntax
		Set pDocOut.DataSet.TransferSyntax=pDocIn.DataSet.TransferSyntax
		
		#; Set the Status to Success, this means the find process is complete
		/* 0 = SUCCESS */
		Set tSC=pDocOut.SetValueAt(0,"CommandSet.Status") If $$$ISERR(tSC) Quit
		
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateNCreateResponse">
<Description>
Create a response to N-CREATE-RQ</Description>
<FormalSpec>pDocIn:EnsLib.DICOM.Document,*pDocOut:EnsLib.DICOM.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status =$$$OK
	#dim tTemp As %String
	
	try {
	
		#; Get the current storage location
		Set tStorageLocation=..GetProductionSettingValue("StorageLocation",.tSC)
		If $$$ISERR(tSC) Quit
		
		#; Now create an instance of a message to indicate that the find process is complete
		Kill %objlasterror Set pDocOut=##class(EnsLib.DICOM.Document).%New(tStorageLocation)
		If '$IsObject(pDocOut) Set tSC=$Get(%objlasterror,$$$ERROR($$$FailedToNewClass,"EnsLib.DICOM.Document")) Quit
		
		#; Need to copy over the AffectedSOPClassUID (mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.AffectedSOPClassUID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.AffectedSOPClassUID") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; And indicate the message id being responded to ( mandatory field)
		Set tTemp=pDocIn.GetValueAt("CommandSet.MessageID",,.tSC)
		$$$ASSERT('$$$ISERR(tSC))
		
		Set tSC=pDocOut.SetValueAt(tTemp,"CommandSet.MessageIDBeingRespondedTo") If $$$ISERR(tSC) Quit
		If $$$ISERR(tSC) Quit
		
		#; Set the CommandField, this is a N-CREATE-RSP
		Set tSC=pDocOut.SetValueAt($$$Str2MsgTyp("N-CREATE-RSP"),"CommandSet.CommandField")
		If $$$ISERR(tSC) Quit
		
		#; Need to copy over the transfer syntax
		Set pDocOut.DataSet.TransferSyntax=pDocIn.DataSet.TransferSyntax
		
		#; Set the Status to Success, this means the process is complete
		/* 0 = SUCCESS */
		Set tSC=pDocOut.SetValueAt(0,"CommandSet.Status") If $$$ISERR(tSC) Quit
		
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>WorkListDefaultData</DefaultData>
<Data name="WorkListDefaultData">
<Structure>listnode</Structure>
<Subscript>"WorkList"</Subscript>
<Value name="1">
<Value>NumberOfWorkListEntries</Value>
</Value>
<Value name="2">
<Value>OriginatingMessageID</Value>
</Value>
<Value name="3">
<Value>DocumentFromService</Value>
</Value>
<Value name="4">
<Value>ReplyCounter</Value>
</Value>
<Value name="5">
<Value>StudyInstanceCounter</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.DICOM.Production.AsyncRouter">
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63315,42529.023566</TimeCreated>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Parameter name="SETTINGS">
<Default>StorageLocation</Default>
</Parameter>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !,"Configure JDICOM Storage      AET JD-SCU, localhost, 1112"
	Write !,"Configure JDICOM ImageServer  AET JD-SCP, localhost, 4096"
	
	#; We will be accepting Storage requests from JD-SCU
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	
	#; We will be sending storage requests to the JD-SCP
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
		
	Quit
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Make sure that the associations exist
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("JD-SCU","ENS-SCP") {
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("ENS-SCU","JD-SCP") {
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.AsyncRouter" TestingEnabled="false" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Item Name="AsyncDispatcher" Category="" ClassName="Demo.DICOM.Process.AsyncRouterDispatcher" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="FilerConfigNames">AsyncFiler1,AsyncFiler2</Setting>
    <Setting Target="Host" Name="RuleClass">Demo.DICOM.Util.TestRoutingRule</Setting>
    <Setting Target="Host" Name="StoreIgnoredEntries">1</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
  </Item>
  <Item Name="AsyncFiler1" Category="" ClassName="Demo.DICOM.Process.AsyncRouterFiler" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="OperationDuplexName">PACS1Operation</Setting>
    <Setting Target="Host" Name="RemoveCompletedEntries">0</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="RetryCount">3</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
  </Item>
  <Item Name="AsyncFiler2" Category="" ClassName="Demo.DICOM.Process.AsyncRouterFiler" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="OperationDuplexName">PACS2Operation</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="RemoveCompletedEntries">0</Setting>
    <Setting Target="Host" Name="RetryCount">3</Setting>
  </Item>
  <Item Name="Listener" Category="" ClassName="EnsLib.DICOM.Service.TCP" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">AsyncDispatcher</Setting>
    <Setting Target="Adapter" Name="IPAddress"></Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCP</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCU</Setting>
    <Setting Target="Adapter" Name="IPPort">1112</Setting>
  </Item>
  <Item Name="PACS1Operation" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">localhost</Setting>
    <Setting Target="Adapter" Name="IPPort">4096</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCP</Setting>
    <Setting Target="Host" Name="DuplexTargetConfigName">AsyncFiler1</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="ReplyCodeActions"></Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
  </Item>
  <Item Name="PACS2Operation" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">AsyncFiler2</Setting>
    <Setting Target="Adapter" Name="IPAddress">localhost</Setting>
    <Setting Target="Adapter" Name="IPPort">4098</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCP</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="ReplyCodeActions"></Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
  </Item>
  <Item Name="Ens.Alert" Category="" ClassName="EnsLib.EMail.AlertOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="From">ensemble@mycompany.test</Setting>
    <Setting Target="Adapter" Name="Recipient">ensemble@mycompany.test</Setting>
    <Setting Target="Adapter" Name="SMTPPort">25</Setting>
    <Setting Target="Adapter" Name="SMTPServer">smtp.mycompany.test</Setting>
    <Setting Target="Adapter" Name="Credentials"></Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.DICOM.Production.Modality">
<Description>
This production simulates a Modality performing a C-FIND Request Demonstrates how to perform a C-FIND Request
and also how to perform a C-CANCEL-RQ. You'll need a good emulator to connect to (Note that DVTK QR SCP program won't
work for this as it's implementation of Cancel is buggy)

Exercise this Demo by sending a test message (doesn't matter what) to the Demo.DICOM.Process.Modality process.
View the message trace to see issued find and cancel requests and how to handle them</Description>
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62888,63141.515362</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.Modality" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Item Name="EnsLib.DICOM.Operation.TCP" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="DuplexTargetConfigName">Demo.DICOM.Process.Modality</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">DVTKSCP_PATIENT</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">107</Setting>
    <Setting Target="Adapter" Name="IPAddress">10.30.4.112</Setting>
  </Item>
  <Item Name="Demo.DICOM.Process.Modality" Category="" ClassName="Demo.DICOM.Process.Modality" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="OperationDuplexName">EnsLib.DICOM.Operation.TCP</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,StorageLocation</Default>
</Parameter>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
    #; We will be sending storage requests to the JD-SCP
    Quit ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("DVTK_QR_SCU","DVTK_QR_SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tSC=$$$OK
    
    #; Make sure that the associations exist
    If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("ENS-SCU","JD-SCP")
    {
        Set tSC=..Setup()
    }
    
    Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Production.Router">
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61096,56809.35922</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.Router" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Item Name="LISTENER" Category="" ClassName="EnsLib.DICOM.Service.TCP" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">DISPATCHER</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCP</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCU</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">1112</Setting>
    <Setting Target="Adapter" Name="CallInterval">1</Setting>
  </Item>
  <Item Name="DISPATCHER" Category="" ClassName="Demo.DICOM.Process.RouterDispatcher" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="FilerConfigNames">PACS1FILER,PACS2FILER</Setting>
  </Item>
  <Item Name="PACS1FILER" Category="" ClassName="Demo.DICOM.Process.RouterFiler" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="OperationDuplexName">PACS1OPERATION</Setting>
    <Setting Target="Host" Name="ReplyCodeActions"></Setting>
    <Setting Target="Host" Name="RetryInterval">10</Setting>
    <Setting Target="Host" Name="FailureTimeout">-1</Setting>
  </Item>
  <Item Name="PACS2FILER" Category="" ClassName="Demo.DICOM.Process.RouterFiler" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="OperationDuplexName">PACS2OPERATION</Setting>
    <Setting Target="Host" Name="ReplyCodeActions"></Setting>
    <Setting Target="Host" Name="RetryInterval">10</Setting>
    <Setting Target="Host" Name="FailureTimeout">-1</Setting>
  </Item>
  <Item Name="PACS1OPERATION" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">PACS1FILER</Setting>
    <Setting Target="Host" Name="ReplyCodeActions">E*Unable to open Device=R</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">-1</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCP</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">4096</Setting>
    <Setting Target="Adapter" Name="IPAddress">localhost</Setting>
  </Item>
  <Item Name="PACS2OPERATION" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">PACS2FILER</Setting>
    <Setting Target="Host" Name="ReplyCodeActions">E*Unable to open Device=R</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">-1</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCP</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">4098</Setting>
    <Setting Target="Adapter" Name="IPAddress">localhost</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,StorageLocation</Default>
</Parameter>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !,"Configure JDICOM Storage      AET JD-SCU, localhost, 1112"
	Write !,"Configure JDICOM ImageServer  AET JD-SCP, localhost, 4096"
	
	#; We will be accepting Storage requests from JD-SCU
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	
	#; We will be sending storage requests to the JD-SCP
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
		
	Quit
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Make sure that the associations exist
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("JD-SCU","ENS-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("ENS-SCU","JD-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Production.Storage">
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61096,56809.35922</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.Storage" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Item Name="EnsLib.DICOM.Operation.TCP" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="true" InactivityTimeout="0" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">Demo.DICOM.Process.Storage</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCP</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">4096</Setting>
    <Setting Target="Adapter" Name="IPAddress">localhost</Setting>
  </Item>
  <Item Name="EnsLib.DICOM.Service.TCP" Category="" ClassName="EnsLib.DICOM.Service.TCP" PoolSize="1" Enabled="true" Foreground="true" InactivityTimeout="0" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">Demo.DICOM.Process.Storage</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCP</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCU</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">1112</Setting>
    <Setting Target="Adapter" Name="CallInterval">1</Setting>
  </Item>
  <Item Name="Demo.DICOM.Process.Storage" Category="" ClassName="Demo.DICOM.Process.Storage" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="OperationDuplexName">EnsLib.DICOM.Operation.TCP</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,StorageLocation</Default>
</Parameter>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !,"Configure JDICOM Storage      AET JD-SCU, localhost, 1112"
	Write !,"Configure JDICOM ImageServer  AET JD-SCP, localhost, 4096"
	
	#; We will be accepting Storage and Query requests from JD-SCU
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	
	#; We will be sending storage requests to the JD-SCP
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
		
	Quit
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Make sure that the associations exist
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("JD-SCU","ENS-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("ENS-SCU","JD-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Production.StorageFile">
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61096,56809.35922</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.StorageFile" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Item Name="EnsLib.DICOM.Operation.TCP" Category="" ClassName="EnsLib.DICOM.Operation.TCP" PoolSize="1" Enabled="true" Foreground="true" InactivityTimeout="0" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">Demo.DICOM.Process.StorageFile</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCU</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCP</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">4096</Setting>
    <Setting Target="Adapter" Name="IPAddress">localhost</Setting>
  </Item>
  <Item Name="Demo.DICOM.Process.StorageFile" Category="" ClassName="Demo.DICOM.Process.StorageFile" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="OperationDuplexName">EnsLib.DICOM.Operation.TCP</Setting>
  </Item>
  <Item Name="EnsLib.DICOM.Service.File" Category="" ClassName="EnsLib.DICOM.Service.File" PoolSize="1" Enabled="false" Foreground="true" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="TargetConfigName">Demo.DICOM.Process.StorageFile</Setting>
    <Setting Target="Adapter" Name="FilePath">\tmp</Setting>
    <Setting Target="Adapter" Name="FileSpec">*.dcm</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,StorageLocation</Default>
</Parameter>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !,"Configure JDICOM Storage      AET JD-SCU, localhost, 1112"
	Write !,"Configure JDICOM ImageServer  AET JD-SCP, localhost, 4096"
	
	#; We will be accepting Storage and Query requests from JD-SCU
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	
	#; We will be sending storage requests to the JD-SCP
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
		
	Quit
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Make sure that the associations exist
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("JD-SCU","ENS-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("ENS-SCU","JD-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("ENS-SCU","JD-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Production.StorageLocal">
<Description>
This production demonstrates how to receive C-STORE requests and store them as
DICOM files in the ensemble file structure</Description>
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61096,56809.35922</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.StorageLocal" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Item Name="EnsLib.DICOM.Service.TCP" Category="" ClassName="EnsLib.DICOM.Service.TCP" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="DuplexTargetConfigName">Demo.DICOM.Process.StorageLocal</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCP</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCU</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">1112</Setting>
    <Setting Target="Adapter" Name="CallInterval">1</Setting>
  </Item>
  <Item Name="Demo.DICOM.Process.StorageLocal" Category="" ClassName="Demo.DICOM.Process.StorageLocal" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Demo.DICOM.Operation.File" Category="" ClassName="Demo.DICOM.Operation.File" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
</Production>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,StorageLocation</Default>
</Parameter>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !,"Configure JDICOM Storage      AET JD-SCU, localhost, 1112"
	
	#; We will be accepting Storage and Query requests from JD-SCU
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
		
	Quit
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Make sure that the associations exist
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("JD-SCU","ENS-SCP")
	{
		Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Production.WorkList">
<IncludeCode>EnsDICOM</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61667,64085.037585</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.DICOM.Production.WorkList" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Setting Target="Production" Name="StorageLocation"></Setting>
  <Item Name="EnsLib.DICOM.Service.TCP" Category="" ClassName="EnsLib.DICOM.Service.TCP" PoolSize="1" Enabled="true" Foreground="true" InactivityTimeout="0" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="DuplexTargetConfigName">Demo.DICOM.Process.WorkList</Setting>
    <Setting Target="Adapter" Name="LocalAET">ENS-SCP</Setting>
    <Setting Target="Adapter" Name="RemoteAET">JD-SCU</Setting>
    <Setting Target="Adapter" Name="TraceVerbosity">2</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="IPPort">1112</Setting>
    <Setting Target="Adapter" Name="CallInterval">1</Setting>
  </Item>
  <Item Name="Demo.DICOM.Process.WorkList" Category="" ClassName="Demo.DICOM.Process.WorkList" PoolSize="1" Enabled="true" Foreground="true" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="NumberOfWorkListEntries">10</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,StorageLocation</Default>
</Parameter>

<Property name="StorageLocation">
<Description>
This is the storage location for the DICOM streams to be stored</Description>
<Type>%String</Type>
</Property>

<Method name="Setup">
<Description>
This is a setup method which configures DICOM for the demo.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !,"Please configure JDICOM ModalitySCU with AET:JD-SCU, host: localhost, port:1112"
	
	#; We will be accepting Storage and Query requests from JD-SCU
	Do ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
		
	Quit
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Make sure that the association exists
	If '##class(EnsLib.DICOM.Util.AssociationContext).AETExists("JD-SCU","ENS-SCP")
	{
		Quit ##class(EnsLib.DICOM.Util.AssociationContext).CreateAssociation("JD-SCU","ENS-SCP",$ListBuild($$$IMPLICITVRLETRANSFERSYNTAX))
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Util.AbstractRoutingRule">
<Description><![CDATA[
Utility class for DICOM async routing
Extend this class and implement method <method>SendToTargetFiler</method> to define routing rules for the async dispatcher ]]></Description>
<IncludeCode>Ensemble</IncludeCode>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64212,41372.010555</TimeCreated>

<Parameter name="DOMAIN">
<Default>ENSDEMO</Default>
</Parameter>

<Method name="SendToTargetFiler">
<Description>
Determines if the specified DICOM document should be routed to the
named filer. The result of the evaluation is passed back in pRouteToFiler 
(which should be passed into this method by reference)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDCMDocument:EnsLib.DICOM.Document,pFilerName:%String,*pRouteToFiler:%Boolean,*pReason:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; SubclassResponsibility
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.DICOM.Util.TestRoutingRule">
<Description>
Demo utility class for DICOM routing</Description>
<Super>Demo.DICOM.Util.AbstractRoutingRule</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64211,39640.30879</TimeCreated>

<Method name="SendToTargetFiler">
<Description>
Determines if the specified DICOM document should be routed to the
named filer. The result of the evaluation is passed back in pRouteToFiler 
(which should be passed into this method by reference)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDCMDocument:EnsLib.DICOM.Document,pFilerName:%String,*pRouteToFiler:%Boolean,*pReason:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC as %Status=$$$OK
	#dim ex as %Exception.AbstractException
	
	$$$ASSERT(pDCMDocument.%Extends("EnsLib.DICOM.Document"))
	
	Try {
		
		#; Initialize return values
		Set pRouteToFiler=0
		Set pReason=""
		
		#; If Modality = CT or CR, then only send to AsyncFiler2
		If $Case(pDCMDocument.GetValueAt("DataSet.Modality"),"CR":1,"CT":1,:0) {
			If pFilerName="AsyncFiler2" {
				Set pRouteToFiler=1
			} Else {
				Set pReason=$$$FormatText($$$Text("Modality %1 not routed to filer %2."),pDCMDocument.GetValueAt("DataSet.Modality"),"AsyncFiler1")	
			}
		} Else {
			#; Otherwise send to both AsyncFiler1 and AsyncFiler2
			If (pFilerName="AsyncFiler1") Set pRouteToFiler=1
			If (pFilerName="AsyncFiler2") Set pRouteToFiler=1
		}
	
	} catch ex {
		Set tSC=ex.AsStatus()
		$$$TRACE($$$FormatText($$$Text("Error in SendToTargetFiler: %1"),ex.DisplayString()))	
	}

	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Dashboard.DashboardsEtc">
<Description><![CDATA[
This class defines the initial definitions of the dashboards for the ENSDEMO namespace.
When this class is compiled (or recompiled), DeepSee copies the dashboard definitions out of
this class. Then the dashboards are available in the DeepSee User Portal and Folder Manager.
They are also listed in Studio as .DFI items, in the Other folder in the Workspace window.
<p>These dashboards display data only when specific productions are running; see the dashboard
descriptions.
<p>This class also defines some sample links for the DeepSee User Portal.]]></Description>
<Super>%DeepSee.UserLibrary.Container</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62867,38753.826747</TimeCreated>

<XData name="Contents">
<Description>
It is convenient to list items here in the same order in which Studio 
lists them, and to precede each with a comment that gives its full name.</Description>
<XMLNamespace>http://www.intersystems.com/deepsee/library</XMLNamespace>
<Data><![CDATA[
<items>

<!-- Dashboard with Charts.dashboard -->
<dashboard xmlns="http://www.intersystems.com/deepsee/library" name="Dashboard with Charts" folderName="" title="" description="This sample dashboard displays random sales information based on the Demo.Dashboard.SalesMetrics class." keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background:white;&apos;,src:&apos;covers/8211681_s.jpg&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;$title&apos;,style:&apos;font-weight: bold;font-variant: small-caps;left:21.875px;left:21.875px;width:95px;&apos;},image: {style:&apos;display: none;&apos;,src:&apos;deepsee/ds2_dashboard_44.png&apos;,imageStyle:&apos;width:64px;height:64px;&apos;},subtitle: {},footer: {text:&apos;Requires Dashboard production&apos;}}" scheme="" worklistCount="0" snapTo="false" snapGrid="true" gridRows="10" gridCols="10" canResize="true" canModify="true" showTitleBar="true" companyName="Demo" companyLogo="" companyStyle="">
  <widget name="pieChartTotalSales" type="pivot" subtype="areaChart" subtypeClass="lineChart" title="Area Line Chart: Recent Sales Figures" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="0" width="525" height="395" sidebarContent="At left you will find information about recent sales revenues from various fruits. For details and past results, call your regional sales manager. Meanwhile, at right you will find information about number of units sold of each type of fruit. At far right is a bar chart showing both values for each product sold." showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="0" colSpanL="3" rowSpanL="5" showToolbar="true" theme="">
    <control name="" action="refresh" target="*" targetProperty="" location="widget" type="timer" controlClass="" timeout="5" label="Refresh" title="Refresh this chart" value="" text="" readOnly="false" valueList="" displayList="" activeWhen=""></control>
    <dataProperty name="" label="" width="" align="" subtype="" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="XgridLines">1</property>
    <property name="YgridLines">1</property>
    <property name="analyzer">1</property>
    <property name="chartToggle">chart</property>
    <property name="excel">1</property>
    <property name="labels">1</property>
    <property name="legendPos">none</property>
    <property name="print">1</property>
  </widget>
  <widget name="pieChart3D" type="pivot" subtype="pieChart3D" subtypeClass="pieChart" title="3D Pie Chart: Number of Units Sold" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="522" width="420" height="394" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="3" colSpanL="4" rowSpanL="5" showToolbar="true" theme="">
    <dataProperty name="" label="Total Units" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Units" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="chartToggle">chart</property>
    <property name="excel">1</property>
    <property name="labels">0</property>
    <property name="legendPos">right</property>
    <property name="print">1</property>
  </widget>
  <widget name="barChartSalesUnits" type="pivot" subtype="columnChartStacked" subtypeClass="barChart" title="Stacked Column Chart: Sales and Units" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="401" left="0" width="369" height="394" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="7" colSpanL="3" rowSpanL="5" showToolbar="true" theme="">
    <dataProperty name="" label="Sales Figures" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <dataProperty name="" label="Units Sold" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Units" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="XgridLines">1</property>
    <property name="YgridLines">1</property>
    <property name="chartToggle">chart</property>
    <property name="excel">1</property>
    <property name="labels">1</property>
    <property name="legendPos">bottom</property>
    <property name="print">1</property>
  </widget>
</dashboard>

<!-- Dashboard with Meters.dashboard -->
<dashboard xmlns="http://www.intersystems.com/deepsee/library" name="Dashboard with Meters" folderName="" title="" description="This sample dashboard displays random sales information based on the Demo.Dashboard.SalesMetrics class." keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background-color:white;top:71.875px;left:28.125px;left:28.125px;width:85px;height:90px;&apos;,src:&apos;covers/11259257_s.jpg&apos;,imageStyle:&apos;width:85px;height:90px;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;$title&apos;,style:&apos;color:green;font-family:verdana;left:21.875px;left:21.875px;width:97.5px;&apos;},image: {style:&apos;display: none;top:106.25px;left:3.125px;left:3.125px;width:87.5px;height:87.5px;&apos;,imageStyle:&apos;width:87.5px;height:87.5px;&apos;},footer: {text:&apos;Requires Dashboard production&apos;}}" scheme="" worklistCount="0" snapTo="false" snapGrid="true" gridRows="2" gridCols="3" canResize="true" canModify="true" showTitleBar="true" companyName="Demo" companyLogo="" companyStyle="">
  <widget name="speedometer" type="meter" subtype="speedometer" subtypeClass="" title="Speedometer" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="0" width="229" height="222" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="0" colSpanL="1" rowSpanL="1" showToolbar="true" theme="">
    <control name="" action="refresh" target="*" targetProperty="" location="widget" type="timer" controlClass="" timeout="5" label="Refresh" title="Refresh the meter display" value="" text="" readOnly="false" valueList="" displayList="" activeWhen=""></control>
    <dataProperty name="" label="Recent Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
  </widget>
  <widget name="fuelGauge" type="meter" subtype="fuelGauge" subtypeClass="" title="Fuel Gauge" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="228" width="198" height="222" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="2" colSpanL="1" rowSpanL="1" showToolbar="true" theme="">
    <dataProperty name="" label="Recent Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
  </widget>
  <widget name="text" type="meter" subtype="textMeter" subtypeClass="" title="Text Meter" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="425" width="208" height="222" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="1" colSpanL="1" rowSpanL="1" showToolbar="true" theme="">
    <dataProperty name="" label="$auto" width="" align="" subtype="textMeter" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="News" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override="{height:67,width:268,dataBinding:&apos;Sales&apos;,label:&apos;$auto&apos;,value:&apos;44&apos;,_type:&apos;textMeter&apos;}"></dataProperty>
  </widget>
  <widget name="trafficLight" type="meter" subtype="trafficLight" subtypeClass="" title="Traffic Light" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="221" left="0" width="196" height="222" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="1" homeColL="0" colSpanL="1" rowSpanL="1" showToolbar="true" theme="">
    <dataProperty name="" label="Recent Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="highRangeColor">green</property>
    <property name="lowRangeColor">red</property>
  </widget>
  <widget name="lightBar" type="meter" subtype="lightBar" subtypeClass="" title="Light Bar" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="221" left="195" width="196" height="222" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="1" homeColL="1" colSpanL="1" rowSpanL="1" showToolbar="true" theme="">
    <dataProperty name="" label="Recent Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
  </widget>
  <widget name="smiley" type="meter" subtype="smiley" subtypeClass="" title="Smiley" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="221" left="390" width="243" height="222" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="1" homeColL="2" colSpanL="1" rowSpanL="1" showToolbar="true" theme="">
    <dataProperty name="" label="Recent Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
  </widget>
</dashboard>

<!-- Links/Ensemble Monitor.link -->
<link xmlns="http://www.intersystems.com/deepsee/library" name="Ensemble Monitor" folderName="Links" title="" description="Ensemble Monitor Page (see performance across all namespaces)" keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background:white;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;$title&apos;,style:&apos;color:rgb(224, 0, 0);font-family:lucida sans unicode;font-size:22px;padding:7px;top:15px;&apos;},image: {style:&apos;top:84.375px;left:25px;left:25px;width:92.5px;height:90px;&apos;,src:&apos;covers/14865209_s.jpg&apos;,imageStyle:&apos;width:92.5px;height:90px;&apos;},footer: {text:&apos;$owner&apos;,style:&apos;display: none;&apos;}}" href="/csp/sys/%25CSP.UI.Portal.EnsembleMonitor.zen">
</link>

<!-- Links/Event Log ENSDEMO.link -->
<link xmlns="http://www.intersystems.com/deepsee/library" name="Event Log ENSDEMO" folderName="Links" title="" description="Event Log Page in ENSDEMO namespace" keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background-color:white;opacity:0.79;&apos;,src:&apos;covers/11008485_s.jpg&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;Event Log&apos;,style:&apos;font-weight: bold;color:rgb(255, 255, 255);font-size:31px;padding:0px;top:59.375px;&apos;},image: {style:&apos;display: none;&apos;},footer: {text:&apos;ENSDEMO&apos;,style:&apos;color:rgb(0, 0, 0);background-color:rgb(190, 226, 250);&apos;}}" href="/csp/ensdemo/EnsPortal.EventLog.zen?$NAMESPACE=ENSDEMO&amp;$NAMESPACE=ENSDEMO">
</link>

<!-- Links/InterSystems Documentation.link -->
<link xmlns="http://www.intersystems.com/deepsee/library" name="InterSystems Documentation" folderName="Links" title="" description="Access DOCBOOK application (if available)" keywords="" owner="" shared="true" public="true" locked="false" resource="" timeCreated="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background:white;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;$title&apos;},image: {style:&apos;top:59.375px;width:140px;height:135px;&apos;,src:&apos;covers/book_128.gif&apos;,imageStyle:&apos;width:140px;height:135px;&apos;},footer: {text:&apos;$owner&apos;}}" href="/csp/docbook/DocBook.UI.HomePageZen.cls">
</link>

<!-- Links/InterSystems Web Site.link -->
<link xmlns="http://www.intersystems.com/deepsee/library" name="InterSystems Web Site" folderName="Links" title="" description="" keywords="" owner="" shared="true" public="true" locked="false" resource="" timeCreated="2013-01-30T22:49:09.292Z" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background:white;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;$title&apos;,style:&apos;font-weight: bold;font-variant: small-caps;color:rgb(0, 75, 152);font-size:18px;&apos;},image: {style:&apos;top:68.75px;left:9.375px;left:9.375px;width:120px;height:115px;&apos;,src:&apos;covers/world_128.gif&apos;,imageStyle:&apos;width:120px;height:115px;&apos;},footer: {text:&apos;$owner&apos;}}" href="http://www.intersystems.com">
</link>

<!-- Links/Queues ENSDEMO.link -->
<link xmlns="http://www.intersystems.com/deepsee/library" name="Queues ENSDEMO" folderName="Links" title="" description="Queues Page in ENSDEMO namespace" keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="2013-02-15T16:07:36.688Z" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background:white;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;Queues&apos;,style:&apos;color:rgb(0, 75, 152);font-family:courier new;font-size:26px;&apos;},image: {style:&apos;left:18.75px;left:18.75px;width:102.5px;height:102.5px;&apos;,src:&apos;covers/8891476_s.jpg&apos;,imageStyle:&apos;width:102.5px;height:102.5px;&apos;},footer: {text:&apos;ENSDEMO&apos;,style:&apos;color:rgb(0, 0, 0);background-color:rgb(190, 226, 250);&apos;}}" href="/csp/ensdemo/EnsPortal.Queues.zen">
</link>

<!-- Links/Production Configuration ENSDEMO.link -->
<link xmlns="http://www.intersystems.com/deepsee/library" name="Production Configuration ENSDEMO" folderName="Links" title="" description="Production Configuration Page in ENSDEMO namespace" keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="2013-02-14T18:23:57.985Z" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background:white;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;Production Configuration&apos;,style:&apos;font-weight: bold;color:rgb(38, 62, 86);&apos;},image: {style:&apos;width:135px;height:120px;&apos;,src:&apos;covers/14458232_s.jpg&apos;,imageStyle:&apos;width:135px;height:120px;&apos;},footer: {text:&apos;ENSDEMO&apos;,style:&apos;color:rgb(0, 0, 0);background-color:rgb(190, 226, 250);&apos;}}" href="/csp/ensdemo/EnsPortal.ProductionConfig.zen">
</link>

<!-- Loan Dashboard.dashboard -->
<dashboard xmlns="http://www.intersystems.com/deepsee/library" name="Loan Dashboard" folderName="" title="" description="This sample dashboard uses Demo.Loan.FindRateProduction." keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background-color:white;opacity:1;&apos;,imageStyle:&apos;width:134px;&apos;},header: {text:&apos;$type&apos;,style:&apos;text-align: center;&apos;},title: {text:&apos;$title&apos;,style:&apos;text-align: center;font-weight: bold;padding:2px;&apos;},image: {style:&apos;top:62.5px;left:37.5px;left:37.5px;width:67.5px;height:87.5px;&apos;,src:&apos;covers/10001316_s.jpg&apos;,imageStyle:&apos;width:67.5px;height:87.5px;&apos;},footer: {text:&apos;Requires FindRateProduction&apos;,style:&apos;background-color:rgb(0, 0, 224);&apos;}}" scheme="" worklistCount="0" snapTo="true" snapGrid="true" gridRows="10" gridCols="10" canResize="true" canModify="true" showTitleBar="true" companyName="Demo" companyLogo="" companyStyle="">
  <widget name="speedometer" type="meter" subtype="speedometer" subtypeClass="" title="Loan Statistics" dataSource="Demo.Loan.FindRateProduction/Demo.Loan.BankMetrics.metric" dataLink="" drillDownDataSource="" top="16" left="15" width="936" height="528" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="0" colSpanL="5" rowSpanL="5" showToolbar="true" theme="">
    <control name="" action="applyFilter" target="*" targetProperty="" location="widget" type="timer" controlClass="" timeout="5" label="" title="" value="" text="" readOnly="false" valueList="" displayList="" activeWhen=""></control>
    <dataProperty name="" label="Loan Requests" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="LoansRequested" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <dataProperty name="" label="Approval Notifications" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="LoansApproved" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="format">#,#</property>
    <property name="highRangeColor">green</property>
    <property name="labelStyle"></property>
  </widget>
</dashboard>

<!-- Sales Dashboard.dashboard -->
<dashboard xmlns="http://www.intersystems.com/deepsee/library" name="Sales Dashboard" folderName="" title="" description="This sample dashboard displays random sales information based on the Demo.Dashboard.SalesMetrics class." keywords="Ensemble" owner="" shared="true" public="true" locked="false" resource="" timeCreated="" createdBy="" category="Sample Category" bookCover="{background: {style:&apos;background-color:white;top:9.375px;&apos;,src:&apos;covers/14790293_s.jpg&apos;,imageStyle:&apos;width:134px;height:190px;&apos;},header: {text:&apos;$type&apos;},title: {text:&apos;$title&apos;,style:&apos;text-align: left;font-variant: small-caps;color:rgb(224, 0, 0);padding:6px;border-radius:16px 16px 16px 16px;top:9.375px;width:105px;&apos;},image: {style:&apos;display: none;&apos;,src:&apos;deepsee/ds2_dashboard_44.png&apos;,imageStyle:&apos;width:64px;height:64px;&apos;},subtitle: {style:&apos;display: none;&apos;},footer: {text:&apos;Requires Dashboard production&apos;}}" scheme="" worklistCount="0" snapTo="false" snapGrid="true" gridRows="10" gridCols="10" canResize="true" canModify="true" showTitleBar="true" companyName="Demo" companyLogo="" companyStyle="">
  <widget name="lineChartSales" type="pivot" subtype="lineChartMarkers" subtypeClass="lineChart" title="Recent Sales by Product: Amounts" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="0" width="381" height="296" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="0" colSpanL="3" rowSpanL="4" showToolbar="true" theme="">
    <control name="" action="refresh" target="*" targetProperty="" location="widget" type="timer" controlClass="" timeout="5" label="Refresh" title="Refresh this chart" value="" text="" readOnly="false" valueList="" displayList="" activeWhen=""></control>
    <dataProperty name="" label="Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="XgridLines">0</property>
    <property name="YgridLines">0</property>
    <property name="chartToggle">none</property>
    <property name="labels">1</property>
    <property name="legendPos">none</property>
  </widget>
  <widget name="speedometerSales" type="meter" subtype="speedometer" subtypeClass="" title="Total Sales and Units Sold" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="296" left="0" width="382" height="240" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="4" homeColL="0" colSpanL="4" rowSpanL="3" showToolbar="true" theme="">
    <dataProperty name="" label="Total Sales" width="" align="" subtype="" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="TotalSales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <dataProperty name="" label="Total Units" width="" align="" subtype="" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="TotalUnits" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="format">#,#</property>
    <property name="highRangeColor">red</property>
    <property name="labelStyle"></property>
    <property name="lowRangeColor">red</property>
  </widget>
  <widget name="lightbarBacklog" type="meter" subtype="lightBar" subtypeClass="" title="Backlog" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="300" left="774" width="174" height="236" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="4" homeColL="4" colSpanL="2" rowSpanL="3" showToolbar="true" theme="">
    <dataProperty name="" label="" width="" align="" subtype="" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="Backlog" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
  </widget>
  <widget name="barChartSalesUnits" type="pivot" subtype="barChart" subtypeClass="barChart" title="Recent Sales and Units Sold" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="947" width="351" height="536" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="3" colSpanL="3" rowSpanL="4" showToolbar="true" theme="">
    <dataProperty name="" label="Sales" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <dataProperty name="" label="Units" width="" align="" subtype="" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="Units" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
  </widget>
  <widget name="pieChartSales" type="pivot" subtype="donutChart3D" subtypeClass="pieChart" title="Recent Sales" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="16" left="1350" width="421" height="337" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="5" homeColL="6" colSpanL="4" rowSpanL="5" showToolbar="true" theme="">
    <dataProperty name="" label="Recent Sales" width="" align="" subtype="" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="labels">1</property>
    <property name="legendPos">none</property>
  </widget>
  <widget name="pieChartSales" type="pivot" subtype="donutChart3D" subtypeClass="pieChart" title="Recent Sales by Product: Proportions" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" top="0" left="381" width="393" height="536" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="0" homeColL="6" colSpanL="4" rowSpanL="5" showToolbar="true" theme="">
    <dataProperty name="" label="" width="" align="" subtype="" style="" display="" format="" showAs="" valueColumn="false" summary="" summaryValue="" dataValue="Sales" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override=""></dataProperty>
    <property name="XgridLines">0</property>
    <property name="YgridLines">0</property>
    <property name="chartToggle">none</property>
    <property name="labelStyle"></property>
    <property name="labels">1</property>
    <property name="legendPos">none</property>
    <property name="showPercentage">1</property>
  </widget>
  <widget name="Widget7" type="meter" subtype="textMeter" subtypeClass="" title="News" dataSource="Demo.Dashboard.Production/SalesMetrics.metric" dataLink="" drillDownDataSource="" width="200" height="200" sidebarContent="" showSidebar="false" sidebarWidth="" maximized="false" homeRowL="7" homeColL="0" colSpanL="6" rowSpanL="3" showToolbar="true" theme="">
    <dataProperty name="" label="$auto" width="" align="" subtype="textMeter" style="" display="value" format="" showAs="value" valueColumn="false" summary="" summaryValue="" dataValue="News" targetValue="" thresholdLower="" thresholdUpper="" rangeLower="" rangeUpper="" baseValue="" override="{height:123,width:494,disabled:true,label:&apos;$auto&apos;,_type:&apos;textMeter&apos;}"></dataProperty>
  </widget>
</dashboard>

</items>
]]></Data>
</XData>
</Class>


<Class name="Demo.Dashboard.Production">
<Description>
This production defines the components needed to run the 
Dashboard demo</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56776</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.Dashboard.Production">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="SalesMetrics" ClassName="Demo.Dashboard.SalesMetrics" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Adapter" Name="CallInterval">2</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.Dashboard.SalesMetrics">
<Description>
This is a sample of a a Business Metric class;
It defines a set of Business Metric properties (aka Key Performance Indicators)
and provides the code to periodically calculate their values.
These metrics can then be displayed within an Ensemble Dashboard.</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessMetric</Super>
<TimeChanged>62230,47447.710478</TimeChanged>
<TimeCreated>60423,56776</TimeCreated>

<Property name="Sales">
<Description>
This reports recent sales (in dollars) for a given product</Description>
<Type>Ens.DataType.Metric</Type>
<MultiDimensional>1</MultiDimensional>
<Parameter name="AUTOHISTORY" value="10"/>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="100"/>
<Parameter name="UNITS" value="Dollars"/>
</Property>

<Property name="Units">
<Description>
This reports recent sales (in units sold) for a given product</Description>
<Type>Ens.DataType.Metric</Type>
<MultiDimensional>1</MultiDimensional>
<Parameter name="AUTOHISTORY" value="10"/>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="100"/>
<Parameter name="UNITS" value="Units"/>
</Property>

<Property name="Backlog">
<Description>
Recent backlog for current product</Description>
<Type>Ens.DataType.Metric</Type>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="10"/>
<Parameter name="UNITS" value="Days"/>
</Property>

<Property name="TotalSales">
<Description>
This reports total sales since start of the demo.</Description>
<Type>Ens.DataType.Metric</Type>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="10000"/>
<Parameter name="UNITS" value="Dollars"/>
</Property>

<Property name="TotalUnits">
<Description>
This reports total units sold since start of the demo.</Description>
<Type>Ens.DataType.Metric</Type>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="10000"/>
<Parameter name="UNITS" value="Units"/>
</Property>

<Property name="News">
<Description>
This reports some random news displayed in order to display it
within a tickertape feed.</Description>
<Type>Ens.DataType.Metric</Type>
</Property>

<Method name="OnCalculateMetrics">
<Description>
This method is called periodically, for each instance (product in this case)
in order to update the various metric values.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// randomly get number of sales since last time
	Set ..Sales = $Random(50) + $Random(50)
	Set ..Units = $Random(5) + $Random(5)

	Set ..TotalSales = ..TotalSales + ..Sales
	Set ..TotalUnits = ..TotalUnits + ..Units
	
	Set ..Backlog = $Random(10)

	// make up some news
	If ((..%Instance = "Apples") && ($Random(100) > 75)) {
		Set tList1 = $LB("Rates are","Futures are","Prices are","Demand is")
		Set tList2 = $LB("up","down","level")
		Set ..News = $LG(tList1,$Random($LL(tList1))+1) _ " " _ $LG(tList2,$Random($LL(tList2))+1) _ "."
	}

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetInstances">
<Description>
This method returns a list of instances for this Business Metric;
in this case, every instance represents a specific product</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pInstSet:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pInstSet(1) = "Apples"
	Set pInstSet(2) = "Bananas"
	Set pInstSet(3) = "Cherries"
	Set pInstSet(4) = "Dates"
	Set pInstSet(5) = "Eggplants"
	Set pInstSet(6) = "Figs"
	
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.FloodMonitor.BusinessOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59264,42937.094</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.FloodMonitor.WaterLevelRequest">
<Method>TestWaterLevel</Method>
</MapItem>

]]></Data>
</XData>

<Method name="TestWaterLevel">
<Description>
An operation that tests the current water level.</Description>
<FormalSpec>pRequest:Demo.FloodMonitor.WaterLevelRequest,*pResponse:Demo.FloodMonitor.WaterLevelResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("Registered water level of '"_pRequest.WaterLevel_"' at location '"_pRequest.Location_"'")
	Set tFlag=$e(pRequest.Location,4)
	If tFlag="R" {
		If pRequest.Location["Error" Quit $$$ERROR($$$GeneralError,"User triggered error")
		Set pResponse=##class(Demo.FloodMonitor.WaterLevelResponse).%New()
		Set pResponse.IsTooHigh=pRequest.WaterLevel>500
		$$$TRACE("Registration of water level finished.")
		Quit $$$OK
	} Else {
		Quit $$$EnsError($$$GeneralError,"User triggered error")
	}

]]></Implementation>
</Method>
</Class>


<Class name="Demo.FloodMonitor.BusinessService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59266,33364.999</TimeCreated>

<Method name="OnProcessInput">
<FormalSpec>pInput:Ens.StringContainer,*pOutput:Ens.StringContainer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		Set tInput=pInput.StringValue
		If tInput="?" Do ..Help() Quit
		Set tRequest=##class(Demo.FloodMonitor.WaterLevelRequest).%New()
		Set tRequest.Location=$p(tInput,":",1)
		Set tRequest.WaterLevel=$p(tInput,":",2)
		Set pResult=""
		Set tFlag=$e(tRequest.Location,1,2)
		If tFlag="CA" Set tSC=..SendRequestAsync("Demo.FloodMonitor.CustomBusinessProcess",tRequest) Quit
		If tFlag="GA" Set tSC=..SendRequestAsync("Demo.FloodMonitor.GeneratedBusinessProcess",tRequest) Quit
		If tFlag="CS" Set tSC=..SendRequestSync("Demo.FloodMonitor.CustomBusinessProcess",tRequest,.tResponse) Quit
		If tFlag="GS" Set tSC=..SendRequestSync("Demo.FloodMonitor.GeneratedBusinessProcess",tRequest,.tResponse) Quit
		Set tSC=$$$ERROR($$$GeneralError,"User triggered error")
	} while (0)
	If $$$ISOK(tSC) {
		If $IsObject($g(tResponse)) {
			Set pOutput=##class(Ens.StringContainer).%New("Return result is: "_tResponse.IsTooHigh)
		} Else {
			Set pOutput=##class(Ens.StringContainer).%New("")
		}
	}
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="Help">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Write !
	Write "Please enter the water level request at the prompt.",!
	Write "Enter the request in the format of location:waterlevel.",!
	Write !
	Write "The first 4 letters in the location name determine the path of execution",!
	Write "The possible values are: (GCE)(ASE)(RASE)(RE)",!
	Write "1st letter: G=GeneratedBusinessProcess, C=CustomBusinessProcess, E=Error",!
	Write "2nd letter: A=SendRequestAsync, S=SendRequestSync, E=Error",!
	Write "3rd letter: R=Reply, A=forwardAsynchronously, S=forwardSynchronously, E=Error",!
	Write "4th letter: R=reply, E=Error",!
	Write !
	Write "One example of ExecutionDirection is ""CSAR""",!
	Write !
	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Demo.FloodMonitor.CustomBusinessProcess">
<ClassType>persistent</ClassType>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcess</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59268,43369.154</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Method name="OnRequest">
<FormalSpec>request:Ens.Request,*response:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tFlag=$e(request.Location,3)
	If tFlag="R" {
		$$$TRACE("Registered water level of '"_request.WaterLevel_"' at location '"_request.Location_"'")
		$$$TRACE("Request handled locally")
		Set response=##class(Demo.FloodMonitor.WaterLevelResponse).%New()
		Set response.IsTooHigh=request.WaterLevel>500
		Quit $$$OK
	} Elseif tFlag="S" {
		;break
		$$$TRACE("Registered water level of '"_request.WaterLevel_"' at location '"_request.Location_"'")
		$$$TRACE("Request forwarded synchronously")
		Set tSC=..SendRequestSync("Demo.FloodMonitor.BusinessOperation",request,.response) If $$$ISERR(tSC) Quit tSC
		Quit $$$OK
	} Elseif tFlag="A" {
		$$$TRACE("Registered water level of '"_request.WaterLevel_"' at location '"_request.Location_"'")
		$$$TRACE("Request forwarded asynchronously")
		#; how can we do fire-and-forget call?
		Set tSC=..SendRequestAsync("Demo.FloodMonitor.BusinessOperation",request,1,"ABC") If $$$ISERR(tSC) Quit tSC
		Quit $$$OK
	} Else {
		Quit $$$EnsError($$$GeneralError,"User triggered error")
	}

]]></Implementation>
</Method>

<Method name="OnResponse">
<FormalSpec><![CDATA[request:Ens.Request,&response:Ens.Response,callrequest:Ens.Request,callresponse:Ens.Response,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("Asynchronous request returned")
	Set response=callresponse
	Quit $$$OK

]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.FloodMonitor.GeneratedBusinessProcess">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59268,43369.154</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<XData name="BPL">
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process request="Demo.FloodMonitor.WaterLevelRequest" response="Demo.FloodMonitor.WaterLevelResponse">
<sequence>
<call name="CallBusinessOperation1" target="Demo.FloodMonitor.BusinessOperation" async="1">
<request type="Demo.FloodMonitor.WaterLevelRequest">
<assign property="callrequest.Location" value="request.Location"/>
<assign property="callrequest.WaterLevel" value="request.WaterLevel"/>
</request>
<response type="Demo.FloodMonitor.WaterLevelResponse">
<assign property="response.IsTooHigh" value="callresponse.IsTooHigh"/>
</response>
</call>
<sync calls="CallBusinessOperation1"/>
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.FloodMonitor.Production">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59312,56897.326</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.FloodMonitor.Production">
  <ActorPoolSize>1</ActorPoolSize>
  <Item Name="Demo.FloodMonitor.BusinessService" ClassName="Demo.FloodMonitor.BusinessService" PoolSize="0" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
  <Item Name="Demo.FloodMonitor.CustomBusinessProcess" ClassName="Demo.FloodMonitor.CustomBusinessProcess" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
  <Item Name="Demo.FloodMonitor.GeneratedBusinessProcess" ClassName="Demo.FloodMonitor.GeneratedBusinessProcess" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
  <Item Name="Demo.FloodMonitor.BusinessOperation" ClassName="Demo.FloodMonitor.BusinessOperation" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
</Production>
]]></Data>
</XData>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..Start()
	;
	Set tSC=##class(Ens.Director).CreateBusinessService("Demo.FloodMonitor.BusinessService",.tBusinessService)
	If $$$ISERR(tSC) Do $system.OBJ.DisplayError(tSC) Quit
	For {
		Read !,"location:waterlevel>",tInput,! Quit:tInput=""
		If tInput="?" Do ##class(Demo.FloodMonitor.BusinessService).Help() Continue
		Set tSC=tBusinessService.ProcessInput(##class(Ens.StringContainer).%New(tInput),.tOutput)
		If 'tSC Do $system.Status.DisplayError(tSC) Continue
		Write !,tOutput.StringValue
	}
	Set tBusinessService = $$$NULLOREF
	;
	Do ..Stop()
	;
	Quit
]]></Implementation>
</Method>

<Method name="TestAll">
<ClassMethod>1</ClassMethod>
<FormalSpec>bsmode="Queue",bomode="Queue"</FormalSpec>
<Implementation><![CDATA[
	DO ..TestOneInvocation("InProc","InProc")
	DO ..TestOneInvocation("InProc","Queue" )
	DO ..TestOneInvocation("Queue", "InProc")
	DO ..TestOneInvocation("Queue", "Queue" )
	Quit
]]></Implementation>
</Method>

<Method name="TestOneInvocation">
<ClassMethod>1</ClassMethod>
<FormalSpec>bsmode,bomode</FormalSpec>
<Implementation><![CDATA[
	Do ..ChangeInvocation("Demo.FloodMonitor.CustomBusinessProcess",bsmode)
	Do ..ChangeInvocation("Demo.FloodMonitor.GeneratedBusinessProcess",bsmode)
	Do ..ChangeInvocation("Demo.FloodMonitor.BusinessOperation",bomode)
	;
	Do ..Start()
	;
	Set tSC=##class(Ens.Director).CreateBusinessService("Demo.FloodMonitor.BusinessService",.tBusinessService)
	If $$$ISERR(tSC) Do $system.OBJ.DisplayError(tSC) Quit
	For A="C","G" {
		For B="A","S","E" {
			For C="R","A","S","E" {
				For D="R","E" {
					Set tInput=A_B_C_D_":999"
					Write !,"INPUT=",tInput
					Set tSC=tBusinessService.ProcessInput(##class(Ens.StringContainer).%New(tInput),.tOutput)
					Write ",ISERR=",$$$ISERR(tSC)
					If $$$ISOK(tSC) Write ",OUTPUT=",tOutput.StringValue
				}
			}
		}
	}
	Set tBusinessService = $$$NULLOREF
	;
	Do ..Stop()
	;
	Quit
]]></Implementation>
</Method>

<Method name="ChangeInvocation">
<ClassMethod>1</ClassMethod>
<FormalSpec>classname,invocation</FormalSpec>
<Implementation><![CDATA[
	If ^oddDEF(classname,$$$cCLASSparameter,"INVOCATION",$$$cPARAMdefault)'=invocation {
		Set ^oddDEF(classname,$$$cCLASSparameter,"INVOCATION",$$$cPARAMdefault)=invocation
		Do $system.OBJ.Compile(classname,"k-u")
	}
	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Demo.FloodMonitor.WaterLevelRequest">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59302,33024.857</TimeCreated>

<Property name="Location">
<Type>%String</Type>
</Property>

<Property name="WaterLevel">
<Type>%Integer</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>WaterLevelRequestDefaultData</DefaultData>
<Data name="WaterLevelRequestDefaultData">
<Structure>listnode</Structure>
<Subscript>"WaterLevelRequest"</Subscript>
<Value name="1">
<Value>Location</Value>
</Value>
<Value name="2">
<Value>WaterLevel</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.FloodMonitor.WaterLevelResponse">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Response</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59276,47080.392</TimeCreated>

<Property name="IsTooHigh">
<Type>%Boolean</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>WaterLevelResponseDefaultData</DefaultData>
<Data name="WaterLevelResponseDefaultData">
<Structure>listnode</Structure>
<Subscript>"WaterLevelResponse"</Subscript>
<Value name="1">
<Value>IsTooHigh</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7.MsgRouter.ABCRoutingRule">
<Description>
</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>62979,52331.281074</TimeChanged>
<TimeCreated>62858,5105.321898</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.HL7.MsgRouter.RuleAssistCompatible</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.HL7.MsgRouter.RoutingEngine" production="">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<when condition="((HL7.ParentId)!=(&quot;&quot;))">
<send transform="" target="Batch_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="2.3.1"></constraint>
<when condition="((HL7.ParentId)!=(&quot;&quot;))">
<send transform="" target="Batch_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="2.3.1"></constraint>
<constraint name="docType" value="FHS,BHS"></constraint>
<when condition="1">
<send transform="" target="Batch_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ADT_A08"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ADT_A01"></constraint>
<when condition="1">
<send transform="" target="Priority_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ADT_A08"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ADT_A01"></constraint>
<when condition="1">
<send transform="" target="ADT_A08_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ORM_O01"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ORM_O01"></constraint>
<when condition="((HL7.{PIDgrp.PV1grp.PV1:PatientClass})=(&quot;E&quot;))">
<send transform="" target="Priority_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ORM_O01"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ORM_O01"></constraint>
<when condition="1">
<send transform="" target="ORM_O01_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ADT_A31"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ADT_A01"></constraint>
<when condition="1">
<send transform="" target="ADT_A31_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ORU_R01"></constraint>
<constraint name="docCategory" value="2.3.1"></constraint>
<constraint name="docType" value="ORU_R01"></constraint>
<when condition="1">
<send transform="" target="Extra_Observations"></send>
<return></return>
</when>
</rule>
<rule name="" disabled="false">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<when condition="1">
<send transform="" target="Regular_FileOperation"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7.MsgRouter.ADTLastNameTransform">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60213,48389</TimeCreated>
<DependsOn>EnsLib.HL7.Message</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>0</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.HL7.Message' targetClass='EnsLib.HL7.Message' sourceDocType='Demo.HL7.MsgRouter.Schema:ADT_A01' targetDocType='2.3.1:ADT_A01' create='new' language='objectscript' >
<assign value='source.{MSH}' property='target.{MSH}' action='set'  />
<assign value='"ADT"' property='target.{MSH:9.1}' action='set'  />
<assign value='"A01"' property='target.{MSH:9.2}' action='set'  />
<assign value='"TEST"' property='target.{MSH:ReceivingApplication}' action='set'  />
<assign value='source.{EVN}' property='target.{EVN}' action='set'  />
<assign value='source.{PID}' property='target.{PID}' action='set'  />
<assign value='"NEWNAME"' property='target.{PID:5.1}' action='set'  />
<assign value='source.{PD1}' property='target.{PD1}' action='set'  />
<assign value='source.{NK1(1)}' property='target.{NK1(1)}' action='set'  />
<assign value='source.{PV1}' property='target.{PV1}' action='set'  />
<assign value='source.{PV2}' property='target.{PV2}' action='set'  />
<assign value='source.{DB1(1)}' property='target.{DB1(1)}' action='set'  />
<assign value='source.{OBX(1)}' property='target.{OBX(1)}' action='set'  />
<assign value='source.{AL1(1)}' property='target.{AL1(1)}' action='set'  />
<assign value='source.{DG1(1)}' property='target.{DG1(1)}' action='set'  />
<assign value='source.{DRG}' property='target.{DRG}' action='set'  />
<assign value='source.{PR1grp(1)}' property='target.{PR1grp(1)}' action='set'  />
<assign value='source.{GT1(1)}' property='target.{GT1(1)}' action='set'  />
<assign value='source.{IN1grp(1)}' property='target.{IN1grp(1)}' action='set'  />
<assign value='source.{ACC}' property='target.{ACC}' action='set'  />
<assign value='source.{UB1}' property='target.{UB1}' action='set'  />
<assign value='source.{UB2}' property='target.{UB2}' action='set'  />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7.MsgRouter.AlertRule">
<Description>
See the AlertTable lookup table for a mapping of alert sources to email addresses. If no match is found in the lookup, EmailAlertTransformation sends the alert to the configured Recipient for the EMailAlertOperation.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>62858,5105.32698</TimeChanged>
<TimeCreated>62858,5105.314808</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.MsgRouter.RoutingEngine" production="">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="">
<constraint name="msgClass" value="Ens.AlertRequest"></constraint>
<when condition="1">
<send transform="Demo.HL7.MsgRouter.EmailAlertTransform" target="EMailAlertOperation"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7.MsgRouter.EmailAlertTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63260,3644.868482</TimeCreated>
<DependsOn>Ens.AlertRequest</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Ens.AlertRequest' targetClass='Ens.AlertRequest' create='new' language='objectscript' >
<assign value='source.SourceConfigName' property='target.SourceConfigName' action='set'  />
<assign value='source.AlertText' property='target.AlertText' action='set'  />
<assign value='..Lookup("AlertTable",source.SourceConfigName)' property='target.AlertDestination' action='set'  />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7.MsgRouter.Functions">
<Description>
Functions to use in rule definitions for the sample message router production.</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.FunctionSet</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60211,45594.129234</TimeCreated>

<Method name="DayOfWeek">
<Description>
Returns the ordinal position of the day in the week, 
where 1 is Sunday, 2 is Monday, and so on.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$zd($H,10)
]]></Implementation>
</Method>

<Method name="TimeInSeconds">
<Description>
Returns the time as a number of seconds since midnight.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$p($H,",",2)
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7.MsgRouter.ORMLastNameTransform">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60213,48814</TimeCreated>
<DependsOn>EnsLib.HL7.Message</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>0</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.HL7.Message' targetClass='EnsLib.HL7.Message' sourceDocType='Demo.HL7.MsgRouter.Schema:ORM_O01' targetDocType='2.3.1:ORM_O01' create='new' language='objectscript' >
<assign value='source.{MSH}' property='target.{MSH}' action='set'  />
<assign value='source.{NTE(1)}' property='target.{NTE(1)}' action='set'  />
<assign value='source.{ORCgrp(1)}' property='target.{ORCgrp(1)}' action='set'  />
<assign value='source.{PIDgrp.PID}' property='target.{PIDgrp.PID}' action='set'  />
<assign value='"NEWNAME"' property='target.{PIDgrp.PID:5.1}' action='set'  />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7.MsgRouter.Production">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60208,69187</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.HL7.MsgRouter.Production" TestingEnabled="false" LogGeneralTraceEvents="false">
  <Description>Routes HL7 messages based on message source and contents. To learn more, click on ABC_Router or XYZ_Router. Click View Rules to see message routing rules.

The production uses a routing process Ens.Alert to route alerts. The rule in Ens.Alert consults a lookup table to see where to send the alert.

To demonstrate alerts, give EMailAlertOperation a valid STMP server and Recipient. You may also edit the AlertTable lookup table. Temporarily assign a bad File Path to an enabled file service.</Description>
  <ActorPoolSize>1</ActorPoolSize>
  <Item Name="ABC_HL7FileService" Category="" ClassName="EnsLib.HL7.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="Test source of HL7 messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="AckTargetConfigNames"></Setting>
    <Setting Target="Host" Name="Framing">Flexible</Setting>
    <Setting Target="Host" Name="TargetConfigNames">ABC_Router</Setting>
    <Setting Target="Host" Name="SearchTableClass">Demo.HL7.MsgRouter.SearchTable</Setting>
    <Setting Target="Host" Name="LocalFacilityApplication"></Setting>
    <Setting Target="Host" Name="AckMode">Never</Setting>
    <Setting Target="Host" Name="UseAckCommitCodes">1</Setting>
    <Setting Target="Host" Name="IgnoreInboundAck">1</Setting>
    <Setting Target="Host" Name="BatchHandling">Batch</Setting>
    <Setting Target="Host" Name="MessageSchemaCategory">Demo.HL7.MsgRouter.Schema</Setting>
    <Setting Target="Host" Name="DefCharEncoding">Latin1</Setting>
    <Setting Target="Host" Name="AlertGracePeriod">0</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\in</Setting>
    <Setting Target="Adapter" Name="FileSpec">ABC*</Setting>
    <Setting Target="Adapter" Name="ArchivePath">C:\Practice\inarchive</Setting>
    <Setting Target="Adapter" Name="WorkPath"></Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="FileAccessTimeout">10</Setting>
    <Setting Target="Adapter" Name="AppendTimestamp">1</Setting>
    <Setting Target="Adapter" Name="CallInterval">5</Setting>
  </Item>
  <Item Name="XYZ_HL7FileService" Category="" ClassName="EnsLib.HL7.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="Test source of HL7 messages." LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="AckTargetConfigNames"></Setting>
    <Setting Target="Host" Name="Framing">Flexible</Setting>
    <Setting Target="Host" Name="TargetConfigNames">XYZ_Router</Setting>
    <Setting Target="Host" Name="SearchTableClass">Demo.HL7.MsgRouter.SearchTable</Setting>
    <Setting Target="Host" Name="LocalFacilityApplication"></Setting>
    <Setting Target="Host" Name="AckMode">Never</Setting>
    <Setting Target="Host" Name="UseAckCommitCodes">1</Setting>
    <Setting Target="Host" Name="IgnoreInboundAck">1</Setting>
    <Setting Target="Host" Name="BatchHandling">1Session</Setting>
    <Setting Target="Host" Name="MessageSchemaCategory">Demo.HL7.MsgRouter.Schema</Setting>
    <Setting Target="Host" Name="DefCharEncoding">Latin1</Setting>
    <Setting Target="Host" Name="AlertGracePeriod">0</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\in</Setting>
    <Setting Target="Adapter" Name="FileSpec">XYZ*</Setting>
    <Setting Target="Adapter" Name="ArchivePath">C:\Practice\inarchive</Setting>
    <Setting Target="Adapter" Name="WorkPath"></Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="FileAccessTimeout">10</Setting>
    <Setting Target="Adapter" Name="AppendTimestamp">1</Setting>
    <Setting Target="Adapter" Name="CallInterval">5</Setting>
  </Item>
  <Item Name="Ens.Alert" Category="" ClassName="EnsLib.MsgRouter.RoutingEngine" PoolSize="0" Enabled="true" Foreground="false" Comment="This handles Alert routing logic." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.HL7.MsgRouter.AlertRule</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
  </Item>
  <Item Name="ABC_Router" Category="" ClassName="EnsLib.HL7.MsgRouter.RoutingEngine" PoolSize="0" Enabled="true" Foreground="false" Comment="This handles message routing logic." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="AlertOnBadMessage">1</Setting>
    <Setting Target="Host" Name="BadMessageHandler">BadMessageHandler</Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.HL7.MsgRouter.ABCRoutingRule</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
  </Item>
  <Item Name="XYZ_Router" Category="" ClassName="EnsLib.HL7.MsgRouter.RoutingEngine" PoolSize="1" Enabled="true" Foreground="false" Comment="This handles message routing logic." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="LocalFacilityApplication">ISC:EnsembleHL7</Setting>
    <Setting Target="Host" Name="AckType">Application</Setting>
    <Setting Target="Host" Name="NackCode">Error</Setting>
    <Setting Target="Host" Name="Validation">dm-z</Setting>
    <Setting Target="Host" Name="AlertOnBadMessage">1</Setting>
    <Setting Target="Host" Name="BadMessageHandler">BadMessageHandler</Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.HL7.MsgRouter.XYZRoutingRule</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
  </Item>
  <Item Name="EMailAlertOperation" Category="" ClassName="EnsLib.EMail.AlertOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Alerts system administrators via e-mail." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="SMTPServer">smtp.mycompany.test</Setting>
    <Setting Target="Adapter" Name="SMTPPort">25</Setting>
    <Setting Target="Adapter" Name="Credentials"></Setting>
    <Setting Target="Adapter" Name="Recipient">ensemble@mycompany.test</Setting>
    <Setting Target="Adapter" Name="Cc"></Setting>
    <Setting Target="Adapter" Name="From">ensemble@mycompany.test</Setting>
  </Item>
  <Item Name="ADT_A08_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Destination for ADT_A08 messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_ADT_A08_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="ORM_O01_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Destination for ORM_O01 messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_ORM_O01_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="ADT_A31_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Destination for ADT_A31 messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_ADT_A31_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="Priority_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Priority destination for HL7 messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_Priority_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="Extra_Observations" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Destination for doctor notes/observations." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_Extra_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="Regular_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Default destination for HL7 messages." LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_Regular_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="Other_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Special destination for HL7 messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_Other_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="BadMessageHandler" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="Destination for bad messages." LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_Bad_%F.txt</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">AsciiLF</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="Batch_FileOperation" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="Filename">%H%M_Batch_%F.txt</Setting>
    <Setting Target="Host" Name="AutoBatchParentSegs">1</Setting>
    <Setting Target="Host" Name="Separators"><![CDATA[|^~\&]]]]><![CDATA[></Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="DefCharEncoding">Latin1</Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">-1</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="Framing">Ascii115/101</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">0</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7.MsgRouter.SearchTable">
<Description>
Defines a set of properties derived from Document objects of class 'EnsLib.HL7.Message'
that can be used in SQL to identify messages of interest.
Extends EnsLib.HL7.SearchTable; adds more searchable properties to the ones defined in that class.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.HL7.SearchTable</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59946,61139</TimeCreated>
<LegacyInstanceContext>1</LegacyInstanceContext>

<XData name="SearchSpec">
<XMLNamespace>http://www.intersystems.com/EnsSearchTable</XMLNamespace>
<Data><![CDATA[
<Items>
<!--
	Items that do not depend on DocType, indexing any HL7 message.
	The | character cannot be used in IDKEY indexes. So using a + in this example
	Any | in the data (i.e. not used as a possible HL7 separator) will be converted
	on filing to the Search Table as a +
	Original HL7 data remains unchanged.
-->
<Item DocType=""               PropName="SendingFacilApp"  >{1:4}_"+"_{1:3}</Item>
<Item DocType=""               PropName="RecvingFacilApp"  >{1:6}_"+"_{1:5 }</Item>
<Item DocType=""               PropName="MSHDateTime" PropType='DateTime:HL7' >{1:7}</Item>

<!-- Get fields from named segments found in any HL7 message -->
<Item DocType=""               PropName="InsuranceCo"      >[IN1:4()]</Item>

<!-- Get specific field from specific segment HL7 message assigned a specific DocType  -->
<Item DocType="Demo.HL7.MsgRouter.Schema:ORM_O01 "  PropName="ServiceId">{ORCgrp().OBRuniongrp.OBRunion.OBR:UniversalServiceID.text}</Item>
<Item DocType="2.3.1:ORU_R01 "                      PropName="ServiceId">{PIDgrpgrp().ORCgrp(1).OBR:UniversalServiceID.text}</Item>
</Items>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.HL7.MsgRouter.XYZRoutingRule">
<Description>
Routing from the XYZ message source.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>62858,5105.889956</TimeChanged>
<TimeCreated>62858,5105.884151</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.HL7.MsgRouter.RuleAssistCompatible</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.HL7.MsgRouter.RoutingEngine" production="">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<when condition="((HL7.ParentId)!=(&quot;&quot;))">
<send transform="" target="Batch_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="2.3.1"></constraint>
<constraint name="docType" value="FHS,BHS"></constraint>
<when condition="1">
<send transform="" target="Batch_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ADT_A08"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ADT_A01"></constraint>
<when condition="(Contains(HL7.{PID:PatientName(1).familylastname},&quot;&lt;S&gt;&quot;))||(StartsWith(HL7.{PID:PatientName(1).familylastname},&quot;Z&quot;))">
<send transform="Demo.HL7.MsgRouter.ADTLastNameTransform" target="Other_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docName" value="ORM_O01"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<constraint name="docType" value="ORM_O01"></constraint>
<when condition="(StartsWith(HL7.{PIDgrp.PID:PatientName(1).familylastname},&quot;S&quot;))||(StartsWith(HL7.{PIDgrp.PID:PatientName(1).familylastname},&quot;Z&quot;))">
<send transform="Demo.HL7.MsgRouter.ORMLastNameTransform" target="Other_FileOperation"></send>
<return></return>
</when>
</rule>
<rule name="">
<constraint name="msgClass" value="EnsLib.HL7.Message"></constraint>
<constraint name="docCategory" value="Demo.HL7.MsgRouter.Schema"></constraint>
<when condition="1">
<send transform="" target="Regular_FileOperation"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7v3.Message">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60278,62850.084093</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Content">
<Type>%GlobalCharacterStream</Type>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="DocType">
<Type>%String</Type>
</Property>

<Property name="Source">
<Type>%String</Type>
<Parameter name="MAXLEN" value="250"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.HL7v3.MessageD</DataLocation>
<DefaultData>MessageDefaultData</DefaultData>
<IdLocation>^Demo.HL7v3.MessageD</IdLocation>
<IndexLocation>^Demo.HL7v3.MessageI</IndexLocation>
<StreamLocation>^Demo.HL7v3.MessageS</StreamLocation>
<Data name="MessageDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Content</Value>
</Value>
<Value name="3">
<Value>DocType</Value>
</Value>
<Value name="4">
<Value>Name</Value>
</Value>
<Value name="5">
<Value>Source</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.MsgRouter.RoutingEngine">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.MsgRouter.VDocRoutingEngine</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,34681.193</TimeCreated>

<Property name="HL7">
<Description>
we need this property For EvaluateRules to get access to the HL7 message</Description>
<Type>Demo.HL7v3.Message</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="HL7Get">
<CodeMode>expression</CodeMode>
<ReturnType>Demo.HL7v3.Message</ReturnType>
<Implementation><![CDATA[..Document
]]></Implementation>
</Method>

<Method name="OnValidate">
<Description>
Override this method to implement your own method for validating a Document</Description>
<FormalSpec>pMsg:Demo.HL7v3.Message,pValSpec:%String,*pStatus:%Status=$$$OK</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0
]]></Implementation>
</Method>

<Method name="OnRequest">
<FormalSpec>request:Demo.HL7v3.Message,*response:%Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..DocType = request.DocType
	Set ..DocName = request.Name
	Set tSC = ##super(request,.response)
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>RoutingEngineDefaultData1</DefaultData>
<Data name="RoutingEngineDefaultData1">
<Structure>listnode</Structure>
<Subscript>"RoutingEngine1"</Subscript>
<Value name="1">
<Value>AlertOnBadMessage</Value>
</Value>
<Value name="2">
<Value>BadMessageHandler</Value>
</Value>
<Value name="3">
<Value>Validation</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.MsgRouter.RuleAssist">
<Abstract>1</Abstract>
<Super>EnsLib.MsgRouter.RuleAssist</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62098,34463.90049</TimeCreated>

<Method name="GetDescription">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit "HL7v3 Demo Message Routing Rule"
]]></Implementation>
</Method>

<Method name="GetContextClass">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit "Demo.HL7v3.MsgRouter.RoutingEngine"
]]></Implementation>
</Method>

<Method name="IsHidden">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.Operation.FileOut">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60277,39171.945377</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.File.OutboundAdapter</Default>
</Parameter>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Parameter name="SETTINGS">
<Default>Filename</Default>
</Parameter>

<Property name="Filename">
<Type>%String</Type>
</Property>

<Method name="WriteToFile">
<FormalSpec>pRequest:Demo.HL7v3.Message,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do pRequest.Content.Rewind()
	Set tFilename=..Adapter.CreateFilename(##class(%File).GetFilename($Piece(pRequest.Source, $Char(13))), ..Filename)

	Set $ZTrap = "WriteToFileET"
	Set tStatus = ..Adapter.PutStream(tFilename, pRequest.Content)

	Quit $$$OK

WriteToFileET
	Set $ZTrap = ""

	Quit $$$ERROR($$$GeneralError, "An error has occurred in WriteToFile(" _ tFilename _ "):  " _ $ZError)
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Demo.HL7v3.Message"> 
		<Method>WriteToFile</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7v3.Operation.SOAPOut">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60277,39171.972481</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.SOAP.OutboundAdapter</Default>
</Parameter>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Method name="SendMessage">
<FormalSpec>pRequest:Demo.HL7v3.Message,*pResponse:Demo.HL7v3.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "SendMessageET"

	Set tStatus = ..Adapter.InvokeMethod("GetResponse", .tResponse, pRequest.Content)
	Do tResponse.Rewind()

	Set pResponse = ##class(Demo.HL7v3.Message).%New()
	Set pResponse.Content = tResponse

	Quit $$$OK
	
SendMessageET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError, "An error has occurred in SendMessage():  " _ $ZError)
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Demo.HL7v3.Message"> 
		<Method>SendMessage</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7v3.Production.InterfaceEngine">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60277,39171.994494</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.HL7v3.Production.InterfaceEngine" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Demo.HL7v3.Service.SOAPIn" Category="" ClassName="Demo.HL7v3.Service.SOAPIn" PoolSize="0" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="AlertGracePeriod">0</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
  </Item>
  <Item Name="HL7v3 SOAP Out" Category="" ClassName="Demo.HL7v3.Operation.SOAPOut" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="WebServiceURL"><![CDATA[<default>]]]]><![CDATA[></Setting>
    <Setting Target="Adapter" Name="WebServiceClientClass">Demo.HL7v3.SOAP.Outbound</Setting>
    <Setting Target="Adapter" Name="Credentials">None</Setting>
    <Setting Target="Adapter" Name="ProxyServer"></Setting>
    <Setting Target="Adapter" Name="ProxyPort">80</Setting>
    <Setting Target="Adapter" Name="ProxyHTTPS">0</Setting>
  </Item>
  <Item Name="Route and Transform Message" Category="" ClassName="Demo.HL7v3.MsgRouter.RoutingEngine" PoolSize="0" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="AlertOnBadMessage">0</Setting>
    <Setting Target="Host" Name="BadMessageHandler"></Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.HL7v3.Rule.RouteAndTransform</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
  </Item>
  <Item Name="Ens.Alert" Category="" ClassName="EnsLib.EMail.AlertOperation" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="HL7v3 File Out MFMT" Category="" ClassName="Demo.HL7v3.Operation.FileOut" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Filename">HL7v3_Output_MFMT_%Q.xml</Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\EnsembleSys\dev\hl7v3\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">1</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="HL7v3 File In" Category="" ClassName="Demo.HL7v3.Service.FileIn" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="AlertGracePeriod">0</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\EnsembleSys\dev\hl7v3\in</Setting>
    <Setting Target="Adapter" Name="FileSpec">*.xml</Setting>
    <Setting Target="Adapter" Name="ArchivePath"></Setting>
    <Setting Target="Adapter" Name="WorkPath"></Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="FileAccessTimeout">10</Setting>
    <Setting Target="Adapter" Name="AppendTimestamp">0</Setting>
    <Setting Target="Adapter" Name="CallInterval">5</Setting>
  </Item>
  <Item Name="HL7v3 File Out QUPA" Category="" ClassName="Demo.HL7v3.Operation.FileOut" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Filename">HL7v3_Output_QUPA_%Q.xml</Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\EnsembleSys\dev\hl7v3\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">1</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7v3.Rule.RouteAndTransform">
<Description>
Test rule for HL7 version 3 productions</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>62858,5110.273177</TimeChanged>
<TimeCreated>62858,5110.266561</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.VDocRuleAssistCompatible</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="Demo.HL7v3.Rule.Context" production="">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="">
<constraint name="msgClass" value="Demo.HL7v3.Message"></constraint>
<constraint name="docName" value="MFMT_IN002101"></constraint>
<when condition="1">
<send transform="Demo.HL7v3.Transformation.MFMTIN002101" target="HL7v3 SOAP Out"></send>
<send transform="Demo.HL7v3.Transformation.MFMTIN002101" target="HL7v3 File Out MFMT"></send>
<return></return>
</when>
</rule>
<rule name="">
<constraint name="msgClass" value="Demo.HL7v3.Message"></constraint>
<constraint name="docName" value="QUPA_IN101103"></constraint>
<when condition="1">
<send transform="Demo.HL7v3.Transformation.QUPAIN101103" target="HL7v3 SOAP Out"></send>
<send transform="Demo.HL7v3.Transformation.QUPAIN101103" target="HL7v3 File Out QUPA"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7v3.SOAP.Outbound">
<Super>%SOAP.WebClient</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60453,75860</TimeCreated>

<Parameter name="LOCATION">
<Description>
This is the URL used to access the web service.</Description>
<Default>http://localhost/csp/ensdemo/Demo.HL7v3.TestHarness.SOAPService.cls</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
This is the namespace used by the Service</Description>
<Default>http://tempuri.org</Default>
</Parameter>

<Parameter name="OUTPUTTYPEATTRIBUTE">
<Description>
Use xsi:type attribute for literal types.</Description>
<Default>1</Default>
</Parameter>

<Parameter name="SERVICENAME">
<Description>
This is the name of the Service</Description>
<Default>HL7v3SOAPOut</Default>
</Parameter>

<Method name="GetResponse">
<Final>1</Final>
<FormalSpec>pInput:%GlobalCharacterStream</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%GlobalCharacterStream</ReturnType>
<WebMethod>1</WebMethod>
<SoapBindingStyle>document</SoapBindingStyle>
<SoapBodyUse>literal</SoapBodyUse>
<Implementation><![CDATA[ Quit ..WebMethod("GetResponse").Invoke($this,"http://tempuri.org/Demo.HL7v3.TestHarness.SOAPService.GetResponse",.pInput)
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.Service.FileIn">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60277,39172.047657</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.File.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pInput:%FileCharacterStream,pOutput:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "OnProcessInputET"
	
	Set tStatus = ##class(%XML.XPATH.Document).CreateFromStream(pInput, .tDocument)
	Set tStatus = tDocument.EvaluateExpression("/*", "name()", .tResults)
	Set tStatus = pInput.Rewind()
	
	If (tResults.Count() > 0) Set tRoot = tResults.GetAt(1).Value
	Else  Set tRoot = "<errorNoRootElement>"
	
	Set tRequest = ##class(Demo.HL7v3.Message).%New()
	Set tRequest.Name		= tRoot
	Set tRequest.DocType	= ""
	Set tRequest.Source     = pInput.Attributes("Filename")
	Do tRequest.Content.CopyFrom(pInput)
	
	Set tStatus = ..SendRequestSync("Route and Transform Message", tRequest, .tResponse)
	
	Quit $$$OK
	
OnProcessInputET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError, "An error has occurred in OnProcessInput():  " _ $ZError)
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.Service.SOAPIn">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.SOAP.Service</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60277,39172.063808</TimeCreated>

<Parameter name="ADAPTER">
</Parameter>

<Parameter name="SERVICENAME">
<Description>
Name of the WebService.</Description>
<Default>HL7v3SOAPIn</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
TODO: change this to actual SOAP namespace.
SOAP Namespace for the WebService</Description>
<Default>http://tempuri.org</Default>
</Parameter>

<Method name="SendMessage">
<Description>
TODO: add arguments and implementation.
SendMessage</Description>
<FormalSpec>pInput:%GlobalCharacterStream</FormalSpec>
<ReturnType>%GlobalCharacterStream</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set $ZTrap = "SendMessageET"

	Set tStatus	= ..ProcessInput(pInput, .pOutput)

	Quit pOutput

SendMessageET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError, "An error has occurred in SendMessage():  " _ $ZError)
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<FormalSpec><![CDATA[pInput:%GlobalCharacterStream,&pOutput:%GlobalCharacterStream]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "OnProcessInputET"
	
	Set tStatus = ##class(%XML.XPATH.Document).CreateFromStream(pInput, .tDocument)
	Set tStatus = tDocument.EvaluateExpression("/*", "name()", .tResults)
	Set tStatus = pInput.Rewind()

	If (tResults.Count() > 0) Set tRoot = tResults.GetAt(1).Value
	Else  Set tRoot = "<errorNoRootElement>"
	
	Set tRequest = ##class(Demo.HL7v3.Message).%New()
	Set tRequest.Name		= tRoot
	Set tRequest.DocType	= ""
	Set tRequest.Source  	= ..#SERVICENAME
	Set tRequest.Content	= pInput
	
	Set tStatus = ..SendRequestSync("Route and Transform Message", tRequest, .tResponse)
	Set pOutput = tResponse.Content

	Quit $$$OK
	
OnProcessInputET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError, "An error has occurred in OnProcessInput():  " _ $ZError)
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.TestHarness.HL7v3SOAPInProxy">
<Super>%SOAP.WebClient</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60453,75653</TimeCreated>

<Parameter name="LOCATION">
<Description>
This is the URL used to access the web service.</Description>
<Default>http://localhost/csp/ensdemo/Demo.HL7v3.Service.SOAPIn.cls</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
This is the namespace used by the Service</Description>
<Default>http://tempuri.org</Default>
</Parameter>

<Parameter name="OUTPUTTYPEATTRIBUTE">
<Description>
Use xsi:type attribute for literal types.</Description>
<Default>0</Default>
</Parameter>

<Parameter name="SERVICENAME">
<Description>
This is the name of the Service</Description>
<Default>HL7v3SOAPIn</Default>
</Parameter>

<Method name="SendMessage">
<Final>1</Final>
<FormalSpec>pInput:%GlobalCharacterStream</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%GlobalCharacterStream</ReturnType>
<WebMethod>1</WebMethod>
<SoapBindingStyle>document</SoapBindingStyle>
<SoapBodyUse>literal</SoapBodyUse>
<Implementation><![CDATA[ Quit ..WebMethod("SendMessage").Invoke($this,"http://tempuri.org/Demo.HL7v3.Service.SOAPIn.SendMessage",.pInput)
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.TestHarness.MessageGenerator">
<ClassType/>
<IncludeCode>%occInclude</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.691347</TimeCreated>

<Method name="AddLog">
<ClassMethod>1</ClassMethod>
<FormalSpec>Text:%String="Default"</FormalSpec>
<Implementation><![CDATA[
 Set i = $Increment(^CacheTempVerwHL7($job))
 set ^CacheTempVerwHL7($job,i)=Text
]]></Implementation>
</Method>

<Method name="ProcessFile">
<Description><![CDATA[
2 parameters FileIn en FileOut <br>
Calls ProcessStream <br>
Used for test.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>FileInput:%String,FileOutput:%String,params:%List=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 q:(FileInput="")||(FileOutput="") $$$ERROR($$$GeneralError,"Input and/or output file name empty!")
 k ^CacheTempVerwHL7($job)
 If ('##class(%File).Exists(FileInput)) {
	 s tekst="File "_FileInput_" does not exist"
	 d ..AddLog(tekst)
	 quit $$$ERROR($$$GeneralError,tekst)
 }
 Set fstream=##class(%FileCharacterStream).%New()
 set fstream.Filename=FileInput
 s status=..ProcessStream(.fstream, params)
 if (status) {
	 d fstream.Rewind()
     s dev=FileOutput
	 o dev:("wns")
	 u dev
	 d fstream.OutputToDevice()
     close dev
     use 0
     s fstream=""
  	 } 
 s fstream=""
 quit $$$OK
]]></Implementation>
</Method>

<Method name="ProcessStream">
<Description>
Main entry point -- passes a stream by reference and returns it modified
(that is, parameters identified by #( )# delimiters will be replaced
by the result of the code they contain, usually a random generator, for
instance, one of the methods of %PopulateUtils)
TODO: pass parameters to this method</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&stream:%Stream.Object,params:%List=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  d stream.Rewind()
  s resultStream=stream.%ConstructClone(1,.cloner)
  d resultStream.Rewind()
  s sw=0,verwerk=0,tussen="",len=15000
  while (len=15000)
  {
  	s buffer=stream.Read(.len), out=""
  	for i=1:1:len {
	  s char=$e(buffer,i)
	  // start parsing here
	  // 
	  if (char=")") {
		  if (sw=1) && (verwerk=1) {
			  s verwerk=-1
			  continue
		  }
		  if (sw=1) && (verwerk=-1) {
			  s tussen=tussen_char
	          continue
		  }
	  }
	  if (verwerk=1) {
		  // build command
		  s tussen=tussen_char
	      continue
	  }
	  if (char="#") {
		 if (verwerk=-1) {
			  s verwerk=0
			  s sw=0,result=""
			  s ontvang=..ProcessParameter(tussen,.result,params)
			  s out=out_result
			  s tussen=""
			  continue
		  }
		  if (sw=0) {
			  s sw=1
			  continue
		  }
	  }
	  if (char="(") {
		  if (sw=1) && (verwerk=0) {
			  s verwerk=1
			  continue
		  }
	  }
	  if (sw=0) { s out=out_char}
    }
    d resultStream.Write(out)
  }
 s stat=stream.Rewind() q:stat'=$$$OK stat
 q stream.CopyFrom(resultStream)
]]></Implementation>
</Method>

<Method name="ProcessParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Source:%String,&Target:%String,params:%List=""]]></FormalSpec>
<PublicList>temp</PublicList>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	i ($e(Source,1,5)="param")
	{
		s index=+$e(Source,7,$l(Source)-1)
		s Target=$lg(params,index,"")
		q 1
	}
 if ($e(Source,1,1)="#") || ($e(Source,1,1)="$") {
 // execute method with xecute
   Set $ZTRAP="Trapexecute"
   s uitvoer="s temp="_Source
   XECUTE uitvoer
   // copy result of xecute into Target
   s Target=temp
   quit 1
Trapexecute ;
 s Target=""
 Set $ZTRAP=""
 d ..AddLog($ZE_"#("_Source_")#")
 quit 0
 }
 else {
 // execute method of %Library.PopulateUtils
 Set $ZTRAP="Trapmethod"
 s Target=$zobjclassmethod("%Library.PopulateUtils",Source)
 s $ZTRAP=""
 quit 1
Trapmethod ;
 s Target=""
 Set $ZTRAP=""
 d ..AddLog($ZE_"#("_Source_")#")
 quit 0
 } // end else
]]></Implementation>
</Method>

<Method name="ShowLog">
<Description><![CDATA[
Show the error log generated in the last execution of ProcessStream <br>
This is stored in global <b>^CacheTempVerwHL7</b>. ]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 s x=""
 for  {
	 s x=$o(^CacheTempVerwHL7($job,x))
	 q:x=""
	 w !,^CacheTempVerwHL7($job,x)
 }
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	s msg=##class(%Dictionary.CompiledXData).%OpenId("Demo.HL7v3.TestHarness.MessageTemplates||QUPAIN101103").Data
	s params=$lb("foobarbaz")
	d ..ProcessStream(.msg, params)
	d msg.OutputToDevice()
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.TestHarness.MessageQueue">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.702592</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Request">
<Type>%GlobalCharacterStream</Type>
</Property>

<Property name="Response">
<Type>%GlobalCharacterStream</Type>
</Property>

<Property name="RequestName">
<Type>%String</Type>
</Property>

<Property name="DateTimeReceived">
<Type>%TimeStamp</Type>
<InitialExpression>$ZDateTime($Horolog, 3)</InitialExpression>
</Property>

<Property name="Status">
<Type>%String</Type>
<InitialExpression>"queued"</InitialExpression>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.HL7v3.Tes7C9.MessageQueueD</DataLocation>
<DefaultData>MessageQueueDefaultData</DefaultData>
<IdLocation>^Demo.HL7v3.Tes7C9.MessageQueueD</IdLocation>
<IndexLocation>^Demo.HL7v3.Tes7C9.MessageQueueI</IndexLocation>
<StreamLocation>^Demo.HL7v3.Tes7C9.MessageQueueS</StreamLocation>
<Data name="MessageQueueDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DateTimeReceived</Value>
</Value>
<Value name="3">
<Value>Request</Value>
</Value>
<Value name="4">
<Value>RequestName</Value>
</Value>
<Value name="5">
<Value>Response</Value>
</Value>
<Value name="6">
<Value>Status</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.TestHarness.MessageTemplate">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%Populate,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.718873</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="RequestMaps">
<Type>Demo.HL7v3.TestHarness.RequestMap</Type>
<Cardinality>many</Cardinality>
<Inverse>Request</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ResponseMaps">
<Type>Demo.HL7v3.TestHarness.ResponseMap</Type>
<Cardinality>many</Cardinality>
<Inverse>Response</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Message">
<Type>%GlobalCharacterStream</Type>
</Property>

<Index name="NameIndex">
<Properties>Name</Properties>
<Unique>1</Unique>
</Index>

<Index name="TypeIndex">
<Properties>Type</Properties>
</Index>

<XData name="MFMTIN002101">
<Data><![CDATA[
<MFMT_IN002101>
<!-- Transport Wrapper 
  --> 
  <id extension="9223372036854775800" root="2.16.528.1.1007.3.2.700222.1" /> 
  <creationTime value="2006-01-01 12:00:00PM" /> 
  <versionCode code="12345" /> 
  <interactionId extension="MFMT_IN002101" root="2.16.840.1.113883.1.6" /> 
  <processingCode code="ER" /> 
  <processingModeCode code="T" /> 
  <acceptAckCode code="ER" /> 
<receiver>
<device>
<!-- receiving application, ID of receiving system 
  --> 
  <id extension="000700856" root="2.16.528.1.1007.3.2" /> 
<name use="L">
  <given>Heathcare System XYZ</given> 
  </name>
<agencyFor classCode="AGNT">
<representedOrganization classCode="ORG" determinerCode="INSTANCE">
  <id extension="00100100" root="2.16.528.1.1007.3.3" /> 
<name use="L">
  <given>Organization XYZ</given> 
  </name>
  </representedOrganization>
  </agencyFor>
  </device>
  </receiver>
<sender>
  <telecom use="WP" value="tel:+31307236354" /> 
<device>
<!-- sending application, ID of sending system 
  --> 
  <id extension="000700222" root="2.16.528.1.1007.3.2" /> 
<name use="L">
  <given>ABC-HIS Goodhope Hospital</given> 
  </name>
<agencyFor classCode="AGNT">
<representedOrganization classCode="ORG" determinerCode="INSTANCE">
  <id extension="00600862" root="2.16.528.1.1007.3.3" /> 
<name use="L">
  <given>Goodhope Hospital</given> 
  </name>
  </representedOrganization>
  </agencyFor>
  </device>
  </sender>
<!-- Control Act Wrapper 
  --> 
<ControlActProcess moodCode="EVN">
  <effectiveTime value="20040417" /> 
<authorOrPerformer typeCode="AUT">
<participant>
<AssignedPerson>
  <id extension="000120450" root="2.16.528.1.1007.3.1" /> 
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </AssignedPerson>
  </participant>
  </authorOrPerformer>
<overseer typeCode="RESP">
<AssignedPerson>
  <id extension="000120450" root="2.16.528.1.1007.3.1" /> 
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </AssignedPerson>
  </overseer>
<subject>
<!-- payload 
  --> 
<registrationProcess classCode="REG" moodCode="RQO">
  <code code="722933" codeSystem="2.16.840.1.113883.2.4.15.4" codeSystemName="ActRegistryCodeNL" displayName="Voorschrift" /> 
  <statusCode code="active" codeSystem="2.16.840.1.113883.5.14" /> 
<effectiveTime>
  <low value="20040417" /> 
  </effectiveTime>
<subject2 typeCode="SUBJ">
<ActReference classCode="SBADM" moodCode="RQO">
  <id extension="9223372036854775800" root="2.16.528.1.1007.3.2.400416.16" /> 
  <statusCode code="active" /> 
<recordTarget>
<patient>
  <id extension="000197245" root="2.16.840.1.113883.2.4.6.3" /> 
  <statusCode code="" /> 
<Person>
<name use="L">
 <given>Tom</given>
 <prefix qualifier="VV">de </prefix>
 <family>Santis</family>
  </name>
  </Person>
<Organization>
  <id extension="00123456" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </patient>
  </recordTarget>
<authorOrPerformer typeCode="AUT">
  <time value="20040417151000" /> 
<assignedEntity>
  <id extension="0000120450" root="2.16.528.1.1007.3.1" /> 
<assignedPerson>
  <name /> 
<LocatedEntity>
  <Place /> 
  </LocatedEntity>
  </assignedPerson>
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </assignedEntity>
  </authorOrPerformer>
<overseer typeCode="RESP">
<assignedEntity>
  <id extension="000120450" root="2.16.528.1.1007.3.1" /> 
  <code code="01.015" codeSystem="2.16.840.1.113883.2.4.15.111" codeSystemName="RoleCode" displayName="GP" /> 
<assignedPerson>
  <name /> 
<LocatedEntity>
  <Place /> 
  </LocatedEntity>
  </assignedPerson>
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </assignedEntity>
  </overseer>
  </ActReference>
  </subject2>
  </registrationProcess>
  </subject>
  </ControlActProcess>
  </MFMT_IN002101>
]]></Data>
</XData>

<XData name="QUPAIN101103">
<Data><![CDATA[
<QUPA_IN101103>
	<id extension="1001" root="2.16.528.1.1007.3.2.2.233"/>
	<creationTime value="20040719140000"/>
	<versionCode code="12345"/>
	<interactionId extension="QUPA_IN101103" root="2.16.840.1.113883"/>
	<processingCode code="P"/>
	<processingModeCode code="T"/>
	<acceptAckCode code="ER"/>
	<receiver>
		<telecom use="WP" value="tel:+34372324874"/>
		<device>
			<id extension="000900478" root="2.16.528.1.1007.3.2"/>
			<name use="L">
				<given> </given>
			</name>
		</device>
	</receiver>
	<sender>
		<telecom use="WP" value="tel:+34307236354"/>
		<device>
			<!-- sending application, ID of sending system -->
			<id extension="1" root="2.16.528.1.1007.3.2"/>
			<name use="L">
				<given> </given>
			</name>
		</device>
	</sender>
	<ControlActProcess moodCode="EVN">
		<effectiveTime value="20040719135956"/>
		<authorOrPerformer typeCode="AUT">
			<participant>
				<AssignedPerson>
					<id extension="000120450" root="2.16.528.1.1007.3.1"/>
					<Organization>
						<id extension="00304845" root="2.16.528.1.1007.3.2"/>
					</Organization>
				</AssignedPerson>
			</participant>
		</authorOrPerformer>
		<reasonOf>
			<justifiedDetectedIssue>
				<code code="QNAT" codeSystem="2.16.840.1.113883.2.4.5.4" codeSystemName="ActCode"/>
				<targetOf>
					<source moodCode="DEF">
						<code code="EMAUTH" codeSystem="2.16.840.1.113883.2.4.5.4" codeSystemName="ActCode"/>
					</source>
				</targetOf>
			</justifiedDetectedIssue>
		</reasonOf>
		<queryByParameter>
			<queryId extension="5523264" root="2.16.528.1.1007.3.2.400893.15"/>
			<statusCode code="new"/>
			<person.addr>
				<value>
					<postalCode>5735 EP</postalCode>
				</value>
				<semanticsText>Person.addr</semanticsText>
			</person.addr>
			<person.birthTime>
				<value>
					<center value="19750103"/>
				</value>
				<semanticsText>Person.birthTime</semanticsText>
			</person.birthTime>
		</queryByParameter>
	</ControlActProcess>
</QUPA_IN101103>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.HL7v37C9.MessageTempl601D</DataLocation>
<DefaultData>MessageTemplateDefaultData</DefaultData>
<IdLocation>^Demo.HL7v37C9.MessageTempl601D</IdLocation>
<IndexLocation>^Demo.HL7v37C9.MessageTempl601I</IndexLocation>
<StreamLocation>^Demo.HL7v37C9.MessageTempl601S</StreamLocation>
<Data name="MessageTemplateDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Message</Value>
</Value>
<Value name="3">
<Value>Name</Value>
</Value>
<Value name="4">
<Value>Type</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.TestHarness.RequestMap">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.731327</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Request">
<Type>Demo.HL7v3.TestHarness.MessageTemplate</Type>
<Cardinality>one</Cardinality>
<Inverse>RequestMaps</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ClassName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="MethodName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Index name="RequestIndex">
<Properties>Request</Properties>
<Unique>1</Unique>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.HL7v3.TestH7C9.RequestMapD</DataLocation>
<DefaultData>RequestMapDefaultData</DefaultData>
<IdLocation>^Demo.HL7v3.TestH7C9.RequestMapD</IdLocation>
<IndexLocation>^Demo.HL7v3.TestH7C9.RequestMapI</IndexLocation>
<StreamLocation>^Demo.HL7v3.TestH7C9.RequestMapS</StreamLocation>
<Data name="RequestMapDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClassName</Value>
</Value>
<Value name="3">
<Value>MethodName</Value>
</Value>
<Value name="4">
<Value>Request</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.TestHarness.ResponseMap">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.741816</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Response">
<Type>Demo.HL7v3.TestHarness.MessageTemplate</Type>
<Cardinality>one</Cardinality>
<Inverse>ResponseMaps</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="XPathContext">
<Type>%String</Type>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Property name="XPathExpression">
<Type>%String</Type>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Property name="XPathValue">
<Type>%String</Type>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Index name="ResponseIndex">
<Properties>Response</Properties>
</Index>

<Index name="ResponseMapUniqueKey">
<Properties>XPathContext,XPathExpression,XPathValue</Properties>
<Unique>1</Unique>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.HL7v3.Test7C9.ResponseMapD</DataLocation>
<DefaultData>ResponseMapDefaultData</DefaultData>
<IdLocation>^Demo.HL7v3.Test7C9.ResponseMapD</IdLocation>
<IndexLocation>^Demo.HL7v3.Test7C9.ResponseMapI</IndexLocation>
<StreamLocation>^Demo.HL7v3.Test7C9.ResponseMapS</StreamLocation>
<Data name="ResponseMapDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Response</Value>
</Value>
<Value name="3">
<Value>XPathContext</Value>
</Value>
<Value name="4">
<Value>XPathExpression</Value>
</Value>
<Value name="5">
<Value>XPathValue</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.TestHarness.ResponseMode">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.751517</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Mode">
<Type>%String</Type>
<Parameter name="VALUELIST" value=",automated,interactive"/>
</Property>

<Property name="Active">
<Type>%Boolean</Type>
</Property>

<Index name="ResponseModeIDKey">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>Mode</Properties>
<Unique>1</Unique>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.HL7v3.Tes7C9.ResponseModeD</DataLocation>
<DefaultData>ResponseModeDefaultData</DefaultData>
<IdLocation>^Demo.HL7v3.Tes7C9.ResponseModeD</IdLocation>
<IndexLocation>^Demo.HL7v3.Tes7C9.ResponseModeI</IndexLocation>
<StreamLocation>^Demo.HL7v3.Tes7C9.ResponseModeS</StreamLocation>
<Data name="ResponseModeDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Active</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.HL7v3.TestHarness.SOAPService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SOAP.WebService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60262,37858.763275</TimeCreated>

<Parameter name="SERVICENAME">
<Description>
Name of the WebService.</Description>
<Default>HL7v3ResponseService</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
TODO: change this to actual SOAP namespace.
SOAP Namespace for the WebService</Description>
<Default>http://tempuri.org</Default>
</Parameter>

<Method name="GetResponse">
<FormalSpec>pInput:%GlobalCharacterStream</FormalSpec>
<ReturnType>%GlobalCharacterStream</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set $ZTrap = "GetResponseET"

	&sql(
		Select	ID Into :tResponseModeID
		From	Demo_HL7v3_TestHarness.ResponseMode
		Where	Active = 1
	)
	Set tResponseModeID	= $Case(SQLCODE, 0:tResponseModeID, :"automated")
	Set tResponse		= $Case(tResponseModeID, "automated":..GetAutomatedResponse(pInput), "interactive":..GetInteractiveResponse(pInput), :"<errorResponse>Unknown response mode:  " _ tResponseModeID _ "</errorResponse>")

	Quit tResponse

GetResponseET
	Set $ZTrap = ""

	Set tResponse = ##class(%GlobalCharacterStream).%New()
	Do tResponse.Write("<errorResponse>An error has occurred in GetReponse():  " _ $ZError _ "</errorResponse>")
	Do tResponse.Rewind()

	Set tID = $Increment(^Demo.HL7v3.TestHarness.Errors("GetResponse"))
	Set ^Demo.HL7v3.TestHarness.Errors("GetResponse", tID) = $ZDateTime($Horolog, 3) _ "|" _ $ZError
	
	Quit tResponse
]]></Implementation>
</Method>

<Method name="GetInteractiveResponse">
<FormalSpec>pInput:%GlobalCharacterStream</FormalSpec>
<ReturnType>%GlobalCharacterStream</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "GetInteractiveResponseET"
	
	// Get request message name (root element)
	Do pInput.Rewind()
	Set tStatus	= ##class(%XML.XPATH.Document).CreateFromStream(pInput, .tDocument)
	Set tStatus	= tDocument.EvaluateExpression("/*", "name()", .tResults)
	
	If (tResults.Count() > 0) Set tRoot = tResults.GetAt(1).Value
	Else  Set tRoot = "<errorNoRootElement>"
	
	// Save in the queue
	Set tQueue = ##class(Demo.HL7v3.TestHarness.MessageQueue).%New()
	Do tQueue.Request.CopyFrom(pInput)
	Set tQueue.RequestName	= tRoot
	Set tStatus				= tQueue.%Save()
	Set tQueuedMessageID	= tQueue.%Id()
	Kill tQueue
	
	// Enter wait loop
	Set tBegin = $ZHorolog
	Do {
		&sql(
			Select	ID
			From	Demo_HL7v3_TestHarness.MessageQueue
			Where	ID = :tQueuedMessageID
			And		Status = 'queued'
		)
		
		If (($ZHorolog - tBegin) >= 300) Quit

		Hang .5
	} While (SQLCODE = 0)
	
	// Out of loop, so we can delete from queue and return response
	If SQLCODE {
		Set tMessage	= ##class(Demo.HL7v3.TestHarness.MessageQueue).%OpenId(tQueuedMessageID)
		Set tResponse	= tMessage.Response
		Set tStatus		= ##class(Demo.HL7v3.TestHarness.MessageGenerator).ProcessStream(.tResponse)
	}
	Else {
		Set tResponse = ##class(%GlobalCharacterStream).%New()
		Do tResponse.Write("<errorResponse>Response not received within a 5-minute timout period</errorResponse>")
	}

	// Remove message from queue
	&sql(
		Delete
		From	Demo_HL7v3_TestHarness.MessageQueue
		Where	ID = :tQueuedMessageID
	)

	Do tResponse.Rewind()
	
	Quit tResponse

GetInteractiveResponseET
	Set $ZTrap = ""

	Set tResponse = ##class(%GlobalCharacterStream).%New()
	Do tResponse.Write("<errorResponse>An error has occurred in GetInteractiveResponse():  " _ $ZError _ "</errorResponse>")
	Do tResponse.Rewind()

	Set tID = $Increment(^Demo.HL7v3.TestHarness.Errors("GetInteractiveResponse"))
	Set ^Demo.HL7v3.TestHarness.Errors("GetInteractiveResponse", tID) = $ZDateTime($Horolog, 3) _ "|" _ $ZError
	
	Quit tResponse
]]></Implementation>
</Method>

<Method name="GetAutomatedResponse">
<FormalSpec>pInput:%GlobalCharacterStream</FormalSpec>
<ReturnType>%GlobalCharacterStream</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap		= "GetAutomatedResponseET"
	Set tFoundMatch	= 0
	
	Do pInput.Rewind()
	Set tStatus = ##class(%XML.XPATH.Document).CreateFromStream(pInput, .tDocument)

	// Iterate through potential XPATH matches
	&sql(
		Declare	XPATH Cursor For
		Select	ID, XPathContext, XPathExpression, XPathValue
		Into	:tResponseMapID, :tXPathContext, :tXPathExpression, :tXPathValue
		From	Demo_HL7v3_TestHarness.ResponseMap
	)
	&sql( Open XPATH )
	&sql( Fetch XPATH )
	While 'SQLCODE {
		Set tStatus = tDocument.EvaluateExpression(tXPathContext, tXPathExpression, .tResults)
	
		// Make sure we've got something to process
		If ($Get(tResults) '= "") && ($IsObject(tResults) = 1) && (tResults.Count() > 0) {
			If (tXPathValue = tResults.GetAt(1).Value) {
				Set tFoundMatch = 1
				
				Quit
			}
	
			&sql( Fetch XPATH )
		}	
		&sql( Close XPATH )
	}
	
	If (tFoundMatch = 1) {
		Set tResponse	= ##class(Demo.HL7v3.TestHarness.ResponseMap).%OpenId(tResponseMapID).Response.Message
		Set tStatus		= ##class(Demo.HL7v3.TestHarness.MessageGenerator).ProcessStream(.tResponse)

		Quit tResponse
	}
	Else {
		Set tResponse = ##class(%GlobalCharacterStream).%New()
		Do tResponse.Write("<defaultResponse>Failed to match specific response</defaultResponse>")
		Do tResponse.Rewind()

		Quit tResponse
	}
	
	Quit

GetAutomatedResponseET
	Set $ZTrap = ""

	Set tResponse = ##class(%GlobalCharacterStream).%New()
	Do tResponse.Write("<errorResponse>An error has occurred in GetAutomatedReponse():  " _ $ZError _ "</errorResponse>")
	Do tResponse.Rewind()

	Set tID = $Increment(^Demo.HL7v3.TestHarness.Errors("GetAutomatedResponse"))
	Set ^Demo.HL7v3.TestHarness.Errors("GetAutomatedResponse", tID) = $ZDateTime($Horolog, 3) _ "|" _ $ZError

	Quit tResponse
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.TestHarness.Utils">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60162,51202.624522</TimeCreated>

<Method name="SendMessagesBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMessageName:%String="",pInterfaceCount:%String=0,pMessageCount:%String=0,pHang:%String=".1",pForeground:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (pForeground = 1) {
		Set tInterfaceID = 1

		Set tStatus = $$Start()
	}
	Else {
			If ($ZConvert($Extract(pInterfaceCount, 1, 2), "U") = "$R") { Set @("tNumInterfaces=" _ pInterfaceCount), tNumInterfaces = +tNumInterfaces } Else { Set tNumInterfaces = +pInterfaceCount }

			For tInterfaceID = 1:1:tNumInterfaces { Job Start:(:1) }
	}
	
	Quit $$$OK
	
Start()
	Set $ZTrap		= "SendMessagesBatchET"
	Set tStatus		= ##class(Demo.HL7v3.TestHarness.Utils).SetInterfaceInfo(pMessageName, tInterfaceID, pMessageCount, pHang)

	If ($ZConvert($Extract(pMessageCount, 1, 2), "U") = "$R") { Set @("tNumMessages=" _ pMessageCount), tNumMessages = +tNumMessages } Else { Set tNumMessages = +pMessageCount }

	&sql(
		Select		mt.ID, rm.ClassName, rm.MethodName
		Into		:tMessageTemplateID, :tClassName, :tMethodName
		From		Demo_HL7v3_TestHarness.RequestMap as rm
		Inner Join	Demo_HL7v3_TestHarness.MessageTemplate as mt on mt.ID = rm.Request
		Where		mt.Name = :pMessageName
	)

	For tCount = 1:1:tNumMessages {
		If '$Data(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID)) Quit

		If 'SQLCODE {
			Set tRequest = ##class(Demo.HL7v3.TestHarness.MessageTemplate).%OpenId(tMessageTemplateID).Message
		
			If $IsObject(tRequest) && $Data(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID)) {
				Set tStatus			= ##class(Demo.HL7v3.TestHarness.MessageGenerator).ProcessStream(.tRequest)
				Set tRequestCount	= $Increment(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID, "Requests"))
				Set tRequestBytes	= $Increment(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID, "Requests", "Total Bytes"), tRequest.Size)

				Set tService = $zobjclassmethod(tClassName, "%New")
				Set @("tResponse = tService." _ tMethodName _ "(tRequest)")

				If $IsObject(tResponse) && $Data(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID)) {
					Set tResponseCount	= $Increment(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID, "Responses"))
					Set tResponseBytes	= $Increment(^Demo.HL7v3.TestHarness.Status("Client", pMessageName, tInterfaceID, "Responses", "Total Bytes"), tResponse.Size)
				}
			}
		}
		
		If ($ZConvert($Extract(pHang, 1, 2), "U") = "$R") { Set @("tHangTime=" _ pHang), tHangTime = +tHangTime } Else { Set tHangTime = +pHang }

		If +tHangTime Hang tHangTime
	}	

	Set tStatus = ##class(Demo.HL7v3.TestHarness.Utils).ClearInterfaceInfo(pMessageName, tInterfaceID)

	Quit $$$OK

SendMessagesBatchET
	Set $ZTrap = ""
	
	Set tStatus = ##class(Demo.HL7v3.TestHarness.Utils).ClearInterfaceInfo(pMessageName, tInterfaceID)

	Set tID = $Increment(^Demo.HL7v3.TestHarness.Errors("SendMessagesBatch", pMessageName, tInterfaceID))
	Set ^Demo.HL7v3.TestHarness.Errors("SendMessagesBatch", pMessageName, tInterfaceID, tID) = $ZDateTime($Horolog, 3) _ "|" _ $ZError

	Quit $$$ERROR($$$GeneralError, "An error has occurred in SendMessagesBatch():  " _ $ZError)
]]></Implementation>
</Method>

<Method name="SetInterfaceInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMessageName:%String="",pInterfaceID:%String="",pMessageCount:%Integer="",pHang:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "SetInterfaceInfoET"
	
	If (pMessageName = "") || (pInterfaceID = "") || (pMessageCount = "") Quit $$$ERROR($$$GeneralError,"Null message name, interface id, or message count encountered...")

	Set ^Demo.HL7v3.TestHarness.Status("Client", pMessageName, pInterfaceID, "Info") = $ZDateTime($Horolog, 3) _ "^" _ pMessageCount _ "^" _ pHang
	
	Quit $$$OK

SetInterfaceInfoET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError,"An error has occurred in SetInterfaceInfo():  " _ $ZError)
]]></Implementation>
</Method>

<Method name="ClearInterfaceInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMessageName:%String="",pInterfaceID:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "ClearInterfaceInfoET"
	
	If (pMessageName = "") || (pInterfaceID = "") Quit $$$ERROR($$$GeneralError,"Null message name or interface id encountered...")

	Kill ^Demo.HL7v3.TestHarness.Status("Client", pMessageName, pInterfaceID)
	
	Quit $$$OK

ClearInterfaceInfoET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError,"An error has occurred in ClearInterfaceInfo():  " _ $ZError)
]]></Implementation>
</Method>

<Method name="ClearAllInterfaceInfo">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "ClearAllInterfaceInfoET"
	
	Kill ^Demo.HL7v3.TestHarness.Status
	
	Quit $$$OK

ClearAllInterfaceInfoET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError,"An error has occurred in ClearAllInterfaceInfo():  " _ $ZError)
]]></Implementation>
</Method>
</Class>


<Class name="Demo.HL7v3.TestHarness.chead.CSPCHD">
<Description>
Created from: http://localhost/csp/ensdemo/Demo.HL7v3.Service.SOAPIn.cls?wsdl</Description>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60453,75653</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="ELEMENTQUALIFIED">
<Default>1</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Default>http://www.intersystems.com/SOAPheaders</Default>
</Parameter>

<Parameter name="XMLNAME">
<Default>CSPCHD</Default>
</Parameter>

<Parameter name="XMLSEQUENCE">
<Default>1</Default>
</Parameter>

<Property name="id">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
<Parameter name="XMLNAME" value="id"/>
</Property>
</Class>


<Class name="Demo.HL7v3.Transformation.MFMTIN002101">
<Super>Ens.DataTransform</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60206,20324.795411</TimeCreated>
<DependsOn>Demo.HL7v3.Message</DependsOn>

<Method name="Transform">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[source:Demo.HL7v3.Message,&target:Demo.HL7v3.Message]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "TransformET"

	// Get a MFMTIN002101 template as a stream
	Set tMFMTIN002101Template = ##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1) _ "||MFMTIN002101").Data

	// Get a stream of XSL from the XSL XDataBlock contained in this class
	Set tXSL = ##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1) _ "||XSL").Data

	// Create an XPATH Document instance from the input stream of XML
	Set tStatus	= ##class(%XML.XPATH.Document).CreateFromStream(source.Content, .tDocument)

	// Get patient's first name, upper-case it, and bind to XSL parameter
	Set tStatus	= tDocument.EvaluateExpression("//MFMT_IN002101/ControlActProcess/subject/registrationProcess/subject2/ActReference/recordTarget/patient/Person/name/given", "text()", .tResults)
	Set tParams("patientNameGiven") = "'" _ $ZConvert(tResults.GetAt(1).Value, "U") _ "'"
				
	// Get patient's name prefix, upper-case it, and bind to XSL parameter
	Set tStatus	= tDocument.EvaluateExpression("//MFMT_IN002101/ControlActProcess/subject/registrationProcess/subject2/ActReference/recordTarget/patient/Person/name/prefix[@qualifier='VV']", "text()", .tResults)
	Set tParams("patientNamePrefix") = "'" _ $ZConvert(tResults.GetAt(1).Value, "U") _ "'"

	// Get patient's last name, upper-case it, and bind to XSL parameter
	Set tStatus	= tDocument.EvaluateExpression("//MFMT_IN002101/ControlActProcess/subject/registrationProcess/subject2/ActReference/recordTarget/patient/Person/name/family", "text()", .tResults)
	Set tParams("patientNameFamily") = "'" _ $ZConvert(tResults.GetAt(1).Value, "U") _ "'"

	// Transform the source according to the XSL
	Set target	= ##class(Demo.HL7v3.Message).%New()
	Set tStatus	= ##class(%XML.XSLT.Transformer).TransformStream(tMFMTIN002101Template, tXSL, target.Content, , .tParams)
	If $$$ISERR(tStatus) ZTrap "XSLT"

	// Copy over name and doctype, then rewind
	Set target.Name		= source.Name
	Set target.DocType	= source.DocType
	Do target.Content.Rewind()

	Quit $$$OK

TransformET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError, "An error has occurred in Transform():  " _ $ZError)
]]></Implementation>
</Method>

<XData name="MFMTIN002101">
<Data><![CDATA[
<MFMT_IN002101>
<!-- Transport Wrapper 
  --> 
  <id extension="9223372036854775800" root="2.16.528.1.1007.3.2.700222.1" /> 
  <creationTime value="2006-01-01 12:00:00PM" /> 
  <versionCode code="12345" /> 
  <interactionId extension="MFMT_IN002101" root="2.16.840.1.113883.1.6" /> 
  <processingCode code="ER" /> 
  <processingModeCode code="T" /> 
  <acceptAckCode code="ER" /> 
<receiver>
<device>
<!-- receiving application, ID of receiving system 
  --> 
  <id extension="000700856" root="2.16.528.1.1007.3.2" /> 
<name use="L">
  <given>Heathcare System XYZ</given> 
  </name>
<agencyFor classCode="AGNT">
<representedOrganization classCode="ORG" determinerCode="INSTANCE">
  <id extension="00100100" root="2.16.528.1.1007.3.3" /> 
<name use="L">
  <given>Organization XYZ</given> 
  </name>
  </representedOrganization>
  </agencyFor>
  </device>
  </receiver>
<sender>
  <telecom use="WP" value="tel:+31307236354" /> 
<device>
<!-- sending application, ID of sending system 
  --> 
  <id extension="000700222" root="2.16.528.1.1007.3.2" /> 
<name use="L">
  <given>ABC-HIS Goodhope Hospital</given> 
  </name>
<agencyFor classCode="AGNT">
<representedOrganization classCode="ORG" determinerCode="INSTANCE">
  <id extension="00600862" root="2.16.528.1.1007.3.3" /> 
<name use="L">
  <given>Goodhope Hospital</given> 
  </name>
  </representedOrganization>
  </agencyFor>
  </device>
  </sender>
<!-- Control Act Wrapper 
  --> 
<ControlActProcess moodCode="EVN">
  <effectiveTime value="20040417" /> 
<authorOrPerformer typeCode="AUT">
<participant>
<AssignedPerson>
  <id extension="000120450" root="2.16.528.1.1007.3.1" /> 
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </AssignedPerson>
  </participant>
  </authorOrPerformer>
<overseer typeCode="RESP">
<AssignedPerson>
  <id extension="000120450" root="2.16.528.1.1007.3.1" /> 
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </AssignedPerson>
  </overseer>
<subject>
<!-- payload 
  --> 
<registrationProcess classCode="REG" moodCode="RQO">
  <code code="722933" codeSystem="2.16.840.1.113883.2.4.15.4" codeSystemName="ActRegistryCodeNL" displayName="Voorschrift" /> 
  <statusCode code="active" codeSystem="2.16.840.1.113883.5.14" /> 
<effectiveTime>
  <low value="20040417" /> 
  </effectiveTime>
<subject2 typeCode="SUBJ">
<ActReference classCode="SBADM" moodCode="RQO">
  <id extension="9223372036854775800" root="2.16.528.1.1007.3.2.400416.16" /> 
  <statusCode code="active" /> 
<recordTarget>
<patient>
  <id extension="000197245" root="2.16.840.1.113883.2.4.6.3" /> 
  <statusCode code="" /> 
<Person>
<name use="L">
  <given>Tom</given> 
  <prefix qualifier="VV">de</prefix> 
  <family>Santis</family> 
  </name>
  </Person>
<Organization>
  <id extension="00123456" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </patient>
  </recordTarget>
<authorOrPerformer typeCode="AUT">
  <time value="20040417151000" /> 
<assignedEntity>
  <id extension="0000120450" root="2.16.528.1.1007.3.1" /> 
<assignedPerson>
  <name /> 
<LocatedEntity>
  <Place /> 
  </LocatedEntity>
  </assignedPerson>
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </assignedEntity>
  </authorOrPerformer>
<overseer typeCode="RESP">
<assignedEntity>
  <id extension="000120450" root="2.16.528.1.1007.3.1" /> 
  <code code="01.015" codeSystem="2.16.840.1.113883.2.4.15.111" codeSystemName="RoleCode" displayName="GP" /> 
<assignedPerson>
  <name /> 
<LocatedEntity>
  <Place /> 
  </LocatedEntity>
  </assignedPerson>
<Organization>
  <id extension="00988137" root="2.16.528.1.1007.3.3" /> 
  </Organization>
  </assignedEntity>
  </overseer>
  </ActReference>
  </subject2>
  </registrationProcess>
  </subject>
  </ControlActProcess>
  </MFMT_IN002101>
]]></Data>
</XData>

<XData name="XSL">
<Data><![CDATA[
<?xml version="1.0"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:hl7="urn:hl7-org:v3" version="1.0">  
  
<xsl:param name="patientNameGiven"/>
<xsl:param name="patientNamePrefix"/>
<xsl:param name="patientNameFamily"/>

<xsl:output method="xml" indent="yes"/>
 
<xsl:template match="node()" priority="0"/>

<xsl:template match="//@* | //node()">
  <xsl:copy>
    <xsl:apply-templates select="@*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="//MFMT_IN002101/ControlActProcess/subject/registrationProcess/subject2/ActReference/recordTarget/patient/Person/name/given/text()">
     <xsl:value-of select="$patientNameGiven"/>
</xsl:template>  

<xsl:template match="//MFMT_IN002101/ControlActProcess/subject/registrationProcess/subject2/ActReference/recordTarget/patient/Person/name/prefix[@qualifier='VV']/text()">
     <xsl:value-of select="$patientNamePrefix"/>
</xsl:template>  

<xsl:template match="//MFMT_IN002101/ControlActProcess/subject/registrationProcess/subject2/ActReference/recordTarget/patient/Person/name/family/text()">
     <xsl:value-of select="$patientNameFamily"/>
</xsl:template>  

</xsl:stylesheet>
]]></Data>
</XData>
</Class>


<Class name="Demo.HL7v3.Transformation.QUPAIN101103">
<Super>Ens.DataTransform</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60206,20324.795411</TimeCreated>
<DependsOn>Demo.HL7v3.Message</DependsOn>

<Method name="Transform">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[source:Demo.HL7v3.Message,&target:Demo.HL7v3.Message]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZTrap = "TransformET"

	// Get a QUPAIN101103 template as a stream
	Set tQUPAIN101103Template = ##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1) _ "||QUPAIN101103").Data

	// Get a stream of XSL from the XSL XDataBlock contained in this class
	Set tXSL = ##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1) _ "||XSL").Data

	// Create an XPATH Document instance from the input stream of XML
	Set tStatus	= ##class(%XML.XPATH.Document).CreateFromStream(source.Content, .tDocument)

	// Get receiving device's name, upper-case it, and bind to XSL parameter
	Set tStatus	= tDocument.EvaluateExpression("//QUPA_IN101103/receiver/device/name/given", "text()", .tResults)
	Set tParams("receivingDeviceName") = "'" _ $ZConvert(tResults.GetAt(1).Value, "U") _ "'"

	// Get sending device's name, upper-case it, and bind to XSL parameter
	Set tStatus	= tDocument.EvaluateExpression("//QUPA_IN101103/sender/device/name/given", "text()", .tResults)
	Set tParams("sendingDeviceName") = "'" _ $ZConvert(tResults.GetAt(1).Value, "U") _ "'"

	// Transform the source according to the XSL
	Set target	= ##class(Demo.HL7v3.Message).%New()
	Set tStatus	= ##class(%XML.XSLT.Transformer).TransformStream(tQUPAIN101103Template, tXSL, target.Content, , .tParams)
	If $$$ISERR(tStatus) ZTrap "XSLT"

	// Copy over name and doctype, then rewind
	Set target.Name		= source.Name
	Set target.DocType	= source.DocType
	Do target.Content.Rewind()

	Quit $$$OK

TransformET
	Set $ZTrap = ""
	
	Quit $$$ERROR($$$GeneralError, "An error has occurred in Transform():  " _ $ZError)
]]></Implementation>
</Method>

<XData name="QUPAIN101103">
<Data><![CDATA[
<QUPA_IN101103>
	<id extension="1001" root="2.16.528.1.1007.3.2.2.233"/>
	<creationTime value="20040719140000"/>
	<versionCode code="12345"/>
	<interactionId extension="QUPA_IN101103" root="2.16.840.1.113883"/>
	<processingCode code="P"/>
	<processingModeCode code="T"/>
	<acceptAckCode code="ER"/>
	<receiver>
		<telecom use="WP" value="tel:+34372324874"/>
		<device>
			<id extension="000900478" root="2.16.528.1.1007.3.2"/>
			<name use="L">
				<given> </given>
			</name>
		</device>
	</receiver>
	<sender>
		<telecom use="WP" value="tel:+34307236354"/>
		<device>
			<!-- sending application, ID of sending system -->
			<id extension="1" root="2.16.528.1.1007.3.2"/>
			<name use="L">
				<given> </given>
			</name>
		</device>
	</sender>
	<ControlActProcess moodCode="EVN">
		<effectiveTime value="20040719135956"/>
		<authorOrPerformer typeCode="AUT">
			<participant>
				<AssignedPerson>
					<id extension="000120450" root="2.16.528.1.1007.3.1"/>
					<Organization>
						<id extension="00304845" root="2.16.528.1.1007.3.2"/>
					</Organization>
				</AssignedPerson>
			</participant>
		</authorOrPerformer>
		<reasonOf>
			<justifiedDetectedIssue>
				<code code="QNAT" codeSystem="2.16.840.1.113883.2.4.5.4" codeSystemName="ActCode"/>
				<targetOf>
					<source moodCode="DEF">
						<code code="EMAUTH" codeSystem="2.16.840.1.113883.2.4.5.4" codeSystemName="ActCode"/>
					</source>
				</targetOf>
			</justifiedDetectedIssue>
		</reasonOf>
		<queryByParameter>
			<queryId extension="5523264" root="2.16.528.1.1007.3.2.400893.15"/>
			<statusCode code="new"/>
			<person.addr>
				<value>
					<postalCode>5735 EP</postalCode>
				</value>
				<semanticsText>Person.addr</semanticsText>
			</person.addr>
			<person.birthTime>
				<value>
					<center value="19750103"/>
				</value>
				<semanticsText>Person.birthTime</semanticsText>
			</person.birthTime>
		</queryByParameter>
	</ControlActProcess>
</QUPA_IN101103>
]]></Data>
</XData>

<XData name="XSL">
<Data><![CDATA[
<?xml version="1.0"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:hl7="urn:hl7-org:v3" version="1.0">  
  
<xsl:param name="receivingDeviceName"/>
<xsl:param name="sendingDeviceName"/>

<xsl:output method="xml" indent="yes"/>
 
<xsl:template match="node()" priority="0"/>

<xsl:template match="//@* | //node()">
  <xsl:copy>
    <xsl:apply-templates select="@*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="//QUPA_IN101103/receiver/device/name/given/text()">
     <xsl:value-of select="$receivingDeviceName"/>
</xsl:template>  

<xsl:template match="//QUPA_IN101103/sender/device/name/given/text()">
     <xsl:value-of select="$sendingDeviceName"/>
</xsl:template>  

</xsl:stylesheet>
]]></Data>
</XData>
</Class>


<Class name="Demo.JMS.HL7toJMS">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64956,24630.608973</TimeCreated>
<DependsOn>EnsLib.HL7.Message,EnsLib.JMS.Message</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.HL7.Message' targetClass='EnsLib.JMS.Message' sourceDocType='2.7.1' create='new' language='objectscript' >
<annotation>Transform HL7 message to JMS message</annotation>
<assign value='source.OutputToString()' property='target.text' action='set' />
<assign value='"TextMessage"' property='target.type' action='set' />
<assign value='target.setStringProperty("Receiving_Application",source.GetValueAt("MSH:5.1"))' property='status' action='set' />
<assign value='target.setStringProperty("Receiving_Site",source.GetValueAt("MSH:6.1"))' property='status' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.JMS.Operation">
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64946,45627.275721</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.JMS.OutboundAdapter</Default>
</Parameter>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
<MapItem MessageType="Ens.StringRequest"> 
<Method>OnStringRequest</Method>
</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="OnStringRequest">
<FormalSpec>pRequest:Ens.StringRequest,*pResponse:Ens.StringRequest</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set tSC = ..Adapter.GetNewMessage(.message) quit:$$$ISERR(tSC)
		;
		do message.setText(pRequest.StringValue)
		do message.setType("TextMessage")
		do message.setByteProperty("myByteKey","A")
		do message.setBooleanProperty("myBooleanKey",1)
		do message.setShortProperty("myShortKey",123)
		do message.setIntegerProperty("myIntegerKey",1234567890)
		do message.setLongProperty("myLongKey",9876543210)
		do message.setFloatProperty("myFloatKey",1.2)
		do message.setDoubleProperty("myDoubleKey",3.1415926)
		do message.setStringProperty("myStringKey","XYZ")
		;
		set index = $i(^JMSLOG)
		set ^JMSLOG(index,"*","type") = "operation pre-call"
		set ^JMSLOG(index,"*","name") = ..%ConfigName
		set ^JMSLOG(index,"*","time") = ##class(%UTC).NowLocal()
		set ^JMSLOG(index,"messageText") = message.getText()
		set ^JMSLOG(index,"messageType") = message.getType()
		set keys = message.getPropertyKeys()
		for i=1:1:keys.size() {
			set key = keys.get(i-1)
			set ^JMSLOG(index,"messageProperty",key) = message.getProperty(key)
		}
		;
		set tSC = ..Adapter.SendMessage(message) quit:$$$ISERR(tSC)
		;
		set index = $i(^JMSLOG)
		set ^JMSLOG(index,"*","type") = "operation post-call"
		set ^JMSLOG(index,"*","name") = ..%ConfigName
		set ^JMSLOG(index,"*","time") = ##class(%UTC).NowLocal()
		set ^JMSLOG(index,"messageId") = message.getMessageId()
		;
		set pResponse = ##class(Ens.StringRequest).%New("Message sent as "_message.getMessageId())
		;
	} catch {
		set tSC=$S($ZE["<ZJGTW>":%objlasterror,1:$$$SystemError)
	}
	;
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.JMS.Process">
<Super>Ens.BusinessProcess</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64979,47158.230555</TimeCreated>

<Method name="OnRequest">
<Description>
Handle a 'Request'</Description>
<FormalSpec>request:EnsLib.JMS.Message,*response:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set index = $i(^JMSLOG)
	set ^JMSLOG(index,"*","type")="process"
	set ^JMSLOG(index,"*","name") = ..%ConfigName
	set ^JMSLOG(index,"*","time")= ##class(%UTC).NowLocal()
	set ^JMSLOG(index,"messageId") = request.messageId
	set ^JMSLOG(index,"messageText") = request.text
	set ^JMSLOG(index,"messageType") = request.type
	set key="" for  {
		set key = request.getNextPropertyKey(key) quit:key=""
		set value = request.getProperty(key)
		set ^JMSLOG(index,"messageProperty",key) = request.getProperty(key)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.JMS.Production">
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64943,21665.548191</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.JMS.Production" TestingEnabled="true" LogGeneralTraceEvents="false">
<Description></Description>
<ActorPoolSize>2</ActorPoolSize>
<Item Name="JavaGatewayManager" Category="" ClassName="EnsLib.JavaGateway.Service" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
<Setting Target="Host" Name="Port">33333</Setting>
<Setting Target="Host" Name="ClassPath">../../dev/java/lib/JDK18/cache-enslib-jms-2.0.0.jar;../../dev/java/lib/jms/wljmsclient.jar;../../dev/java/lib/jms/wlthint3client.jar</Setting>
</Item>
<Item Name="TestingService" Category="" ClassName="EnsLib.Testing.Service" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
</Item>
<Item Name="Demo.JMS.Operation" Category="" ClassName="Demo.JMS.Operation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
<Setting Target="Adapter" Name="JavaGatewayPort">33333</Setting>
<Setting Target="Adapter" Name="JMSServer">t3://va-ins-vdif1:7003</Setting>
<Setting Target="Adapter" Name="JMSFactory">esr.jms.connectionFactory.InboundConnFactory</Setting>
<Setting Target="Adapter" Name="JMSQueue">Edb.jms.queue.DistributedInboundQueryQueue</Setting>
<Setting Target="Adapter" Name="JMSCredentials">WebLogic</Setting>
<Setting Target="Adapter" Name="JMSLogFileName">JMS_Demo_Operation.log</Setting>
<Setting Target="Host" Name="ReplyCodeActions">E=R</Setting>
</Item>
<Item Name="Demo.HL7.FileService" Category="" ClassName="EnsLib.HL7.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
<Setting Target="Adapter" Name="FilePath">../../Data/JMS/HL7In</Setting>
<Setting Target="Adapter" Name="FileSpec">*.*</Setting>
<Setting Target="Host" Name="MessageSchemaCategory">2.7.1</Setting>
<Setting Target="Host" Name="TargetConfigNames">Demo.JMS.RoutingRule</Setting>
</Item>
<Item Name="Demo.JMS.RoutingRule" Category="" ClassName="EnsLib.HL7.MsgRouter.RoutingEngine" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
<Setting Target="Host" Name="Validation"></Setting>
<Setting Target="Host" Name="BusinessRuleName">Demo.JMS.RoutingRule</Setting>
</Item>
<Item Name="EnsLib.JMS.Operation" Category="" ClassName="EnsLib.JMS.Operation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
<Setting Target="Adapter" Name="JavaGatewayPort">33333</Setting>
<Setting Target="Adapter" Name="JMSServer">t3://va-ins-vdif1:7003</Setting>
<Setting Target="Adapter" Name="JMSFactory">esr.jms.connectionFactory.InboundConnFactory</Setting>
<Setting Target="Adapter" Name="JMSQueue">Edb.jms.queue.DistributedInboundQueryQueue</Setting>
<Setting Target="Adapter" Name="JMSCredentials">WebLogic</Setting>
<Setting Target="Adapter" Name="JMSLogFileName">JMS_EnsLib_Operation.log</Setting>
</Item>
<Item Name="EnsLib.JMS.Service" Category="" ClassName="EnsLib.JMS.Service" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
<Setting Target="Adapter" Name="JavaGatewayPort">33333</Setting>
<Setting Target="Adapter" Name="JMSServer">t3://va-ins-vdif1:7003</Setting>
<Setting Target="Adapter" Name="JMSFactory">esr.jms.connectionFactory.InboundConnFactory</Setting>
<Setting Target="Adapter" Name="JMSQueue">Edb.jms.queue.DistributedInboundQueryQueue</Setting>
<Setting Target="Adapter" Name="JMSCredentials">WebLogic</Setting>
<Setting Target="Adapter" Name="JMSLogFileName">JMS_EnsLib_Service.log</Setting>
<Setting Target="Host" Name="TargetConfigNames">Demo.JMS.Process</Setting>
</Item>
<Item Name="Demo.JMS.Process" Category="" ClassName="Demo.JMS.Process" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
</Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.JMS.RoutingRule">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64957,37946.560722</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.HL7.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="Demo.JMS.RoutingRule" context="EnsLib.HL7.MsgRouter.RoutingEngine" production="Demo.JMS.Production">
<ruleSet name="Demo RuleSet" effectiveBegin="" effectiveEnd="">
<rule name="Demo Rule">
<when condition="1">
<send transform="Demo.JMS.HL7toJMS" target="EnsLib.JMS.Operation"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.JMS.Service">
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>64946,45639.45232</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.JMS.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pMessage:%Net.Remote.Proxy,*pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set index = $i(^JMSLOG)
	set ^JMSLOG(index,"*","type")="service"
	set ^JMSLOG(index,"*","name") = ..%ConfigName
	set ^JMSLOG(index,"*","time")= ##class(%UTC).NowLocal()
	set ^JMSLOG(index,"messageId") = pMessage.getMessageId()
	set ^JMSLOG(index,"messageText") = pMessage.getText()
	set ^JMSLOG(index,"messageType") = pMessage.getType()
	set keys = pMessage.getPropertyKeys()
	for i=1:1:keys.size() {
		set key = keys.get(i-1)
		set ^JMSLOG(index,"messageProperty",key) = pMessage.getProperty(key)
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.BankEven">
<Description>
Loan Approval Business Process for Bank Even.
Bank Even simulates a bank with unreliable service;
sometimes it responds quickly, other times not.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,50665.473</TimeCreated>

<XData name="BPL">
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Demo.Loan.Msg.Application' response='Demo.Loan.Msg.Approval' height='2000' width='2000' >
<context>
<property name='CreditRating' type='%Integer' />
<property name='PrimeRate' type='%Numeric' />
<property name='NameLength' type='%Integer' />
</context>
<sequence xend='550' yend='900' >
<trace value='"received application for "_request.Name' xpos='550' ypos='200' />
<assign name='Count Name Length' property='context.NameLength' value='$Length(request.Name)' action='set' xpos='550' ypos='300' />
<transform name='Initialize from Loan App' class='Demo.Loan.BankEvenLoanAppTransform' source='request' target='response' xpos='550' ypos='400' />
<call name='PrimeRate' target='Demo.Loan.WebOperations' async='0' xpos='550' ypos='500' >
<annotation>Make a synchronous request for the Prime Rate.</annotation>
<request type='Demo.Loan.Msg.PrimeRateRequest' />
<response type='Demo.Loan.Msg.PrimeRateResponse' >
<assign property='context.PrimeRate' value='callresponse.PrimeRate' action='set' />
</response>
</call>
<call name='CreditRating' target='Demo.Loan.WebOperations' async='0' xpos='550' ypos='600' >
<annotation>Make a synchronous request	for the Credit Rating.</annotation>
<request type='Demo.Loan.Msg.CreditRatingRequest' >
<assign property='callrequest.TaxID' value='request.TaxID' action='set' />
</request>
<response type='Demo.Loan.Msg.CreditRatingResponse' >
<assign property='context.CreditRating' value='callresponse.CreditRating' action='set' />
</response>
</call>
<assign name='InterestRate' property='response.InterestRate' value='context.PrimeRate+1+(2*(1-(context.CreditRating/100)))' action='set' xpos='550' ypos='700' >
<annotation>Copy InterestRate into the response object.</annotation>
</assign>
<trace value='"application is "_$s(response.IsApproved:"approved for "_response.InterestRate_"%",1:"denied")' xpos='550' ypos='800' />
</sequence>
</process>
]]></Data>
</XData>

<Property name="BankName">
<Type>%String</Type>
<InitialExpression>"Bank Even"</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Type>%String</Type>
<Default>BankName</Default>
</Parameter>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>BankEvenDefaultData</DefaultData>
<Data name="BankEvenDefaultData">
<Structure>listnode</Structure>
<Subscript>"BankEven"</Subscript>
<Value name="1">
<Value>BankName</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.BankEvenLoanAppTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60213,48389</TimeCreated>
<DependsOn>Demo.Loan.Msg.Application,Demo.Loan.Msg.Approval</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>0</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.Loan.Msg.Application' targetClass='Demo.Loan.Msg.Approval' create='new' language='objectscript' >
<assign value='process.BankName' property='target.BankName' action='set'  />
<assign value='(context.NameLength#2)=0' property='target.IsApproved' action='set'  />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.Loan.BankManana">
<Description>
Loan Approval Business Process for Bank Manana.
Bank Manana simulates a bank with unreliable service;
sometimes it responds quickly, other times not.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,50665.473</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<XData name="BPL">
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process request="Demo.Loan.Msg.Application" response="Demo.Loan.Msg.Approval">

	<context>
		<property name="CreditRating" type="%Integer"/>
		<property name="PrimeRate" type="%Numeric"/>
	</context>

	<sequence>

	<trace value='"received application for "_request.Name'/>
	<assign name='Init Response' property="response.BankName" value='"BankManana"'>
	<annotation><![CDATA[Initialize the response object.]]]]><![CDATA[></annotation>
	</assign>

	<call name="PrimeRate" target="Demo.Loan.WebOperations" async="0">
	<annotation><![CDATA[Make a synchronous request for the Prime Rate.]]]]><![CDATA[></annotation>
	<request type="Demo.Loan.Msg.PrimeRateRequest">
	</request>
	<response type="Demo.Loan.Msg.PrimeRateResponse">
	<assign property="context.PrimeRate" value="callresponse.PrimeRate"/>
	</response>
	</call>

	<call name="CreditRating" target="Demo.Loan.WebOperations" async="0">
	<annotation><![CDATA[Make a synchronous request	for the Credit Rating.]]]]><![CDATA[></annotation>
	<request type="Demo.Loan.Msg.CreditRatingRequest">
	<assign property="callrequest.TaxID" value='request.TaxID'/>
	</request>
	<response type="Demo.Loan.Msg.CreditRatingResponse">
	<assign property="context.CreditRating" value="callresponse.CreditRating"/>
	</response>
	</call>

	<assign name='IsApproved' property="response.IsApproved" value="1">
		<annotation><![CDATA[Copy IsApproved into the response object.]]]]><![CDATA[></annotation>
	</assign>

	<assign name='InterestRate' property="response.InterestRate" value="context.PrimeRate+1+(2*(1-(context.CreditRating/100)))">	
		<annotation><![CDATA[Copy InterestRate into the response object.]]]]><![CDATA[></annotation>
	</assign>
	
	<delay name="Delay" duration="&quot;PT&quot;_(2+($zcrc(request.Name,3)#7))_&quot;S&quot;">
		<annotation><![CDATA[Wait for a random duration.
This simulates the poor service offered by this bank.]]]]><![CDATA[></annotation>
	</delay>
	
	<trace value='"application is "_$s(response.IsApproved:"approved for "_response.InterestRate_"%",1:"denied")'/>
	</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.Loan.BankMetrics">
<Description>
Business Metric Class for Demo Loan Production</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessMetric</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56776</TimeCreated>

<Property name="LoansRequested">
<Description>
Total number of loan requests to date.</Description>
<Type>Ens.DataType.Metric</Type>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="10000"/>
<Parameter name="UNITS" value="Applications"/>
</Property>

<Property name="LoansApproved">
<Description>
Total number of loans approved to date.</Description>
<Type>Ens.DataType.Metric</Type>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="10000"/>
<Parameter name="UNITS" value="Applications"/>
</Property>

<Method name="OnCalculateMetrics">
<Description>
Calculate and update the set of metrics for this class</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Note: these calculations are not accurate, they 
	// are demonstrative.
	
	// set the values of our metrics
	&sql(SELECT COUNT(*) INTO :count
		 FROM Demo_Loan_Msg.Application)

	Set ..LoansRequested = count
	
	// set the values of our metrics
	&sql(SELECT COUNT(*) INTO :count 
		 FROM Demo_Loan_Msg.Approval
		 WHERE IsApproved = 1)

	Set ..LoansApproved = count

	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.BankSoprano">
<Description>
Loan Approval Business Process for Bank Soprano.
Bank Soprano simulates a bank with great service but
somewhat high interest rates.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,50665.473</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<XData name="BPL">
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process request="Demo.Loan.Msg.Application" response="Demo.Loan.Msg.Approval">
	
	<context>
		<property name="CreditRating" type="%Integer"/>
		<property name="PrimeRate" type="%Numeric"/>
	</context>
	
	<sequence>

	<trace value='"received application for "_request.Name'/>
	
	<assign name='Init Response' property="response.BankName" value='"BankSoprano"'>
	<annotation><![CDATA[Initialize the response object.]]]]><![CDATA[></annotation>
	</assign>
	
	<call name="PrimeRate" target="Demo.Loan.WebOperations" async="1">
	<annotation><![CDATA[Send an asynchronous request for the Prime Rate.]]]]><![CDATA[></annotation>
	<request type="Demo.Loan.Msg.PrimeRateRequest"/>
	<response type="Demo.Loan.Msg.PrimeRateResponse">
	<assign property="context.PrimeRate" value="callresponse.PrimeRate"/>
	</response>
	</call>

	<call name="CreditRating" target="Demo.Loan.WebOperations" async="1">
	<annotation><![CDATA[Send an asynchronous request for the Credit Rating.]]]]><![CDATA[></annotation>
	<request type="Demo.Loan.Msg.CreditRatingRequest">
	<assign property="callrequest.TaxID" value='request.TaxID'/>
	</request>
	<response type="Demo.Loan.Msg.CreditRatingResponse">
	<assign property="context.CreditRating" value="callresponse.CreditRating"/>
	</response>
	</call>

	<sync name='Wait' calls="PrimeRate,CreditRating" type="all" timeout="10">
	<annotation><![CDATA[Wait for the response from the async requests.
Wait for up to 10 seconds.]]]]><![CDATA[></annotation>
	</sync>

	<switch name='Approved?'>
	<case name='No PrimeRate' condition='context.PrimeRate=""'>
		<assign name='Not Approved' property="response.IsApproved" value="0"/>
	</case>
	<case name='No Credit' condition='context.CreditRating=""'>
		<assign name='Not Approved' property="response.IsApproved" value="0"/>
	</case>
	<default name='Approved' >
	<assign name='Approved' property="response.IsApproved" value="1"/>
	<assign name='InterestRate' property="response.InterestRate" value="context.PrimeRate+10+(99*(1-(context.CreditRating/100)))">
		<annotation><![CDATA[Copy InterestRate into response object.]]]]><![CDATA[></annotation>
	</assign>
	</default>
	</switch>

	<delay name='Delay' duration="&quot;PT&quot;_(2+($zcrc(request.Name,4)#5))_&quot;S&quot;">
		<annotation><![CDATA[Wait for a random duration.]]]]><![CDATA[></annotation>
	</delay>
	
	<trace value='"application is "_$s(response.IsApproved:"approved for "_response.InterestRate_"%",1:"denied")'/>

	</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>BankSopranoDefaultData</DefaultData>
<Data name="BankSopranoDefaultData">
<Subscript>"BankSoprano"</Subscript>
<Value name="1">
<Value>CreditRating</Value>
</Value>
<Value name="2">
<Value>PrimeRate</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.BankUS">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcess</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,50665.473</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Property name="CreditRating">
<Type>%Integer</Type>
</Property>

<Property name="PrimeRate">
<Type>%Numeric</Type>
</Property>

<Method name="OnRequest">
<FormalSpec>request:Demo.Loan.Msg.Application,*response:Demo.Loan.Msg.Approval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		$$$TRACE("received application for "_request.Name)
		#;
		If $zcrc(request.Name,2)#5=0 {
			Set response = ##class(Demo.Loan.Msg.Approval).%New()
			Set response.BankName = "BankUS"
			Set response.IsApproved = 0
			$$$TRACE("application is denied because of bank holiday")
			Quit
		}
		#;
		Set tRequest = ##class(Demo.Loan.Msg.PrimeRateRequest).%New()
		Set tSC = ..SendRequestAsync("Demo.Loan.WebOperations",tRequest,1,"PrimeRate")
		#;
		Set tRequest = ##class(Demo.Loan.Msg.CreditRatingRequest).%New()
		Set tRequest.TaxID = request.TaxID
		Set tSC = ..SendRequestAsync("Demo.Loan.WebOperations",tRequest,1,"CreditRating")
		#;
		Set tSC = ..SetTimer("PT15S")
		#;
		Quit
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError Goto Exit
]]></Implementation>
</Method>

<Method name="OnResponse">
<Description>
Handle a 'Response'</Description>
<FormalSpec><![CDATA[request:Ens.Request,&response:Ens.Response,callrequest:Ens.Request,callresponse:Ens.Response,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		If pCompletionKey="PrimeRate" {
			Set ..PrimeRate = callresponse.PrimeRate
		} Elseif pCompletionKey="CreditRating" {
			Set ..CreditRating = callresponse.CreditRating
		}
		Quit
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError Goto Exit
]]></Implementation>
</Method>

<Method name="OnComplete">
<FormalSpec><![CDATA[request:Ens.Request,&response:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		Set response = ##class(Demo.Loan.Msg.Approval).%New()
		Set response.BankName = "BankUS"
		Set tIsUsCitizen=($zcvt($tr(request.Nationality,"."),"u")="USA")||($zcvt($tr(request.Nationality,"."),"u")="US")
		If ('tIsUsCitizen)||(..CreditRating<50) {
			Set response.IsApproved = 0
			$$$TRACE("application is denied")
		} Else {
			Set response.IsApproved = 1
			Set response.InterestRate = ..PrimeRate+2+(5*(1-(..CreditRating/100)))
			$$$TRACE("application is approved for "_response.InterestRate_"%")
		}
		Quit
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>BankUSDefaultData</DefaultData>
<Data name="BankUSDefaultData">
<Structure>listnode</Structure>
<Subscript>"BankUS"</Subscript>
<Value name="1">
<Value>CreditRating</Value>
</Value>
<Value name="2">
<Value>PrimeRate</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.BankUSProduction">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59312,56897.326</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.Loan.BankUSProduction" TestingEnabled="true">
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Demo.Loan.BankUSTerminalService" ClassName="Demo.Loan.BankUSTerminalService" PoolSize="0" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
  <Item Name="Demo.Loan.WebOperations" ClassName="Demo.Loan.WebOperations" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
  <Item Name="Demo.Loan.BankUS" ClassName="Demo.Loan.BankUS" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
</Production>
]]></Data>
</XData>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..Start()
	;
	Set tSC=##class(Ens.Director).CreateBusinessService("Demo.Loan.BankUSTerminalService",.tBusinessService)
	If $$$ISERR(tSC) Do $system.OBJ.DisplayError(tSC) Quit
	For {
		Read !,"amount:name:taxid:nationality>",tInput,! Quit:tInput=""
		Set tSC=tBusinessService.ProcessInput(##class(Ens.StringContainer).%New(tInput),.tOutput)
		If 'tSC Do $system.Status.DisplayError(tSC) Continue
		Write !,tOutput.StringValue
	}
	Set tBusinessService = $$$NULLOREF
	;
	Do ..Stop()
	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.BankUSTerminalService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59276,57717.364</TimeCreated>

<Method name="OnProcessInput">
<FormalSpec>pInput:Ens.StringContainer,pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; assuming the first line is 'amount:name:TaxID:nationality'
	Set tSubject=pInput.StringValue

	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount=$p(tSubject,":",1)
	Set tApplication.Name=$p(tSubject,":",2)
	Set tApplication.TaxID=$p(tSubject,":",3)
	Set tApplication.Nationality=$p(tSubject,":",4)
	Set tSC=..SendRequestSync("Demo.Loan.BankUS",tApplication,.tApproval)  Quit:$$$ISERR(tSC) tSC

	Set pOutput=##class(Ens.StringContainer).%New(tApproval.GetText())
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.Dashboard">
<Description>
Business Activity Dashboard for Demo.Loan application.</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Dashboard</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56776</TimeCreated>

<XData name="Dashboard">
<Data><![CDATA[
<Dashboard RefreshRate="2000" Metric="Demo.Loan.BankMetrics">
<Speedometer Label="Requests" Property="LoansRequested" />
<Speedometer Label="Approvals" Property="LoansApproved" />
</Dashboard>
]]></Data>
</XData>
</Class>


<Class name="Demo.Loan.FindRateCSPService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59278,43007.285</TimeCreated>

<Method name="OnProcessInput">
<FormalSpec>pCSPRequest:%CSP.Request,pOutput:Ens.StringContainer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount = pCSPRequest.Get("Amount")
	Set tApplication.Name = pCSPRequest.Get("Name")
	Set tApplication.TaxID = pCSPRequest.Get("TaxID")
	Set tApplication.Nationality = pCSPRequest.Get("Nationality")
	Set tApplication.BusinessOperationType = "mail"
	Set tApplication.Destination = pCSPRequest.Get("EMail")
	Set tSC = ..SendRequestAsync("Demo.Loan.FindRateDecisionProcessBPL",tApplication)  Quit:$$$ISERR(tSC) tSC

	Set pOutput = ##class(Ens.StringContainer).%New(tApplication.GetRecordNumberText(1))
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateDecisionProcessBPL">
<Description>
Loan Approval Business Process for Find Rate.
This process passes on a Loan Application to 
3 other bank and finds the best available rate.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,50665.473</TimeCreated>

<Parameter name="DOMAIN">
<Default>EnsDemo</Default>
</Parameter>

<XData name="BPL">
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Demo.Loan.Msg.Application' height='2000' width='2635' >
<context>
<property name='BankName' type='%String' ><parameters><parameter name='MAXLEN' value=''/></parameters></property>
<property name='IsApproved' type='%Boolean' />
<property name='InterestRate' type='%Numeric' />
<property name='TheResults' type='Demo.Loan.Msg.Approval' collection='list' />
<property name='Iterator' type='%String' />
<property name='ThisResult' type='Demo.Loan.Msg.Approval' />
</context>
<sequence xend='550' yend='1450' >
<trace value='"received application for "_request.Name' xpos='550' ypos='200' />
<call name='BankUS' target='Demo.Loan.BankUS' async='1' xpos='550' ypos='300' >
<annotation>Send an asynchronous request to Bank US.</annotation>
<request type='Demo.Loan.Msg.Application' >
<assign property='callrequest' value='request' action='set' />
</request>
<response type='Demo.Loan.Msg.Approval' >
<assign property='context.TheResults' value='callresponse' action='append' />
</response>
</call>
<call name='BankSoprano' target='Demo.Loan.BankSoprano' async='1' xpos='550' ypos='400' >
<annotation>Send an asynchronous request to Bank Soprano.</annotation>
<request type='Demo.Loan.Msg.Application' >
<assign property='callrequest' value='request' action='set' />
</request>
<response type='Demo.Loan.Msg.Approval' >
<assign property='context.TheResults' value='callresponse' action='append' />
</response>
</call>
<call name='BankManana' target='Demo.Loan.BankManana' async='1' xpos='550' ypos='500' >
<annotation>Send an asynchronous request to Bank Manana.</annotation>
<request type='Demo.Loan.Msg.Application' >
<assign property='callrequest' value='request' action='set' />
</request>
<response type='Demo.Loan.Msg.Approval' >
<assign property='context.TheResults' value='callresponse' action='append' />
</response>
</call>
<call name='BankEven' target='Demo.Loan.BankEven' async='1' xpos='550' ypos='600' >
<annotation>Send an asynchronous request to Bank Even.</annotation>
<request type='Demo.Loan.Msg.Application' >
<assign property='callrequest' value='request' action='set' />
</request>
<response type='Demo.Loan.Msg.Approval' >
<assign property='context.TheResults' value='callresponse' action='append' />
</response>
</call>
<sync name='Wait for Banks' calls='BankUS,BankSoprano,BankManana,BankEven' timeout='5' type='all' xpos='550' ypos='700' >
<annotation>Wait for the response from the banks. Wait for up to 5 seconds.</annotation>
</sync>
<trace value='"sync complete"' xpos='550' ypos='800' />
<foreach name='Loop through Results' property='context.TheResults' key='context.Iterator' xpos='550' ypos='900' xend='550' yend='1200' >
<annotation>Loop over the results received from the banks.
Drill into this shape to see the details of the loop.
</annotation>
<assign name='ThisResult' property='context.ThisResult' value='context.TheResults.GetAt(context.Iterator)' action='set' xpos='550' ypos='200' />
<trace value='"processing reply from "_context.ThisResult.BankName' xpos='550' ypos='300' />
<if name='Approved?' condition='context.ThisResult.IsApproved' xpos='550' ypos='400' xend='550' yend='1100' >
<annotation>Were we approved by this bank?</annotation>
<true>
<if name='BetterRate?' condition='(&apos;context.IsApproved)||(context.InterestRate&gt;context.ThisResult.InterestRate)' xpos='685' ypos='550' xend='685' yend='1000' >
<annotation>Is this a better rate?
Compare rate with current best rate.</annotation>
<true>
<assign name='BankName' property='context.BankName' value='context.ThisResult.BankName' action='set' xpos='820' ypos='700' >
<annotation>This is the best rate so far;
Copy the details into the context object.</annotation>
</assign>
<assign name='IsApproved' property='context.IsApproved' value='context.ThisResult.IsApproved' action='set' xpos='820' ypos='800' />
<assign name='InterestRate' property='context.InterestRate' value='context.ThisResult.InterestRate' action='set' xpos='820' ypos='900' />
</true>
</if>
</true>
</if>
</foreach>
<switch name='Response' xpos='550' ypos='1000' xend='550' yend='1250' >
<annotation>Determine which type of response was requested.</annotation>
<case condition='request.BusinessOperationType="mail"' name='Mail' >
<call name='SendApproval' target='Demo.Loan.FindRateEMailOperation' async='1' xpos='685' ypos='1150' >
<request type='Demo.Loan.Msg.SendReply' >
<assign property='callrequest.Text' value='process.GetText(context)' action='set' />
<assign property='callrequest.Destination' value='request.Destination' action='set' />
</request>
</call>
</case>
<case condition='request.BusinessOperationType="file"' name='File' >
<call name='SendApproval' target='Demo.Loan.FindRateFileOperation' async='1' xpos='955' ypos='1150' >
<request type='Demo.Loan.Msg.SendReply' >
<assign property='callrequest.Text' value='process.GetText(context)' action='set' />
<assign property='callrequest.Destination' value='request.Destination' action='set' />
</request>
</call>
</case>
<case condition='request.BusinessOperationType="term"' name='Terminal' >
<call name='SendApproval' target='My Terminal Output' async='1' xpos='1225' ypos='1150' >
<request type='Demo.Loan.Msg.SendReply' >
<assign property='callrequest.Text' value='process.GetText(context)' action='set' />
<assign property='callrequest.Destination' value='request.Destination' action='set' />
</request>
</call>
</case>
<case condition='request.BusinessOperationType="tcp"' name='TCP' >
<call name='SendApproval' target='Demo.Loan.FindRateTCPOperation' async='1' xpos='1495' ypos='1150' >
<request type='Demo.Loan.Msg.SendReply' >
<assign property='callrequest.Text' value='process.GetText(context)' action='set' />
<assign property='callrequest.Destination' value='request.Destination' action='set' />
</request>
</call>
</case>
<case condition='request.BusinessOperationType="msmq"' name='MSMQ' >
<call name='SendApproval' target='Demo.Loan.FindRateMSMQOperation' async='1' xpos='1765' ypos='1150' >
<request type='Demo.Loan.Msg.SendReply' >
<assign property='callrequest.Text' value='process.GetText(context)' action='set' />
<assign property='callrequest.Destination' value='request.Destination' action='set' />
</request>
</call>
</case>
<case condition='request.BusinessOperationType="mqseries"' name='MQSeries' >
<call name='SendApproval' target='Demo.Loan.FindRateMQSeriesOperation' async='1' xpos='2035' ypos='1150' >
<request type='Demo.Loan.Msg.SendReply' >
<assign property='callrequest.Text' value='process.GetText(context)' action='set' />
<assign property='callrequest.Destination' value='request.Destination' action='set' />
</request>
</call>
</case>
<default/>
</switch>
<trace value='"application is "_$s(context.IsApproved:"approved for "_context.InterestRate_"% by "_context.BankName,1:"denied")' xpos='550' ypos='1350' />
</sequence>
</process>
]]></Data>
</XData>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Method name="GetText">
<FormalSpec>context:Ens.BP.Context</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSessionId=..%SessionId
	&sql(Select MessageBodyId into :tRecordNum from Ens.MessageHeader where ID=:tSessionId)
	If $Get(tRecordNum)="" set tRecordNum ="??"
	
	If context.IsApproved {
		Set tText = $$FormatMessage^%occMessages(,"EnsDemo","FindRateContext1","Your loan application with record number %1 was approved.",tRecordNum)_$c(13,10)
		Set tText = tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateContext2","The lowest interest rate available is at %1 percent offered by %2.",context.InterestRate,context.BankName)_$c(13,10)
	} Else {
		Set tText = $$FormatMessage^%occMessages(,"EnsDemo","FindRateIsDenied","Your loan application was denied.",tRecordNum)_$c(13,10)
	}
	Set tText=tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateThankyou","Thank you for applying with FindRate.")_$c(13,10)
	Quit $ZCVT(tText,"O","HTML")
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.Loan.FindRateDecisionProcessCustom">
<ClassType>persistent</ClassType>
<IncludeCode>EnsUI</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcess</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,34681.193</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Property name="BankName">
<Type>%String</Type>
</Property>

<Property name="IsApproved">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="InterestRate">
<Type>%Numeric</Type>
</Property>

<Method name="OnRequest">
<FormalSpec>request:Demo.Loan.Msg.Application,*response:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("received application for "_request.Name)
	#;
	Set tSC = ..SendRequestAsync("Demo.Loan.BankUS",request)  Quit:$$$ISERR(tSC) tSC
	Set tSC = ..SendRequestAsync("Demo.Loan.BankSoprano",request)  Quit:$$$ISERR(tSC) tSC
	Set tSC = ..SendRequestAsync("Demo.Loan.BankManana",request)  Quit:$$$ISERR(tSC) tSC
	#;
	Quit ..SetTimer("PT5S")
]]></Implementation>
</Method>

<Method name="OnResponse">
<FormalSpec><![CDATA[request:Demo.Loan.Msg.Application,&response:Ens.Response,callrequest:Demo.Loan.Msg.Application,callresponse:Demo.Loan.Msg.Approval,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'callresponse.%Extends("Demo.Loan.Msg.Approval")||'callresponse.IsApproved $$$OK
	Quit:..IsApproved&&(..InterestRate<=callresponse.InterestRate) $$$OK
	Set ..BankName = callresponse.BankName
	Set ..IsApproved = callresponse.IsApproved
	Set ..InterestRate = callresponse.InterestRate
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnComplete">
<FormalSpec><![CDATA[request:Demo.Loan.Msg.Application,&response:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("sync complete")
	#;
	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text = ..GetText()
	Set tSendReply.Destination = request.Destination
	If request.BusinessOperationType="mail" {
		Set tSC=..SendRequestAsync("Demo.Loan.FindRateEMailOperation",tSendReply,0)
	} Elseif request.BusinessOperationType="file" {
		Set tSC=..SendRequestAsync("Demo.Loan.FindRateFileOperation",tSendReply,0)
	} Elseif request.BusinessOperationType="term" {
		Set tSC=..SendRequestAsync("My Terminal Output",tSendReply,0)
	} Elseif request.BusinessOperationType="msmq" {
		Set tSC=..SendRequestAsync("Demo.Loan.FindRateMSMQOperation",tSendReply,0)
	} Elseif request.BusinessOperationType="mqseries" {
		Set tSC=..SendRequestAsync("Demo.Loan.FindRateMQSeriesOperation",tSendReply,0)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnError">
<FormalSpec><![CDATA[request:Ens.Request,&response:Ens.Response,callrequest:Ens.Request,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("received error "_$$$StatusDisplayString(pErrorStatus))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetText">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tText=""
	Set tThank = $$FormatMessage^%occMessages(,"EnsDemo","FindRateThankyou","Thank you for applying with FindRate.")
	If ..IsApproved {
		Set tText=tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateIsApproved1","Your loan application was approved.")_$c(13,10)
		Set tText=tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateIsApproved2","The lowest interest rate available is at ")_..InterestRate_$$FormatMessage^%occMessages(,"EnsDemo","FindRateOfferedby","% offered by ")_..BankName_"."_$c(13,10)
		Set tText=tText_tThank_$c(13,10)
	} Else {
		Set tText=tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateIsDenied","Your loan application was denied.")_$c(13,10)
		Set tText=tText_tThank_$c(13,10)
	}
	Quit tText
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>FindRateDecisionProcessDefaultData</DefaultData>
<Data name="FindRateDecisionProcessDefaultData">
<Subscript>"FindRateDecisionProcess"</Subscript>
<Value name="1">
<Value>BankName</Value>
</Value>
<Value name="2">
<Value>InterestRate</Value>
</Value>
<Value name="3">
<Value>IsApproved</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.FindRateEMailOperation">
<Description>
Sends emails based on EMail Adapter config settings and the property values of a Demo.Loan.Msg.SendReply request object</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59280,43460.487</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.EMail.OutboundAdapter</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.Loan.Msg.SendReply">
<Method>EMailSendReply</Method>
</MapItem>
]]></Data>
</XData>

<Method name="EMailSendReply">
<Description>
Send an approval email to the applicant</Description>
<FormalSpec>pRequest:Demo.Loan.Msg.SendReply,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pRequest.Destination="" $$$TRACE("no email address.") Quit $$$OK
	$$$TRACE("send email to "_pRequest.Destination)
	Set tMailMessage=##class(%Net.MailMessage).%New()
	Do tMailMessage.To.Insert(pRequest.Destination)
	Set tMailMessage.Subject="RE: Loan Application Approval"
	set tMailMessage.Charset="UTF-8"
	Set tSC=tMailMessage.TextData.Write(pRequest.Text)  Quit:$$$ISERR(tSC) tSC
	Set tSC=..Adapter.SendMail(tMailMessage)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateEMailService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59278,43007.285</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.EMail.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pMailMessage:%Net.MailMessage,pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("received email from "_pMailMessage.From)

	#; assuming the subject format is LoanApplication:amount:name:TaxID:nationality
	Set tSubject=pMailMessage.Subject

	#; unrecognized mail subject
	If $p(tSubject,":")'="LoanApplication" Quit

	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount=$p(tSubject,":",2)
	Set tApplication.Name=$p(tSubject,":",3)
	Set tApplication.TaxID=$p(tSubject,":",4)
	Set tApplication.Nationality=$p(tSubject,":",5)
	Set tApplication.BusinessOperationType="mail"
	Set tApplication.Destination=pMailMessage.From
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateDecisionProcessCustom",tApplication)  Quit:$$$ISERR(tSC) tSC

	$$$TRACE("record number is "_tApplication.RecordNumber())

	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text=tApplication.GetRecordNumberText()
	Set tSendReply.Destination=tApplication.Destination
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateEMailOperation",tSendReply)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateFileOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59280,43460.487</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.File.OutboundAdapter</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.Loan.Msg.SendReply">
<Method>FileSendReply</Method>
</MapItem>
]]></Data>
</XData>

<Method name="FileSendReply">
<Description>
Send an approval to the output file</Description>
<FormalSpec>pRequest:Demo.Loan.Msg.SendReply,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("write to file "_pRequest.Destination)
	Set tSC=..Adapter.PutString(pRequest.Destination, pRequest.Text)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateFileService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59278,43007.285</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.File.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pFileStream:%FileCharacterStream,pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tInputFilename=$tr(pFileStream.Filename,"/","\")
	Set tInputFilename=$p(tInputFilename,"\",$l(tInputFilename,"\"))
	Set tRecordFilename=tInputFilename
	Set $p(tRecordFilename,".",$l(tRecordFilename,"."))="record"
	Set tApprovalFilename=tInputFilename
	Set $p(tApprovalFilename,".",$l(tApprovalFilename,"."))="approval"		
	#;
	$$$TRACE("found file "_tInputFilename)
	#;
	#; assuming the first line is 'amount:name:TaxID:nationality'
	Set tSubject=pFileStream.ReadLine()
	#;
	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount=$p(tSubject,":",1)
	Set tApplication.Name=$p(tSubject,":",2)
	Set tApplication.TaxID=$p(tSubject,":",3)
	Set tApplication.Nationality=$p(tSubject,":",4)
	Set tApplication.BusinessOperationType="file"
	Set tApplication.Destination=tApprovalFilename
	Set tSC = ..SendRequestAsync("Demo.Loan.FindRateDecisionProcessCustom",tApplication)  Quit:$$$ISERR(tSC) tSC
	#;
	$$$TRACE("record number is "_tApplication.RecordNumber())
	#;
	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text=tApplication.GetRecordNumberText()
	Set tSendReply.Destination=tRecordFilename
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateFileOperation",tSendReply)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateMQSeriesOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59280,43460.487</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.MQSeries.OutboundAdapter</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.Loan.Msg.SendReply">
<Method>MQSeriesSendReply</Method>
</MapItem>
]]></Data>
</XData>

<Method name="MQSeriesSendReply">
<Description>
Send an approval to the output message</Description>
<FormalSpec>pRequest:Demo.Loan.Msg.SendReply,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("write to mqseries")
	Set tSC=..Adapter.SendMessage(pRequest.Text)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateMQSeriesService">
<Description>
A business service for FindRate using MSMQ adapters</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59389,42703.614649</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.MQSeries.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<Description>
Authors of BusinessService implements this method to receive incoming data</Description>
<FormalSpec>pInput:%RegisteredObject,*pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; assuming the first line is 'amount:name:TaxID:nationality'
	Set tSubject=pInput.Body
	If $IsObject(tSubject) {
		#; The body is a stream
		Set tSubject=tSubject.ReadLine()
	}
	
	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount=$p(tSubject,":",1)
	Set tApplication.Name=$p(tSubject,":",2)
	Set tApplication.TaxID=$p(tSubject,":",3)
	Set tApplication.Nationality=$p(tSubject,":",4)
	Set tApplication.BusinessOperationType="mqseries"
	Set tApplication.Destination="FindRateResponse"
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateDecisionProcessCustom",tApplication)  Quit:$$$ISERR(tSC) tSC

	$$$TRACE("record number is "_tApplication.RecordNumber())

	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text=tApplication.GetRecordNumberText()
	Set tSendReply.Destination="FindRateResponse"
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateMQSeriesOperation",tSendReply)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateMSMQOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59280,43460.487</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.MSMQ.OutboundAdapter</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.Loan.Msg.SendReply">
<Method>MSMQSendReply</Method>
</MapItem>
]]></Data>
</XData>

<Method name="MSMQSendReply">
<Description>
Send an approval to the output message</Description>
<FormalSpec>pRequest:Demo.Loan.Msg.SendReply,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("write to msmq "_pRequest.Destination)
	Set tSC=..Adapter.SendMessage(pRequest.Destination, pRequest.Text)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateMSMQService">
<Description>
A business service for FindRate using MSMQ adapters</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59389,42703.614649</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.MSMQ.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<Description>
Authors of BusinessService implements this method to receive incoming data</Description>
<FormalSpec>pInput:%RegisteredObject,*pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; assuming the first line is 'amount:name:TaxID:nationality'
	If pInput.BodyLength<32768 {
		#; Access the property directly
		Set tSubject=pInput.Body
	} Else {
		#; We need to access the message via a stream, since it's too large for a single string
		Set tDispatch=pInput.Become("%Activate.IDispatch")
		Set tStream=tDispatch.GetPropertyAsStream("Body")
		Set tSubject=tStream.ReadLine()
	}
	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount=$p(tSubject,":",1)
	Set tApplication.Name=$p(tSubject,":",2)
	Set tApplication.TaxID=$p(tSubject,":",3)
	Set tApplication.Nationality=$p(tSubject,":",4)
	Set tApplication.BusinessOperationType="msmq"
	Set tApplication.Destination="FindRateResponse"
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateDecisionProcessCustom",tApplication)  Quit:$$$ISERR(tSC) tSC

	$$$TRACE("record number is "_tApplication.RecordNumber())
	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text=tApplication.GetRecordNumberText()
	Set tSendReply.Destination="FindRateResponse"
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateMSMQOperation",tSendReply)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateProduction">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59312,56897.717</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.Loan.FindRateProduction" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Demo.Loan.BankMetrics" Category="" ClassName="Demo.Loan.BankMetrics" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="CallInterval">5</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateTerminalService" Category="" ClassName="Demo.Loan.FindRateTerminalService" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="BusinessPartner">Old School Bank</Setting>
  </Item>
  <Item Name="My Terminal Output" Category="" ClassName="Demo.Loan.FindRateTerminalOperation" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="BusinessPartner">Old School Bank</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateFileService" Category="" ClassName="Demo.Loan.FindRateFileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\loan\in</Setting>
    <Setting Target="Adapter" Name="FileSpec">*.application</Setting>
    <Setting Target="Adapter" Name="ArchivePath">C:\Practice\loan\inarchive</Setting>
    <Setting Target="Host" Name="BusinessPartner">LoanTech Corporation</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateFileOperation" Category="" ClassName="Demo.Loan.FindRateFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\loan\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">1</Setting>
    <Setting Target="Host" Name="BusinessPartner">LoanTech Corporation</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateEMailService" Category="" ClassName="Demo.Loan.FindRateEMailService" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="POP3Server">test.mymailserver.net</Setting>
    <Setting Target="Adapter" Name="Credentials">POP3GetEmailTest</Setting>
    <Setting Target="Host" Name="BusinessPartner">Store Front Loans</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateEMailOperation" Category="" ClassName="Demo.Loan.FindRateEMailOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="Credentials">SMTPSendEmailTest</Setting>
    <Setting Target="Adapter" Name="From">loan@FindRate.com</Setting>
    <Setting Target="Adapter" Name="SMTPServer">1.2.3.4</Setting>
    <Setting Target="Host" Name="BusinessPartner">Store Front Loans</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateTCPService" Category="" ClassName="Demo.Loan.FindRateTCPService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">1</Setting>
    <Setting Target="Adapter" Name="Port">1234</Setting>
    <Setting Target="Adapter" Name="StayConnected">60</Setting>
    <Setting Target="Host" Name="BusinessPartner">LoanQuick, Inc.</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateTCPOperation" Category="" ClassName="Demo.Loan.FindRateTCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Adapter" Name="IPAddress">!</Setting>
    <Setting Target="Adapter" Name="Port">4321</Setting>
    <Setting Target="Adapter" Name="ResponseTimeout">15</Setting>
    <Setting Target="Adapter" Name="StayConnected">-1</Setting>
    <Setting Target="Adapter" Name="ConnectTimeout">5</Setting>
    <Setting Target="Adapter" Name="ReadTimeout">60</Setting>
    <Setting Target="Host" Name="BusinessPartner">LoanQuick, Inc.</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateCSPService" Category="" ClassName="Demo.Loan.FindRateCSPService" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="BusinessPartner">My Loans, Inc.</Setting>
  </Item>
  <Item Name="Demo.Loan.WebOperations" Category="" ClassName="Demo.Loan.WebOperations" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">10</Setting>
    <Setting Target="Host" Name="BusinessPartner">My Loans, Inc.</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateDecisionProcessCustom" Category="" ClassName="Demo.Loan.FindRateDecisionProcessCustom" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateDecisionProcessBPL" Category="" ClassName="Demo.Loan.FindRateDecisionProcessBPL" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Demo.Loan.BankSoprano" Category="" ClassName="Demo.Loan.BankSoprano" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Demo.Loan.BankManana" Category="" ClassName="Demo.Loan.BankManana" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Demo.Loan.BankUS" Category="" ClassName="Demo.Loan.BankUS" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateMSMQService" Category="" ClassName="Demo.Loan.FindRateMSMQService" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="CallInterval">5</Setting>
    <Setting Target="Adapter" Name="CreateQueueIfNeeded">0</Setting>
    <Setting Target="Adapter" Name="QueueLabel">FindRate MSMQ Request Service</Setting>
    <Setting Target="Adapter" Name="QueuePathName">.\private$\FindRate_Request</Setting>
    <Setting Target="Host" Name="BusinessPartner">State Bank</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateMQSeriesService" Category="" ClassName="Demo.Loan.FindRateMQSeriesService" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="QueueManager">QM_testperson</Setting>
    <Setting Target="Adapter" Name="Channel">S_testperson/TCP/127.0.0.1(1414)</Setting>
    <Setting Target="Adapter" Name="QueueName">default</Setting>
    <Setting Target="Adapter" Name="QueueOptions">MQOO_INPUT_AS_Q_DEF</Setting>
    <Setting Target="Host" Name="BusinessPartner">Carriers Bank</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateMSMQOperation" Category="" ClassName="Demo.Loan.FindRateMSMQOperation" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="QueueLabel">Find Rate MSMQ Service Response</Setting>
    <Setting Target="Adapter" Name="QueuePathName">.\private$\FindRate_Response</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="BusinessPartner">State Bank</Setting>
  </Item>
  <Item Name="Demo.Loan.FindRateMQSeriesOperation" Category="" ClassName="Demo.Loan.FindRateMQSeriesOperation" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Adapter" Name="QueueManager">QM_testperson</Setting>
    <Setting Target="Adapter" Name="Channel">S_testperson/TCP/127.0.0.1(1414)</Setting>
    <Setting Target="Adapter" Name="QueueName">postcard</Setting>
    <Setting Target="Adapter" Name="QueueOptions">MQOO_OUTPUT</Setting>
    <Setting Target="Host" Name="BusinessPartner">Carriers Bank</Setting>
  </Item>
  <Item Name="Demo.Loan.BankEven" Category="" ClassName="Demo.Loan.BankEven" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set tSC=..TestStart()
	If 'tSC Do $system.Status.DisplayError(tSC) Quit

	Set tSC=##class(Ens.Director).CreateBusinessService("Demo.Loan.FindRateTerminalService",.tBusinessService)
	If $$$ISERR(tSC) Do $system.OBJ.DisplayError(tSC) Quit
	For {
		Read !,"amount:name:taxid:nationality>",tInput,! Quit:tInput=""
		Set tSC=tBusinessService.ProcessInput(##class(Ens.StringContainer).%New(tInput),.tOutput)
		If 'tSC Do $system.Status.DisplayError(tSC) Continue
		;Write !,tOutput.StringValue
	}
	Set tBusinessService = $$$NULLOREF

	Do ..Stop()
	Quit
]]></Implementation>
</Method>

<Method name="SendRandomData">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMode:%String="term",pCount:%Integer=1,pDelay:%Integer=10</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=..TestStart() Quit:$$$ISERR(tSC)

	If pMode="term" {
		Set tSC=##class(Ens.Director).CreateBusinessService("Demo.Loan.FindRateTerminalService",.tBS)  Quit:$$$ISERR(tSC)
	} Else { Set tSC=$$$OK }
	For tI=1:1:pCount {
		If tI>1 Hang $random(pDelay+1)

		Set tInput=..RandomRequest()
		Set tMode=pMode If tMode="all" Set tMode=$case($r(4), 0:"term", 1:"file", 2:"tcp", 3:"mail")
		Write !,"Request #",tI,": ",tInput," sent by ",tMode,!

		If tMode="term" {
			If '$Data(tBS) Set tSC=##class(Ens.Director).CreateBusinessService("Demo.Loan.FindRateTerminalService",.tBS)  Quit:$$$ISERR(tSC)
			Set tSC=tBS.ProcessInput(##class(Ens.StringContainer).%New(tInput),.tOutput)  Quit:$$$ISERR(tSC)
			Continue
		} Else { Kill tBS }
		If tMode="file" Do $zf(-1,"echo "_tInput_">C:\Practice\loan\in\random_"_$tr($zdt($H,8)," :","_")_".application") continue
		If tMode="tcp"  Do ..SendTCP(tInput,1234) Continue
		If tMode="mail" Do ..SendMail(tInput,$g(^MyEmailAddress)) continue
		If tMode="msmq" Do ..SendMSMQ(tInput,".\private$\FindRate_Request") Continue
		If tMode="mqseries" Do ..SendMQSeries(tInput,"postcard") Continue
	}
	If $$$ISERR(tSC) Do $System.Status.DisplayError(tSC)
]]></Implementation>
</Method>

<Method name="RandomRequest">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tAmount=($r(1000)+1)*1000
	Set tName=##class(%PopulateUtils).Name()
	Set tTaxID=##class(%PopulateUtils).SSN()
	Set tNationality=$p("USA,USA,UK",",",$r(3)+1)
	Quit tAmount_":"_tName_":"_tTaxID_":"_tNationality
]]></Implementation>
</Method>

<Method name="SendMail">
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication,pFrom</FormalSpec>
<Implementation><![CDATA[
	Set tSMTP=##class(%Net.SMTP).%New()
	Set tSMTP.smtpserver="192.9.200.1"
	Set tMail=##class(%Net.MailMessage).%New()
	Set tMail.Charset="iso-8859-1"
	Set tMail.From=$g(pFrom)
	Set tMail.Subject="LoanApplication:"_$g(pApplication,"100000:mo_mail:123456789:USA")
	Do tMail.To.Insert("testjsl@intersys.com")
	Do tMail.TextData.Write("The body is not used for the application purposes.")
	Set tSC=tSMTP.Send(tMail) If 'tSC Do $system.OBJ.DisplayError(tSC) Quit
	Write "Loan application is sent successfully.",!
	Quit
]]></Implementation>
</Method>

<Method name="SendMSMQ">
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication,pQueue</FormalSpec>
<Implementation><![CDATA[
	#; send message through MSMQ
	Set qinfo=##class(Activate.MSMQ.MSMQQueueInfo).%New()
	If qinfo=$$$NULLOREF Write "Failed to create MSMQQueueInfo",! Quit
	Set qinfo.PathName=pQueue
	Set qpub=qinfo.Open(2, 0)
	Set msg=##class(Activate.MSMQ.MSMQMessage).%New()
	Set msg.Label="Loan application:"_pApplication
	Set msg.Body="The body is not used for the application purposes"
	Do msg.Send(qpub)
	Do qpub.Close()
	#; read 2 message back from MSMQ
	Set qinfo=##class(Activate.MSMQ.MSMQQueueInfo).%New()
	If qinfo=$$$NULLOREF Write "Failed to create MSMQQueueInfo",! Quit
	Set qinfo.PathName=$p(pQueue,"_",1)_"_Response"
	;
	Set qpub=qinfo.Open(1, 0)
	Set msg=qpub.Receive(,,,10000)
	Write !,msg.Body,!
	;
	Set qpub=qinfo.Open(1, 0)
	Set msg=qpub.Receive(,,,10000)
	Write msg.Body,!
	Do qpub.Close()
	Quit
]]></Implementation>
</Method>

<Method name="SendMQSeries">
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication,pQueue</FormalSpec>
<Implementation><![CDATA[
	#; send message through MQ Series
	Set base=##class(EnsLib.MQSeries.Base).%New()
	Set tSC=base.Initialize("QM_dave","S_davem/TCP/127.0.0.1(1414)")
	Set tSC=base.OpenQueue(pQueue,"MQOO_OUTPUT")
	
	#; Construct a message to send
	Set msg=base.CreateMessage(.tSC)
	
	Set msg.Body="Loan application:"_pApplication_$c(13,10)_"The body is not used for the application purposes"
	
	Do base.SendMessage(msg)
	
	Do base.CloseQueue()
	Set base=""
	
	Quit
]]></Implementation>
</Method>

<Method name="SendTCP">
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication,pPort:%Integer=1234</FormalSpec>
<Implementation><![CDATA[
	Set tDevice="|TCP|"_pPort
	Open tDevice:("127.0.0.1":pPort:"ST"):2
	If $Test=0 Write "can not open TCP device '"_tDevice_"'" Quit
	;
	Use tDevice
	Set pApplication=$g(pApplication,"100000:mo_tcp:123456789:USA")
	;
	Write pApplication_$C(13,10),*-3
	;
	Read tOutput
	;
	Close tDevice
	Write tOutput
	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateTCPOperation">
<ClassType/>
<IncludeCode>%occInclude,Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59280,43460.487</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.TCP.TextLineOutboundAdapter</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.Loan.Msg.SendReply">
<Method>TCPSendReply</Method>
</MapItem>
]]></Data>
</XData>

<Method name="TCPSendReply">
<Description>
Send an approval to the output TCP listener</Description>
<FormalSpec>pRequest:Demo.Loan.Msg.SendReply,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=..Adapter.SendMessageString(pRequest.Text)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateTCPService">
<Description>
To use this service, telnet to the configured port (default=1234) and enter the application date on a single line, separated by colons.
Example: 10000:Mo:111-22-3333:US
The demo application will copy your receipt notice to the output terminal, and will send the final Approval response there as well.</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59276,57717.364</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Name of the adapter class</Description>
<Default>EnsLib.TCP.TextLineInboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pInput:Ens.StringContainer,pOutput:Ens.StringContainer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; assuming the first line is 'amount:name:TaxID:nationality'
	
	#; Just print a prompt if empty input
	If pInput.StringValue="" {
		Set pOutput=##class(Ens.StringContainer).%New("Please apply for a loan as follows - ""Amount:Name:TaxID:Nationality"" (or ""quit"" to quit)")
		Quit $$$OK
	} ElseIf $ZCVT(pInput.StringValue,"L")="quit" {
		$$$sysTRACE("Disconnecting because of client request '"_$E(pInput.StringValue,1,32767-50)_"'")
		Do ..Adapter.Disconnect()
		Quit $$$OK
	}
	$$$TRACE("received line "_pInput.StringValue)

	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tSubject=pInput.StringValue
	Set tApplication.Amount=$p(tSubject,":",1)
	Set tApplication.Name=$p(tSubject,":",2)
	Set tApplication.TaxID=$p(tSubject,":",3)
	Set tApplication.Nationality=$p(tSubject,":",4)
	Set tApplication.BusinessOperationType="tcp"
	Set tApplication.Destination=""
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateDecisionProcessBPL",tApplication)  Quit:$$$ISERR(tSC) tSC

	$$$TRACE("record number is "_tApplication.RecordNumber())
	Set pOutput=##class(Ens.StringContainer).%New(tApplication.GetRecordNumberText())

	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text=tApplication.GetRecordNumberText()
	Set tSendReply.Destination=""
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateTCPOperation",tSendReply)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateTerminalOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59280,43460.487</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItem MessageType="Demo.Loan.Msg.SendReply">
<Method>TerminalSendReply</Method>
</MapItem>
]]></Data>
</XData>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ^Ens.Debug("TraceCat",..%ConfigName,"user")=1 ; force user TRACE messages On for this config item (regardless of general trace debug settings)
	Set ^Ens.Debug("TraceCat",..%ConfigName)=0 ; force all other TRACE messages Off for this config item (regardless of general trace debug settings)
	Kill $$$EnsDebug("TraceCat")  Merge $$$EnsDebug("TraceCat")=^Ens.Debug("TraceCat") ; ensure local copy is in sync. Full sync for all jobs will happen when Ens.MonitorService gets around to it
	
	Quit ##super()
]]></Implementation>
</Method>

<Method name="TerminalSendReply">
<Description>
Send an approval message to the applicant's terminal session</Description>
<FormalSpec>pRequest:Demo.Loan.Msg.SendReply,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $x'=0 Write !
	For i=1:1:79 Write "=" Write:i=79 !
	Write pRequest.Text
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.FindRateTerminalService">
<Description>
A Business Service called via CreateBusinessService() from the command line prompt offered by the Test() method in class Demo.Loan.FindRateProduction</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59276,57717.364</TimeCreated>

<Method name="OnProcessInput">
<FormalSpec>pInput:Ens.StringContainer,pOutput:Ens.StringContainer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; assuming the first line is 'amount:name:TaxID:nationality'
	Set tSubject=pInput.StringValue

	$$$TRACE("received line "_tSubject)

	Set tApplication = ##class(Demo.Loan.Msg.Application).%New()
	Set tApplication.Amount=$p(tSubject,":",1)
	Set tApplication.Name=$p(tSubject,":",2)
	Set tApplication.TaxID=$p(tSubject,":",3)
	Set tApplication.Nationality=$p(tSubject,":",4)
	Set tApplication.BusinessOperationType="term"
	Set tApplication.Destination=""
	Set tSC=..SendRequestAsync("Demo.Loan.FindRateDecisionProcessBPL",tApplication)  Quit:$$$ISERR(tSC) tSC

	$$$TRACE("record number is "_tApplication.RecordNumber())

	Set pOutput=##class(Ens.StringContainer).%New(tApplication.GetRecordNumberText())

	Set tSendReply = ##class(Demo.Loan.Msg.SendReply).%New()
	Set tSendReply.Text=tApplication.GetRecordNumberText()
	Set tSendReply.Destination=""
	Set tSC=..SendRequestAsync("My Terminal Output",tSendReply)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Loan.Msg.Application">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,25915.521</TimeCreated>

<Property name="Amount">
<Type>%Integer</Type>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="TaxID">
<Type>%String</Type>
</Property>

<Property name="Nationality">
<Type>%String</Type>
</Property>

<Property name="BusinessOperationType">
<Type>%String</Type>
</Property>

<Property name="Destination">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Parameter name="RESPONSECLASSNAME">
<Default>Demo.Loan.Msg.Approval</Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>EnsDemo</Default>
</Parameter>

<Method name="RecordNumber">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If ..%Id()="" Do ..%Save()
	Quit ..%Id()
]]></Implementation>
</Method>

<Method name="GetRecordNumberText">
<FormalSpec>pFormatAsHTML:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCRLF=$s(pFormatAsHTML:"<br>",1:$c(13,10))
	Set tText=$$FormatMessage^%occMessages(,"EnsDemo","FindRateReceived","Your loan application has been received, and is being processed.")
	Set tTemp = $$FormatMessage^%occMessages(,"EnsDemo","FindRateRecordNumber","Your record number is %1.",..RecordNumber())
	Set tText=tText_" "_tTemp_tCRLF
	Set tText=tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateWillReceive","You'll receive a reply from FindRate within 2 business days.")_tCRLF
	Set tText=tText_$$FormatMessage^%occMessages(,"EnsDemo","FindRateThankyou","Thank you for applying with FindRate.")_tCRLF
	Quit tText
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ApplicationDefaultData</DefaultData>
<Data name="ApplicationDefaultData">
<Subscript>"Application"</Subscript>
<Value name="1">
<Value>Amount</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Nationality</Value>
</Value>
<Value name="4">
<Value>TaxID</Value>
</Value>
<Value name="5">
<Value>BusinessOperation</Value>
</Value>
<Value name="6">
<Value>Destination</Value>
</Value>
<Value name="7">
<Value>BusinessOperationType</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.Msg.Approval">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Response</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,25915.521</TimeCreated>

<Property name="BankName">
<Type>%String</Type>
</Property>

<Property name="IsApproved">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="InterestRate">
<Type>%Numeric</Type>
</Property>

<Parameter name="DOMAIN">
<Default>EnsDemo</Default>
</Parameter>

<Method name="GetText">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSessionId=$$$JobSessionId
	&sql(Select MessageBodyId into :tRecordNum from Ens.MessageHeader where ID=:tSessionId)
	If $Get(tRecordNum)="" set tRecordNum ="??"
	If ..IsApproved {
		Set tText=$$FormatMessage^%occMessages(,"EnsDemo","FindRateIsApproved3","Your loan application with record number %1 was approved at the interest rate of %2 percent.",tRecordNum,..InterestRate)_$c(13,10)
	} Else {
		Set tText=$$FormatMessage^%occMessages(,"EnsDemo","FindRateIsDenied1","Your loan application with record number %1 was denied.",tRecordNum)_$c(13,10)
	}
	Set tThank=$$FormatMessage^%occMessages(,"EnsDemo","FindRateThankyou1","Thank you for applying with %1.",..BankName)
	Quit tText_tThank_$c(13,10)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ApprovalDefaultData</DefaultData>
<Data name="ApprovalDefaultData">
<Subscript>"Approval"</Subscript>
<Value name="1">
<Value>BankName</Value>
</Value>
<Value name="2">
<Value>InterestRate</Value>
</Value>
<Value name="3">
<Value>IsApproved</Value>
</Value>
<Value name="4">
<Value>Destination</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.Msg.CreditRatingRequest">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59296,84933.272</TimeCreated>

<Parameter name="RESPONSECLASSNAME">
<Default>Demo.Loan.Msg.CreditRatingResponse</Default>
</Parameter>

<Property name="TaxID">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>CreditRatingRequestDefaultData</DefaultData>
<Data name="CreditRatingRequestDefaultData">
<Subscript>"CreditRatingRequest"</Subscript>
<Value name="1">
<Value>TaxID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.Msg.CreditRatingResponse">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Response</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59304,56321.684</TimeCreated>

<Property name="TaxID">
<Type>%String</Type>
</Property>

<Property name="CreditRating">
<Type>%Integer</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>CreditRatingResponseDefaultData</DefaultData>
<Data name="CreditRatingResponseDefaultData">
<Structure>listnode</Structure>
<Subscript>"CreditRatingResponse"</Subscript>
<Value name="1">
<Value>CreditRating</Value>
</Value>
<Value name="2">
<Value>TaxID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.Msg.PrimeRateRequest">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59296,84933.272</TimeCreated>

<Parameter name="RESPONSECLASSNAME">
<Default>Demo.Loan.Msg.PrimeRateResponse</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.Loan.Msg.PrimeRateResponse">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Response</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59304,56321.7</TimeCreated>

<Property name="PrimeRate">
<Type>%Numeric</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>PrimeRateResponseDefaultData</DefaultData>
<Data name="PrimeRateResponseDefaultData">
<Structure>listnode</Structure>
<Subscript>"PrimeRateResponse"</Subscript>
<Value name="1">
<Value>PrimeRate</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.Msg.SendReply">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59277,25915.521</TimeCreated>

<Property name="Text">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Destination">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ApprovalDefaultData</DefaultData>
<Data name="ApprovalDefaultData">
<Subscript>"Approval"</Subscript>
<Value name="1">
<Value>BankName</Value>
</Value>
<Value name="2">
<Value>InterestRate</Value>
</Value>
<Value name="3">
<Value>IsApproved</Value>
</Value>
<Value name="4">
<Value>Destination</Value>
</Value>
<Value name="5">
<Value>Text</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Loan.WebOperations">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59296,84933.182</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Parameter name="USEWEBSERVICES">
<Default>no</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
<MapItem MessageType="Demo.Loan.Msg.PrimeRateRequest">
<Method>GetPrimeRate</Method>
</MapItem>
<MapItem MessageType="Demo.Loan.Msg.CreditRatingRequest">
<Method>GetCreditRating</Method>
</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="GetPrimeRate">
<FormalSpec>pRequest:Demo.Loan.Msg.PrimeRateRequest,*pResponse:Demo.Loan.Msg.PrimeRateResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("PrimeRate requested")
	If ..#USEWEBSERVICES="yes" {
		Set tResult = ##class(Demo.WebService.FederalReserveClient).GetPrimeRate()
	} Else {
		Set tResult = 3
	}
	Set pResponse = ##class(Demo.Loan.Msg.PrimeRateResponse).%New()
	Set pResponse.PrimeRate = tResult
	$$$TRACE("value of '"_tResult_"' returned")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetCreditRating">
<FormalSpec>pRequest:Demo.Loan.Msg.CreditRatingRequest,*pResponse:Demo.Loan.Msg.CreditRatingResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("CreditRating requested for '"_pRequest.TaxID_"'")
	If ..#USEWEBSERVICES="yes" {
		Set tResult = ##class(Demo.WebService.CreditBureauClient).GetCreditRating(pRequest.TaxID)
	} Else {
		Set tResult = pRequest.TaxID#10*10
	}
	Set pResponse = ##class(Demo.Loan.Msg.CreditRatingResponse).%New()
	Set pResponse.TaxID = pRequest.TaxID
	Set pResponse.CreditRating = tResult
	$$$TRACE("value of '"_tResult_"' returned")
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Demo.REST.DirectoryOperation">
<Description>
This business operation accepts a request for Person or Employee directory services. The request specifies the action to be taken and any additional parameters needed.
Then the remote REST service is invoked using the appropriate HTTP command, URL, and JSON formatted payload.  The REST HTTP response is then parsed and the values are returned in a response object.
This demonstrates automatically and manually constructing and sending a JSON payload, and retrieving and parsing a JSON object or collection response.
It also demonstrates use of the four CRUD operations in the RESTful HTTP context: Create/PUT, Retrieve/GET, Update/POST, and Delete/DELETE.</Description>
<Super>EnsLib.REST.Operation</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59235,56913.819</TimeCreated>

<Method name="OnMessage">
<FormalSpec>pRequest:Demo.REST.DirectoryRequest,*pResponse:Demo.REST.DirectoryResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		If (pRequest.Type="") || (pRequest.Key="") || (pRequest.KeyValue="") {
			Set tSC=$$$ERROR($$$EnsErrGeneral,"Fields Type, Key and KeyValue are mandatory")
			Quit
		}
		Set tCmd=$ZConvert(pRequest.Command,"U")
		If tCmd = "GET" {
			Set tURL=..Adapter.URL_"/"_pRequest.Type_"/"_pRequest.Key_"/"_$$$URLENCODE(pRequest.KeyValue)_$S(""=pRequest.Field:"",1:"/"_pRequest.Field)
			Set tSC=..Adapter.GetURL(tURL,.tHttpResponse)
			Set:$$$ISERR(tSC)&&$IsObject(tHttpResponse)&&$IsObject(tHttpResponse.Data)&&tHttpResponse.Data.Size tSC=$$$ERROR($$$EnsErrGeneral,$$$StatusDisplayString(tSC)_":"_tHttpResponse.Data.Read())
			Set tSC1 = pRequest.NewResponse(.pResponse)  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			Set pResponse.SessionId=..%RequestHeader.SessionId
			Set pResponse.RequestURL="Get "_tURL
			Quit:$$$ISERR(tSC)
			If $$$IsdefObject(tHttpResponse)&&$IsObject(tHttpResponse.Data)&&tHttpResponse.Data.Size {
				For i=0:1:31 { Continue:$Case(i,9:1,10:1,13:1,:0)  Set tArr($I(tArr))=$C(i), tArr($I(tArr))="" } ; strip control chars from raw stream copy
				Do ##class(%IO.MetaCharacterStream).%New(tHttpResponse.Data).CopyReplaceArray(pResponse.RawResponse,,,,,,,"IO",.tSC,.tArr)
				If pRequest.KeyValue=$TR(pRequest.KeyValue,"*?") {
					Set tSC=..JSONStreamToObject(tHttpResponse.Data,.tProxy)  Quit:$$$ISERR(tSC)
					Do tProxy.%CopyToArray(.tRec)
					If $Case(pRequest.Field, "":1, "*":1, :0) {
						Do ..getPersonProps(.tRec,pResponse.Properties)
						$$$TRACE("Got "_pResponse.Properties.Count()_" property records")
					} Else {
						$$$ASSERT($G(tRec(pRequest.Key))=pRequest.KeyValue)
						Kill tRec(pRequest.Key)
						Set tVal=$G(tRec(pRequest.Field),$C(0))
						Kill tRec(pRequest.Field)
						$$$ASSERT(tVal'=$C(0)&&'$D(tRec)) ; should not have returned any other fields
						Set pResponse.Value=tVal
						$$$TRACE("Got "_pRequest.Field_" = "_tVal_" for key "_pRequest.Key)
					}
				} Else {
					Set tSC=..JSONStreamToObjectArray(tHttpResponse.Data,.tProxyArray)  Quit:$$$ISERR(tSC)
					For i=1:1:tProxyArray { Set tProxy=tProxyArray(i)
						Kill tRec
						Do tProxy.%CopyToArray(.tRec)
						If $Case(pRequest.Field, "":1, "*":1, :0) {
							Set rec=##class(%ArrayOfDataTypes).%New()
							Do ..getPersonProps(.tRec,rec)
							Do pResponse.Records.SetAt(rec,i)
						} Else {
							Set tVal=$G(tRec(pRequest.Field),$C(0))
							Kill tRec(pRequest.Field)
							$$$ASSERT(tVal'=$C(0)) ; should not have returned other fields
							Do pResponse.Properties.SetAt(pRequest.Key_"="_$S($ZCVT(pRequest.Field,"L")=$ZCVT(pRequest.Key,"L"):tVal,1:tRec(pRequest.Key))_" : "_pRequest.Field_"="_tVal,i)
						}
					}
					$$$TRACE("Got "_tProxyArray_" records")
				}
			} Else { /* Set tSC=$$$ERROR($$$EnsErrGeneral,"No response data")  Quit */ }
		} ElseIf tCmd = "POST" {
			Set tURL=..Adapter.URL_"/"_pRequest.Type_"/"_pRequest.Key_"/"_$$$URLENCODE(pRequest.KeyValue)
			Set tSC=..Adapter.PostURL(tURL,.tHttpResponse,"",pRequest.Body)
			Set:$$$ISERR(tSC)&&$IsObject(tHttpResponse)&&$IsObject(tHttpResponse.Data)&&tHttpResponse.Data.Size tSC=$$$ERROR($$$EnsErrGeneral,$$$StatusDisplayString(tSC)_":"_tHttpResponse.Data.Read())
			Set tSC1=pRequest.NewResponse(.pResponse)  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			Set pResponse.SessionId=..%RequestHeader.SessionId
			Set pResponse.RequestURL="Post "_tURL
			If $IsObject(tHttpResponse) {
				Do pResponse.RawResponse.CopyFrom(tHttpResponse.Data)  Do tHttpResponse.Data.Rewind()
				Set pResponse.Value=tHttpResponse.Data.Read() ; count
			}
			
		} ElseIf tCmd = "DELETE" {
			Set tURL=..Adapter.URL_"/"_pRequest.Type_"/"_pRequest.Key_"/"_$$$URLENCODE(pRequest.KeyValue)_$S(""=pRequest.Field:"",1:"/"_pRequest.Field)
			Set tSC=..Adapter.DeleteURL(tURL,.tHttpResponse)
			Set:$$$ISERR(tSC)&&$IsObject(tHttpResponse)&&$IsObject(tHttpResponse.Data)&&tHttpResponse.Data.Size tSC=$$$ERROR($$$EnsErrGeneral,$$$StatusDisplayString(tSC)_":"_tHttpResponse.Data.Read())
			Set tSC1=pRequest.NewResponse(.pResponse) Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1) 
			Quit:$$$ISERR(tSC)
			Set pResponse.SessionId=..%RequestHeader.SessionId
			Set pResponse.RequestURL="Delete "_tURL
			Do pResponse.RawResponse.CopyFrom(tHttpResponse.Data)  Do tHttpResponse.Data.Rewind()
			Set pResponse.Value=tHttpResponse.Data.Read() ; count

		} ElseIf tCmd = "PUT" {
			Set tURL=..Adapter.URL_"/"_pRequest.Type
			Set tSC=..Adapter.PutURL(tURL,.tHttpResponse,"",pRequest.Body)
			Set:$$$ISERR(tSC)&&$IsObject(tHttpResponse)&&$IsObject(tHttpResponse.Data)&&tHttpResponse.Data.Size tSC=$$$ERROR($$$EnsErrGeneral,$$$StatusDisplayString(tSC)_":"_tHttpResponse.Data.Read())
			Set tSC1=pRequest.NewResponse(.pResponse)  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			Quit:$$$ISERR(tSC)
			Set pResponse.SessionId=..%RequestHeader.SessionId
			Set pResponse.RequestURL="Put "_tURL
			Do pResponse.RawResponse.CopyFrom(tHttpResponse.Data)  Do tHttpResponse.Data.Rewind()
			Set pResponse.Value=tHttpResponse.Data.Read() ; ID
		} Else {
			Set tSC=$$$ERROR($$$EnsErrGeneral,"Command "_pRequest.Command_" not implemented")
		}
	} catch {
		Set tSC=$$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getPersonProps">
<Description>
copy Person properties from COS array to %ArrayOfDataTypes object, handling various data types appropriately</Description>
<FormalSpec>pArray,pCollectionObj</FormalSpec>
<Implementation><![CDATA[
	Set k="" For { Set k=$O(pArray(k),1,val)  Quit:""=k
		If '$IsObject(val) {
			Do pCollectionObj.SetAt($S($L(val)<=50:val,1:$E(val,1,47)_"..."),k) ; truncate strings longer than 50 chars
		} ElseIf $Case(k,"Spouse":1,"Company":1,:0) {
			Do pCollectionObj.SetAt(val.Name,k) ; don't drill in to nested Spouse and Company objects, just keep their name
		} ElseIf val.%Extends("%Library.ListOfDataTypes") || val.%Extends("%Library.ListOfObjects") {
			Set val2="" For j=1:1:val.Count() { Set val2=val2_","_val.GetAt(j) } ; concatenate lists of values into a single string (i.e. FavoriteColors)
			Do pCollectionObj.SetAt($E(val2,2,*),k)
		} ElseIf val.%Extends("%ZEN.proxyObject") {
			Kill tRec2  Do val.%CopyToArray(.tRec2)
			Set j="" For { Set j=$O(tRec2(j),1,val2)  Quit:""=j
				Do pCollectionObj.SetAt(val2,k_"."_j) ; unroll nested proxy object properties using a dot in the property name
			}
		} Else {
			Do pCollectionObj.SetAt(val,k) ; just store the oref string
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="Demo.REST.DirectoryPage">
<Description>
StartProduction</Description>
<IncludeCode>EnsConstants,EnsUI,Ensemble</IncludeCode>
<Super>%CSP.UI.Portal.Template</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60310,50851.071342</TimeCreated>

<Parameter name="DOMAIN">
<Default>ENSDEMO</Default>
</Parameter>

<Parameter name="RESOURCE">
<Description>
User needs USE permissions on the %Ens_MessageContent resource to view this page.</Description>
<Default>%Ens_MessageContent:USE</Default>
</Parameter>

<Parameter name="PAGENAME">
<Description>
Displayed name of this page.</Description>
<Default>Demo REST Directory Service</Default>
</Parameter>

<Parameter name="CSSINCLUDES">
<Default>ensemble/Ensemble_Wizards.css</Default>
</Parameter>

<Parameter name="AUTOLOGOUT">
<Description>
If true, then attempt to refresh this page when its session timeout period has expired.
This will cause a login page to display if the current session has ended
and security is set to require login.</Description>
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<XData name="contentPane">
<Description>
This XML block defines the contents of the page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane>
<jsonProvider id="jpResponseInfo" OnGetTargetObject="GetResponseInfo">
<parameter id="riId" paramName="responseId"/>
</jsonProvider>
<hgroup cellVAlign="top">
<pane id="paneSelect" paneName="paneSelect"/>
<spacer width="15"/>
<pane id="paneInfo" paneName="paneInfo" width="40%" />
<pane id="paneDetails" paneName="paneDetails"/>
</hgroup>
<hgroup>
<spacer width="15"/>
<vgroup>
<text name="txSession" id="txSession" label="Session ID" labelClass="labelRequired"
          title="View the Trace diagram for the REST service request and response." />
<text name="txURL" id="txURL" label="URL sent" labelClass="labelRequired" size="210" 
          title="The text of the REST service URL submitted to the server." />
<textarea name="txRawResponse" id="txRawResponse" label="Raw Response JSON" labelClass="labelRequired" height="100" width="400"
          title="The full REST / JSON response received from the server." />
</vgroup>
</hgroup>
</pane>
]]></Data>
</XData>

<XData name="paneSelect">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane xmlns="http://www.intersystems.com/zen" >
<vgroup id="mainPanel" cellAlign="center" groupClass="" enclosingClass="menuPanel"  valign="top">
<form name="fmSelect" id="fmSelect" layout="vertical" cellStyle="padding: 2px 10px; font-size:0.8em;">
<radioSet required="true" readOnly="false" hidden="false" value=""
  name="rsPersonEmployee" id="rsPersonEmployee" label="Record Type" 
  labelClass="labelRequired"  enclosingStyle="padding-bottom:4px;" 
  title="Which type of directory record to work with"
  valueList="Person,Employee" displayList="Person,Employee" originalValue="Person"
  onclick="zenPage.changeType('rsPersonEmployee');"
	/>
<hgroup>
<radioSet required="true" readOnly="false" hidden="false" value=""
  name="rsNameSSN" id="rsNameSSN" label="Retrieval Key Field" 
  labelClass="labelRequired"  enclosingStyle="padding-bottom:4px;" 
  title="Which key field to use to identify directory records"
  valueList="Name,SSN" displayList="Name,SSN" originalValue="Name"
  onclick="zenPage.changeType('rsNameSSN');"
	/>
<spacer width="10" />
<text name="txKeyVal" id="txKeyVal" label="Key Value" labelClass="labelRequired" size="21" 
          title="Enter a key value to use in identifying which directory records to work with. May contain wildcards * and ?." />
</hgroup>
<hgroup>
<radioSet required="true" readOnly="false" hidden="false" value=""
  name="rsField" id="rsField" label="Retrieve Field(s)" 
  labelClass="labelRequired"  enclosingStyle="padding-bottom:4px;" 
  title="Which field value to retrieve"
  valueList="All,Single" displayList="All,Single" originalValue="All"
  onclick="zenPage.changeType('rsField');"
	/>
<spacer width="10" />
<text name="txField" id="txField" label="Field Name" labelClass="labelRequired" size="21" hidden="true"
          title="Enter a field name to retrieve the value of (case insensitive)." />
</hgroup>
<button controlClass="commandButton" id="btnRetrieve" caption="Retrieve" onclick="zenPage.retrieveRec();"
		title="Retrieve directory records matching the above retrieval criteria" />
</form>
</vgroup>
</pane>
]]></Data>
</XData>

<XData name="paneInfo">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane>
<label name="txValue" id="txValue" label="Retrieved Value" labelClass="labelRequired" controlClass="labelRequired"
          title="Value retrieved for a single-record, single-field query." />
<html id="htmlInfo" OnDrawContent="DrawInfoTable" />
</pane>
]]></Data>
</XData>

<XData name="paneDetails">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane>
<form name="fmDetails" id="fmDetails" layout="vertical" cellStyle="padding: 2px 10px; font-size:0.8em;">
<html id="htmlDetails" OnDrawContent="DrawDetailsTable" />
<hgroup>
<button controlClass="commandButton" id="btnUpdate" caption="Update" onclick="zenPage.updateRec();"
		title="Update the current directory record using the above field values" />
<button controlClass="commandButton" id="btnDelete" caption="Delete" onclick="zenPage.deleteRec();"
		title="Delete the current directory record" />
<button controlClass="commandButton" id="btnCreate" caption="Create" onclick="zenPage.createRec();"
		title="Create a new directory record using the above field values" />
</hgroup>
</form>
</pane>
]]></Data>
</XData>

<Method name="DrawInfoTable">
<FormalSpec>pID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 &html<<table id="infoTable" border="1" style="cursor:default;visibility:hidden;" title="Click a row to select">
	<thead>
		<tr>
			<th id="infoKey">Key</th>
			<th id="infoVal">Value</th>
		</tr>
 	</thead>
 	<tbody id="infoBody">
 	</tbody>
	</table>

	<table id="recordsTable" border="1" style="cursor:default;visibility:hidden;" title="Click a row to select">
	<thead>
		<tr>
			<th id="recordsName">Name</th>
			<th id="recordsSSN">SSN</th>
		</tr>
	</thead>
	<tbody id="recordsBody">
	</tbody>
	</table>>
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawDetailsTable">
<FormalSpec>pID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 &html<<table id="detailTable" border="1">
	<thead>
		<tr>
			<th id="detailProp">Property</th>
			<th id="detailVal">Value</th>
		</tr>
	</thead>
	<tbody id="detailBody">
	</tbody>
	</table>>
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Description>
This client event, if present, is fired when the page is loaded.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('rsPersonEmployee').setValue('Person');
	zen('rsNameSSN').setValue('Name');
	zen('rsField').setValue('All');
]]></Implementation>
</Method>

<Method name="retrieveRec">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var type = zen('rsPersonEmployee').getValue();
	var key = zen('rsNameSSN').getValue();
	var val = zen('txKeyVal').getValue();
	var field = zen('txField').getValue();
	if ('All' == zen('rsField').getValue()) field='*';

	if ('' == val) { alert($$$Text('You must enter a key value. You may use wildcards * and ?.')); return }
	if ('' == field) { alert($$$Text('You must enter a field value or select "All".')); return }

	var result = zenPage.DoRetrieve(type,key,val,field);
	var parm = zen('riId');
	var ids = result.split('|');
	var id = parseInt(ids[1]);
	if (id > 0) {
		parm.value = id;
		/*zenPage.currRespId = id;
		zenPage.currType = type;
		zenPage.currKey = key;
		zenPage.currKeyVal = val;
		zenpage.currField = field;*/
	} else {
		parm.value = '';
		var err = result;
		if (err && ('' != err)) alert(err);
	}
	zenPage.refresh();
]]></Implementation>
</Method>

<Method name="updateRec">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var key = zenPage.findKey();
	if ('' == key) return;
	var keyval = key.split('=');
	var obj = zenPage.getDetailObj();
	if (!obj) return;
	var type = zen('rsPersonEmployee').getValue();
	var result = zenPage.DoUpdate(type,keyval[0],keyval[1],obj);
	var parm = zen('riId');
	var ids = result.split('|');
	var id = parseInt(ids[1]);
	var updid = parseInt(ids[0]);
	if (updid > 0) {
		parm.value = id;
		zenPage.refresh();
		alert('record '+updid+' updated');
	} else {
		parm.value = '';
		var err = result;
		if (err && ('' != err)) alert(err);
	}
]]></Implementation>
</Method>

<Method name="deleteRec">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var key = zenPage.findKey();
	if ('' == key) return;
	var keyval = key.split('=');
	var result = zenPage.DoDelete(keyval[0],keyval[1]);
	var parm = zen('riId');
	var ids = result.split('|');
	var id = parseInt(ids[1]);
	var count = parseInt(ids[0]);
	if (count > 0) {
		if (count == 1) { alert('one record deleted'); }
		else { alert(count + ' RECORDS DELETED'); }
		parm.value = id;
		zenPage.refresh();
	} else {
		parm.value = '';
		var err = result;
		if (err && ('' != err)) alert(err);
	}
]]></Implementation>
</Method>

<Method name="createRec">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var key = zenPage.findKey();
	if ('' == key) return;
	var keyval = key.split('=');
	var obj = zenPage.getDetailObj()
	if (!obj) return;
	var type = zen('rsPersonEmployee').getValue();
	// An Employee is a Person, but setting one of these properties for a Person object will cause Property error
	if ((type = "Person") && ((obj.Company) || (obj.Title) || (obj.Salary) || (obj.Notes) || (obj.Picture))){
		type = "Employee"
	}
	var result = zenPage.DoCreate(type,keyval[0],keyval[1],obj);
	var parm = zen('riId');
	var ids = result.split('|');
	var id = parseInt(ids[1]);
	var newid = parseInt(ids[0]);
	if (newid > 0) {
		parm.value = id;
		zenPage.refresh();
		alert('Create succeeded, new id=' + newid);
	} else {
		parm.value = '';
		var err = result;
		if (err && ('' != err)) alert(err);
	}
]]></Implementation>
</Method>

<Method name="getDetailObj">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var obj = new zenProxy();
	var dbod = self.document.getElementById('detailTable').children[1];
	var numProps = 0;
	for (var rownum in dbod.rows) {
		var row=dbod.rows[rownum];
		if (!row.cells)continue;
		var prop = row.cells[0].textContent;
		var val = row.cells[1].children[0].value;
		obj[prop] = val;
		numProps = numProps + 1;
	}
	if (numProps > 0) return obj;
	alert('No directory record selected');
	return null;
]]></Implementation>
</Method>

<Method name="findKey">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var dbod = self.document.getElementById('detailTable').children[1];
	if (dbod.rows.length===0) {
		alert('No record to modify.');
		return '';	
	}
	var name = '';
	for (var rownum in dbod.rows) {
		var row=dbod.rows[rownum];
		if (!row.cells) continue;
		var prop = row.cells[0].textContent;
		if (prop.toLowerCase() == 'ssn') {
			var ssn = row.cells[1].children[0].value;
			if ('' != ssn) return 'ssn='+ssn;
		}
		if (prop.toLowerCase() == 'name') {
			name = row.cells[1].children[0].value;
			if (name != '') return 'name='+name;
		}
	}
	alert('Can\'t find key in current directory record');
	return '';
]]></Implementation>
</Method>

<Method name="DoRetrieve">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,key:%String,val:%String,field:%String</FormalSpec>
<ReturnType>%ZEN.Datatype.string</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tSC = ##class(Ens.Director).CreateBusinessService("EnsLib.Testing.Service",.tService)  Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)
	Set tTestRequest = ##class(EnsLib.Testing.Request).%New()  $$$ASSERT($IsObject(tTestRequest))
	Set tTestRequest.Target = "Demo.REST.DirectoryOperation"
	Set tTestRequest.SyncCall = 1
	Set tRequest=##class(Demo.REST.DirectoryRequest).%New()
	Set tRequest.Command = "GET"
	// An Employee is a Person, but if don't look in Employee data, will get Property error for these properties
	Set:$Case(field,"Company":1,"Title":1,"Salary":1,"Notes":1,"Picture":1,:0) type = "Employee"
	Set tRequest.Type = $ZConvert(type,"L")
	Set tRequest.Key = $ZConvert(key,"L")
	Set tRequest.KeyValue = val
	Set tRequest.Field = $S("*"=field:"",1:field)
	Set tTestRequest.Request = tRequest
	Set tSC = tService.ProcessInput(tTestRequest,.tResponse)
	Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)

	#; display response
	Quit $S($$$IsdefObject(tResponse):1_"|"_tResponse.%Id(),1:"No Response from Demo.REST.DirectoryOperation GET")
]]></Implementation>
</Method>

<Method name="DoUpdate">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,key:%String,val:%String,obj:%ZEN.proxyObject</FormalSpec>
<ReturnType>%ZEN.Datatype.string</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tSC = ##class(Ens.Director).CreateBusinessService("EnsLib.Testing.Service",.tService)  Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)
	Set tTestRequest = ##class(EnsLib.Testing.Request).%New()  $$$ASSERT($IsObject(tTestRequest))
	Set tTestRequest.Target = "Demo.REST.DirectoryOperation"
	Set tTestRequest.SyncCall = 1
	Set tRequest=##class(Demo.REST.DirectoryRequest).%New()
	Set tRequest.Command = "POST"
	Set tRequest.Type = $ZConvert(type,"L")
	Set tRequest.Key = $ZConvert(key,"L")
	Set tRequest.KeyValue = val
	Set tSC=##class(Ens.Util.JSON).ObjectToJSONStream(obj,tRequest.Body)
	If $$$ISOK(tSC) {
		Set tTestRequest.Request = tRequest
		Set tSC = tService.ProcessInput(tTestRequest,.tResponse)
	}
	Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)

	#; display response
	Quit $S($$$IsdefObject(tResponse):tResponse.Value_"|"_tResponse.%Id(),1:"No Response from Demo.REST.DirectoryOperation POST")
]]></Implementation>
</Method>

<Method name="DoDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,val:%String</FormalSpec>
<ReturnType>%ZEN.Datatype.string</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tSC = ##class(Ens.Director).CreateBusinessService("EnsLib.Testing.Service",.tService)  Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)
	Set tTestRequest = ##class(EnsLib.Testing.Request).%New()  $$$ASSERT($IsObject(tTestRequest))
	Set tTestRequest.Target = "Demo.REST.DirectoryOperation"
	Set tTestRequest.SyncCall = 1
	Set tRequest=##class(Demo.REST.DirectoryRequest).%New()
	Set tRequest.Command = "DELETE"
	Set tRequest.Type = "person"
	Set tRequest.Key = $ZConvert(key,"L")
	Set tRequest.KeyValue = val
	Set tTestRequest.Request = tRequest
	Set tSC = tService.ProcessInput(tTestRequest,.tResponse)
	Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)

	#; display response
	Quit $S($$$IsdefObject(tResponse):tResponse.Value_"|"_tResponse.%Id(),1:"No Response from Demo.REST.DirectoryOperation DELETE")
]]></Implementation>
</Method>

<Method name="DoCreate">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,key:%String,keyvalue:%String,obj:%ZEN.proxyObject</FormalSpec>
<ReturnType>%ZEN.Datatype.string</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tSC = ##class(Ens.Director).CreateBusinessService("EnsLib.Testing.Service",.tService)  Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)
	Set tTestRequest = ##class(EnsLib.Testing.Request).%New()  $$$ASSERT($IsObject(tTestRequest))
	Set tTestRequest.Target = "Demo.REST.DirectoryOperation"
	Set tTestRequest.SyncCall = 1
	Set tRequest=##class(Demo.REST.DirectoryRequest).%New()
	Set tRequest.Command = "PUT"
	Set tRequest.Type = $ZConvert(type,"L")
	Set tRequest.Key = key
	Set tRequest.KeyValue = keyvalue
	Set tSC=##class(Ens.Util.JSON).ObjectToJSONStream(obj,tRequest.Body)
	If $$$ISOK(tSC) {
		Set tTestRequest.Request = tRequest
		Set tSC = tService.ProcessInput(tTestRequest,.tResponse)
	}
	Quit:$$$ISERR(tSC) $$$StatusDisplayString(tSC)

	#; display response
	Quit $S($$$IsdefObject(tResponse):tResponse.Value_"|"_tResponse.%Id(),1:"No Response from Demo.REST.DirectoryOperation PUT")
]]></Implementation>
</Method>

<Method name="refresh">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var json = this.getComponentById('jpResponseInfo');
	json.reloadContents();
	var resp = json.getContentObject();
	var ctl;
	ctl = zen('txURL');
	ctl.setValue(resp ? resp.RequestURL : '');

	ctl = zen('txRawResponse');
	ctl.setValue(resp ? resp.RawResponse : '');

	var ctl=zen('txValue')
	ctl.setValue(resp ? resp.Value : '');

	var records = '';
	var rows = '';
	var i = 0;
	if (resp) {
		var showing = this.getComponentById('rsField').getValue();
		for (var prop in resp.Properties) {
			i = i + 1;
			if (showing == "All") {
				var val = resp.Properties[prop];
				rows = rows+'<tr onclick="zenPage.propClick(\''+prop+'\');"><td>'+prop+'</td><td>'+val+'</td></tr>';
			} else {
				var parts = resp.Properties[prop].split(':');
				var key = parts[0];
				parts[0] = null;
				rows = rows+'<tr onclick="zenPage.propClick(\''+prop+'\');"><td>'+key+'</td><td>'+parts.join(':')+'</td></tr>';
			}
		}

		for (var num in resp.Records) {
			var rec = resp.Records[num];
			records = records+'<tr onclick="zenPage.recClick(\''+num+'\');"><td>'+rec.Name+'</td><td>'+rec.SSN+'</td></tr>';
		}
	}
	ctl.setHidden(rows != '' || records != '');
	self.document.getElementById('infoTable').style.visibility = (rows == '') ? "hidden" : "visible";
	self.document.getElementById('recordsTable').style.visibility = (records == '') ? "hidden" : "visible";

	var bod = self.document.getElementById('infoTable').children[1];
	zenPage.setInnerHTML(bod,rows);

	var bod2 = self.document.getElementById('recordsTable').children[1];
	zenPage.setInnerHTML(bod2, records);

	var sctl = zen('txSession');
	sctl.setValue(resp ? resp.SessionId : '');
	//Set ..%GetComponentById("lblSessionId").value = "<b>"_$$$Text("Session Id:")_"</b> "_tSessionId_" &nbsp;&nbsp;<a href=""#"" class=""ribbonSortOption"" style=""font-size:10pt"" onClick=""zenPage.launchPopupWindow(zenLink('EnsPortal.VisualTrace.zen?SESSIONID="_tSessionId_"'),'Trace','status=no,scrollbars=auto,resizable=yes,top=200,left=200,width=1000,height=800');"" title="""_$$$Text("Display the Visual Trace diagram for this REST service invocation")_""">"_$$$Text("Visual Trace")_"</a>"

	var dbod = self.document.getElementById('detailTable').children[1];
	zenPage.setInnerHTML(dbod,'');
]]></Implementation>
</Method>

<Method name="setInnerHTML">
<Description>
Allow innerHTML value to be edited even in IE</Description>
<FormalSpec>body,html</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var temp = document.createElement('div');
	temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
	body.parentNode.replaceChild(temp.firstChild.firstChild, body);
]]></Implementation>
</Method>

<Method name="propClick">
<FormalSpec>prop</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var json = this.getComponentById('jpResponseInfo');
	var resp = json.getContentObject();
	var rows='';
	if (parseInt(prop) == prop) {
		var parts = resp.Properties[prop].split(':');
		var key = parts[0];
		var vals;
		vals = key.split('=');
		rows = rows+'<tr><td>'+vals[0]+'</td><td><input type="text" value=\''+vals[1]+'\'/></td></tr>';
		vals = parts[1].split('=');
		rows = rows+'<tr><td>'+vals[0]+'</td><td><input type="text" value=\''+vals[1]+'\'/></td></tr>';
	}
	else {
		var val;
		val = resp.Properties[prop];
		rows = rows+'<tr><td>'+prop+'</td><td><input type="text" value=\''+val+'\'/></td></tr>';
	}
	var bod = self.document.getElementById('detailTable').children[1];
	zenPage.setInnerHTML(bod,rows);
]]></Implementation>
</Method>

<Method name="recClick">
<FormalSpec>num</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var json = this.getComponentById('jpResponseInfo');
	var resp = json.getContentObject();
	var rows='';
	var rec = resp.Records[num];
	for (var prop in rec) {
		if ('_' == prop[0]) continue;
		rows = rows+'<tr><td>'+prop+'</td><td><input type="text" value=\''+rec[prop]+'\'/></td></tr>';
	}
	var bod = self.document.getElementById('detailTable').children[1];
	zenPage.setInnerHTML(bod,rows);
]]></Implementation>
</Method>

<Method name="GetResponseInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pObj]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, pObj=$$$NULLOREF
	try {
		Set tResponseId = $G(pParameters("responseId"))
		If tResponseId {
			Set pObj=##class(Demo.REST.DirectoryResponse).%OpenId(tResponseId,,.tSC)  Quit:$$$ISERR(tSC)
		}
	} catch {
		Set tSC = $$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="changeType">
<Description>
What to do when the user selects a new radio button value.</Description>
<FormalSpec>id</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var ctl = zen(id);
	var val = ctl.getValue();
	if (id == 'rsField') {
		var tx = zen('txField');
		tx.setHidden((val=='All') ? 1 : 0);
	}
]]></Implementation>
</Method>

<Method name="%OnGetTitle">
<Description>
Get the (localized) title string for the page.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%OnGetPageName()
]]></Implementation>
</Method>

<Method name="%OnGetPageName">
<Description>
Get the (localized) name of the page.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set txt = $$$Text(..#PAGENAME)
	Quit txt
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description>
Decorate the page.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ##super()
	
	Set tSC = $$$OK
	
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.REST.DirectoryRequest">
<IncludeCode>Ensemble</IncludeCode>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>62675,45979.493591</TimeChanged>
<TimeCreated>62636,28344.589637</TimeCreated>

<Parameter name="RESPONSECLASSNAME">
<Default>Demo.REST.DirectoryResponse</Default>
</Parameter>

<Property name="Command">
<Type>%String</Type>
<InitialExpression>"GET"</InitialExpression>
</Property>

<Property name="Type">
<Type>%String</Type>
<InitialExpression>"person"</InitialExpression>
</Property>

<Property name="Key">
<Type>%String</Type>
<InitialExpression>"name"</InitialExpression>
</Property>

<Property name="KeyValue">
<Type>%String</Type>
</Property>

<Property name="Field">
<Type>%String</Type>
</Property>

<Property name="Body">
<Description>
For JSON content submission</Description>
<Type>%GlobalCharacterStream</Type>
</Property>

<Method name="NewResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set pResponse = $classmethod(..#RESPONSECLASSNAME,"%New")  Set tSC=$S($IsObject(pResponse):$$$OK, 1:%objlasterror)
	} catch {
		Set tSC=$$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.REST.DirectoryRequestD</DataLocation>
<DefaultData>DirectoryRequestDefaultData</DefaultData>
<IdLocation>^Demo.REST.DirectoryRequestD</IdLocation>
<IndexLocation>^Demo.REST.DirectoryRequestI</IndexLocation>
<StreamLocation>^Demo.REST.DirectoryRequestS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="DirectoryRequestDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Command</Value>
</Value>
<Value name="3">
<Value>Type</Value>
</Value>
<Value name="4">
<Value>Key</Value>
</Value>
<Value name="5">
<Value>KeyValue</Value>
</Value>
<Value name="6">
<Value>Field</Value>
</Value>
<Value name="7">
<Value>Body</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.REST.DirectoryResponse">
<IncludeCode>Ensemble</IncludeCode>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>62648,58777</TimeChanged>
<TimeCreated>62636,28360.099318</TimeCreated>

<Property name="Value">
<Description>
Single result value</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Properties">
<Description>
Single record properties or list of records' single values</Description>
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN"/>
<Parameter name="XMLITEMNAME" value="Value"/>
<Parameter name="XMLKEYNAME" value="Key"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Records">
<Description>
Array of records' properties</Description>
<Type>%ArrayOfDataTypes</Type>
<Collection>array</Collection>
<Parameter name="XMLITEMNAME" value="Record"/>
<Parameter name="XMLKEYNAME" value="num"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="RequestURL">
<Description>
For the record: submitted Request URL</Description>
<Type>%String</Type>
<Internal>1</Internal>
<Parameter name="MAXLEN"/>
</Property>

<Property name="RawResponse">
<Description>
For the record: raw HTTP response body resulting from request URL</Description>
<Type>%Stream.GlobalCharacter</Type>
<Internal>1</Internal>
</Property>

<Property name="SessionId">
<Description>
For the record: ID of the session used to retrieve this response</Description>
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.REST.DirectoryResponseD</DataLocation>
<DefaultData>DirectoryResponseDefaultData</DefaultData>
<IdLocation>^Demo.REST.DirectoryResponseD</IdLocation>
<IndexLocation>^Demo.REST.DirectoryResponseI</IndexLocation>
<StreamLocation>^Demo.REST.DirectoryResponseS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="DirectoryResponseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Values</Value>
</Value>
<Value name="3">
<Value>Objects</Value>
</Value>
<Value name="4">
<Value>Value</Value>
</Value>
<Value name="5">
<Value>RequestURL</Value>
</Value>
<Value name="6">
<Value>RawResponse</Value>
</Value>
<Value name="7">
<Value>SessionId</Value>
</Value>
</Data>
<Data name="Properties">
<Attribute>Properties</Attribute>
<Structure>subnode</Structure>
<Subscript>"Properties"</Subscript>
</Data>
<Data name="Records">
<Attribute>Records</Attribute>
<Structure>subnode</Structure>
<Subscript>"Records"</Subscript>
</Data>
</Storage>
</Class>


<Class name="Demo.REST.DirectoryService">
<Description>
This is a sample REST service implementing a directory of Person and Employee records. Not every Person is an Employee.
The CRUD (Create,Retrieve,Update,Delete) interface is implemented via the REST/HTTP commands PUT,GET,POST,and DELETE respectively.
Records of interest may be retrieved via type and key fields "name" and "ssn".  Wildcards containing * and ? are supported.
The resulting HTTP body of a successful GET query may be a partially or fully populated JSON object, depending on the field requested, or a JSON array of such JSON objects if a wildcard was used.
Example REST URLs:
GET /directory/employee/name/Q*/salary
GET /directory/employee/name/Quentin, Fred A.
GET /directory/employee/ssn/123-45-6789/*</Description>
<Super>EnsLib.REST.Service</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62538,45933.322065</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.HTTP.InboundAdapter</Default>
</Parameter>

<XData name="UrlMap">
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/:personType" Method="PUT" Call="createPerson"/>
<Route Url="/:personType/:keyfield/:keyval/:getfield" Method="GET" Call="retrievePerson"/>
<Route Url="/:personType/:keyfield/:keyval" Method="GET" Call="retrievePerson"/>
<Route Url="/:personType/:keyfield/:keyval" Method="POST" Call="updatePerson"/>
<Route Url="/:personType/:keyfield/:keyval" Method="DELETE" Call="deletePerson"/>
</Routes>
]]></Data>
</XData>

<Parameter name="EnsServicePrefix">
<Default>|directory</Default>
</Parameter>

<Method name="createPerson">
<Description>
Create or replace</Description>
<FormalSpec>pInput:%Library.AbstractStream,*pOutput:%Stream.Object,pPersonType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tType=$ZConvert(pPersonType,"L")  Quit:$Case(tType,"employee":0, "person":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory type "_..#EnsServicePrefix_"/"_tType_"/ not supported.")
	Set $E(tType)=$ZConvert($E(tType),"U")
	Set tNS=$Namespace

	Set tSC=..JSONStreamToObject(pInput,.tProxy) Quit:$$$ISERR(tSC) tSC
	Do tProxy.%CopyToArray(.tRec)
	ZNSpace "SAMPLES"
	try {
		Set tObj=$classmethod("Sample."_tType,"%New")  Quit:$$$ISERR(tSC)
		Set tSC=..updateObject(tObj,.tRec)  Quit:$$$ISERR(tSC)
		Set tSC=tObj.%Save()  Quit:$$$ISERR(tSC)
		Set tID=tObj.%Id()
		Kill tRS
		ZNSpace tNS
		Do pOutput.Write(tID)
	} catch {
		Kill tRS
		ZNSpace tNS
		Set tSC=$$$SystemError
	}
	Kill tRS
	ZNSpace tNS

	// return 201 if successfully created
	Do:$$$ISOK(tSC) pOutput.SetAttribute("ResponseCode","201 Created")
	Quit tSC
]]></Implementation>
</Method>

<Method name="retrievePerson">
<Description>
Retrieve</Description>
<FormalSpec>pInput:%Library.AbstractStream,*pOutput:%Stream.Object,pPersonType:%String,pKeyField:%String,pKeyVal:%String,pGetField:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tType=$ZConvert(pPersonType,"L")  Quit:$Case(tType,"employee":0, "person":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory type "_..#EnsServicePrefix_"/"_tType_"/ not supported.")
	Set $E(tType)=$ZConvert($E(tType),"U")
	Set tKeyIn=pKeyField, tKey=$ZConvert(tKeyIn,"L")  Quit:$Case(tKey,"name":0, "ssn":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory key "_..#EnsServicePrefix_"/"_tType_"/"_tKey_" not supported.")
	Set tKeyVal=$Replace($ZConvert(pKeyVal,"I","URL"),"'","''")
	Set tField=pGetField  Set:""=tField tField="*"  Quit:tField["," $$$ERROR($$$EnsErrGeneral,"Commas not allowed in selection field; found: .../"_tField)
	Set tNS=$Namespace

	Set tKeyWild=$Translate(pKeyVal,"*?","%_")
	Do:tKeyWild'=pKeyVal pOutput.Write("[")
	ZNSpace "SAMPLES"
	try {
		Set tSel=$S("*"=tField:"ID",1:tField)
		Set tSQL="SELECT "_tSel_$S("*"=tField||(tKey=tSel):"", 1:","_tKey)_$Case("ID",tKey:"",tSel:"",:",ID")_" FROM Sample."_tType_" WHERE "_tKey_" LIKE '"_tKeyWild_"'"
		Set tRS=##class(%ResultSet).%New()
		Set tSC=tRS.Prepare(tSQL)  Quit:$$$ISERR(tSC)
		Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
		Set tFirst=1
		Set tOut=##class(%IO.StringStream).%New()
		While tRS.Next(.tSC) && $$$ISOK(tSC) {
			#; first normalize the case of the key and sel property names
			If tFirst {
				Set k="" For { Set k=$O(tRS.Data(k))  Quit:""=k
					If $ZConvert(k,"L")=$Zconvert(tSel,"L") Set tSelN=k
					If $ZConvert(k,"L")=$Zconvert(tKey,"L") Set tKeyN=k
				}
			}
			If $Case(tSelN, "Company":1, "Notes":1, "Home":1, "Office":1, :0) {
				Set tVal=tRS.Data("ID")
				Set tObj=$classmethod("Sample."_tType,"%OpenId",tVal,,.tSC)  Quit:$$$ISERR(tSC)
				Set tVal=$property(tObj,tSelN)
				Set tSelX = $Case(tSelN, "Home":"Addr", "Office":"Addr", :tSelN)
				Set tVal=$Case(tSelX, "Company":tVal.Name, "Notes":tVal.Read(), "Addr":tVal.Street_", "_tVal.City_" "_tVal.State_" "_tVal.Zip, :tVal)
			} Else {
				Set tVal=tRS.Data(tSelN)
			}
			If "*"=tField {
				Set tObj=$classmethod("Sample."_tType,"%OpenId",tVal,,.tSC)  Quit:$$$ISERR(tSC)
				Set tProxyObj=..buildProxyObj(tObj)
				Do tOut.Write($S(tFirst:"",1:","))
				Set tSC=..ObjectToJSONStream(tProxyObj,.tOut)
			} Else {
				Set:tKeyN'=tSelN tKeyFound=tRS.Data(tKeyN)
				Do tOut.Write($S(tFirst:"",1:",")_"{"_$S(tKeyN=tSelN:"",1:""""_tKeyIn_""":"""_tKeyFound_""", ")_""""_tSel_""":"""_tVal_"""}"_$C(13,10))
			}
			Set tFirst=0
			ZNSpace tNS
			Do tOut.Rewind()  Set tSC1=pOutput.Write(tOut.Read())  Do tOut.Clear()  Set:$$$ISOK(tSC) tSC=tSC1  Quit:$$$ISERR(tSC)
			ZNSpace "SAMPLES"
		} Quit:$$$ISERR(tSC)
		Do:tKeyWild'=tKeyVal pOutput.Write("]"_$C(13,10))
	} catch {
		Kill tRS
		ZNSpace tNS
		Set tSC=$$$SystemError
	}
	Kill tRS
	ZNSpace tNS
	Do:$$$ISOK(tSC) pOutput.SetAttribute("Content-Type","application/json")
	Quit tSC
]]></Implementation>
</Method>

<Method name="updatePerson">
<Description>
Update: For given service, replaces primary Person or Person with given name</Description>
<FormalSpec>pInput:%Library.AbstractStream,*pOutput:%Stream.Object,pPersonType:%String,pKeyField:%String,pKeyVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tType=$ZConvert(pPersonType,"L")  Quit:$Case(tType,"employee":0, "person":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory type "_..#EnsServicePrefix_"/"_tType_"/ not supported.")
	Set $E(tType)=$ZConvert($E(tType),"U")
	Set tKeyIn=pKeyField, tKey=$ZConvert(tKeyIn,"L")  Quit:$Case(tKey,"name":0, "ssn":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory key "_..#EnsServicePrefix_"/"_tType_"/"_tKey_" not supported.")
	Set tKeyVal=$Replace($ZConvert(pKeyVal,"I","URL"),"'","''")
	Set tNS=$Namespace

	Set tSC=..JSONStreamToObject(pInput,.tProxy) Quit:$$$ISERR(tSC) tSC
	Do tProxy.%CopyToArray(.tRec)
	ZNSpace "SAMPLES"
	try {
		Set tSQL="SELECT ID FROM Sample."_tType_" WHERE "_tKey_" = '"_tKeyVal_"'"
		Set tRS=##class(%ResultSet).%New()
		Set tSC=tRS.Prepare(tSQL)  Quit:$$$ISERR(tSC)
		Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
		If 'tRS.Next(.tSC) || $$$ISERR(tSC) Set:$$$ISOK(tSC) tSC=$$$ERROR($$$EnsErrGeneral,"No "_tType_" record found with key field "_tKey_" = '"_tKeyVal_"'")  Quit

		Set tID=tRS.Data("ID")
		If +tID'=tID Set tSC=$$$ERROR($$$EnsErrGeneral,"No "_tType_" ID found for key field "_tKey_" = '"_tKeyVal_"'")  Quit
		Kill tRS

		Set tObj=$classmethod("Sample."_tType,"%OpenId",tID,,.tSC)  Quit:$$$ISERR(tSC)
		Set tSC=..updateObject(tObj,.tRec,tKey,tKeyVal)  Quit:$$$ISERR(tSC)
		Set tSC=$method(tObj,"%Save")  Quit:$$$ISERR(tSC)

		Kill tRS
		ZNSpace tNS
		Do pOutput.Write(tID)
	} catch {
		Kill tRS
		ZNSpace tNS
		Set tSC=$$$SystemError
	}
	Kill tRS
	ZNSpace tNS
	Do:$$$ISOK(tSC) pOutput.SetAttribute("Content-Type","application/json")
	Quit tSC
]]></Implementation>
</Method>

<Method name="deletePerson">
<FormalSpec>pInput:%Library.AbstractStream,*pOutput:%Stream.Object,pPersonType:%String,pKeyField:%String,pKeyVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tType=$ZConvert(pPersonType,"L")  Quit:$Case(tType,"employee":0, "person":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory type "_..#EnsServicePrefix_"/"_tType_"/ not supported.")
	Set $E(tType)=$ZConvert($E(tType),"U")
	Set tKeyIn=pKeyField, tKey=$ZConvert(tKeyIn,"L")  Quit:$Case(tKey,"name":0, "ssn":0, :1) $$$ERROR($$$EnsErrGeneral,"Directory key "_..#EnsServicePrefix_"/"_tType_"/"_tKey_" not supported.")
	Set tKeyVal=$Replace($ZConvert(pKeyVal,"I","URL"),"'","''")
	Set tNS=$Namespace

	ZNSpace "SAMPLES"
	try {
		Set tSQL="DELETE FROM Sample."_tType_" WHERE "_tKey_" = '"_tKeyVal_"'"
		Set tRS=##class(%ResultSet).%New()
		Set tSC=tRS.Prepare(tSQL)  Quit:$$$ISERR(tSC)
		Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
		Set tRowCount=tRS.%ROWCOUNT
		Kill tRS
		ZNSpace tNS
		Do pOutput.Write(tRowCount)
	} catch {
		Kill tRS
		ZNSpace tNS
		Set tSC=$$$SystemError
	}
	Kill tRS
	ZNSpace tNS

	// return 204 if successfully deleted
	Do:$$$ISOK(tSC) pOutput.SetAttribute("ResponseCode","204 No Content")
	Quit tSC
]]></Implementation>
</Method>

<Method name="updateObject">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pArray,pKeyField:%String="",pKeyVal="xxx"]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, tDOB=0, tAge=0, tHasKey=0, tKFU=$ZCVT(pKeyVal,"U")
	Set prop="" For { Set tVal="" Set prop=$O(pArray(prop),1,tVal)  Quit:""=prop  Set propU=$ZConvert(prop,"U")
		If propU=pKeyField && (tKFU'=tVal) Set tSC=$$$ERROR($$$EnsErrGeneral,"Attempt to assign key value "_pKeyField_" ='"_tVal_"' where existing value = '"_pKeyVal_"'")  Quit
		Set:$Case(propU,"SSN":""'=tVal,"NAME":""'=tVal,:0) tHasKey=tHasKey+1
		Set:0=tAge&&("AGE"=propU) tAge=tVal
		Continue:$Case(propU,"ID":1,"AGE":1,:("_"=$E(prop)))
		If propU="COMPANY" {
			If ""=tVal {
				Set tCo=$$$NULLOREF
			} Else {
				&sql()
				Set tSQL="SELECT ID FROM Sample.Company WHERE Name = '"_tVal_"'"
				Set tRS=##class(%ResultSet).%New()
				Set tSC=tRS.Prepare(tSQL)  Quit:$$$ISERR(tSC)
				Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
				If 'tRS.Next(.tSC) || $$$ISERR(tSC) Set:$$$ISOK(tSC) tSC=$$$ERROR($$$EnsErrGeneral,"No company found named '"_tVal_"'")  Quit
				Set tCoID=tRS.Data("ID")
				Set tCo=##class(Sample.Company).%OpenId(tCoID)
				If '$IsObject(tCo) Set tSC=$$$ERROR($$$EnsErrGeneral,"Couldn't open Company object '"_tVal_"' with ID="_tCoID)  Quit
			}
			Set pObj.Company=tCo
			Kill tCo
		} ElseIf propU="SPOUSE" {
			If ""=tVal {
				Set tSpouse=$$$NULLOREF
			} Else {
				&sql()
				Set tSQL="SELECT ID FROM Sample.Person WHERE Name = '"_tVal_"'"
				Set tRS=##class(%ResultSet).%New()
				Set tSC=tRS.Prepare(tSQL)  Quit:$$$ISERR(tSC)
				Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
				If 'tRS.Next(.tSC) || $$$ISERR(tSC) Set:$$$ISOK(tSC) tSC=$$$ERROR($$$EnsErrGeneral,"No spouse person found named '"_tVal_"'")  Quit
				Set tSpouseID=tRS.Data("ID")
				Set tSpouse=##class(Sample.Person).%OpenId(tSpouseID)
				If '$IsObject(tSpouse) Set tSC=$$$ERROR($$$EnsErrGeneral,"Couldn't open spouse Person object '"_tVal_"' with ID="_tSpouseID)  Quit
			}
			Set pObj.Spouse=tSpouse
			Kill tSpouse
		} ElseIf propU="NOTES" {
			Set tStream=$property(pObj,prop)
			Do tStream.Clear()
			Set tSC=tStream.Write(tVal)
		} ElseIf prop["." {
			Set tChild=$property(pObj,$P(prop,"."))
			If $IsObject(tChild) Set $property(tChild,$P(prop,".",2))=tVal
		} Else {
			Set:0=tDOB&&("DOB"=propU) tDOB=1, tVal=$P($ZDTH(tVal,3),",")
			Set $property(pObj,prop)=tVal
		}
	}
	Quit:""=pKeyField&&(tHasKey<2) $$$ERROR($$$EnsErrGeneral,"Can't create object unless Name and SSN fields have values")
	Set:tAge&&(0=tDOB) pObj.DOB=($P($H,",")-(tAge*365))
	Quit tSC
]]></Implementation>
</Method>

<Method name="buildProxyObj">
<Description>
Normalize the Person or Employee info by copying its properties to a proxy object in a selective way</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pObj:%Persistent</FormalSpec>
<Implementation><![CDATA[
	Set tProxy = ##class(%ZEN.proxyObject).%New()
	Set tProxy.ID=pObj.%Id()
	Set tProxy.Name=pObj.Name
	Set tProxy.Age=pObj.Age
	Set tProxy.DOB=$ZDateTime(pObj.DOB,3)
	Set tProxy.SSN=pObj.SSN
	Set tProxy.FavoriteColors=pObj.FavoriteColors
	Set tProxy.Spouse=pObj.Spouse.Name
	Set tProxy.Home=..buildProxyAddr(pObj.Home)
	Set tProxy.Office=..buildProxyAddr(pObj.Office)
	If pObj.%IsA("Sample.Employee") {
		Set tProxy.Company=pObj.Company.Name
		Set tProxy.Notes=$S($IsObject(pObj.Notes):pObj.Notes.Read(),1:"")
	}
	Quit tProxy
]]></Implementation>
</Method>

<Method name="buildProxyAddr">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pObj:%SerialObject</FormalSpec>
<Implementation><![CDATA[
	Set tProxy = ##class(%ZEN.proxyObject).%New()
	Set tProxy.Street=pObj.Street
	Set tProxy.City=pObj.City
	Set tProxy.State=pObj.State
	Set tProxy.Zip=pObj.Zip
	Quit tProxy
]]></Implementation>
</Method>

<Method name="OnErrorStream">
<Description>
Control the type and content of error returned to the REST caller</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStatus:%Status</FormalSpec>
<Implementation><![CDATA[
 	Set tStream = ##class(%GlobalBinaryStream).%New()  $$$ASSERT($IsObject(tStream))
	Do tStream.Write($ZConvert($$$StatusDisplayString(pStatus)_$C(13,10),"O","UTF8"))
	Set tStream.Attributes("Content-Type")=" text/plain; charset=""UTF-8"""
	Set tStream.Attributes("ResponseCode")="500 Internal Server Error"
 	Quit tStream
]]></Implementation>
</Method>
</Class>


<Class name="Demo.REST.MathService">
<Description><![CDATA[
Simple REST Service in Ensemble  

It is a Math service with a RESTful interface returning JSON:		/sum/2/3  =>  { "Sum" : 5 }

There are two ways to call this REST interface. You can test both ways using a Browser: 

1) Calling the adapter port directly

		http://IP:AdapterPort/sum/2/3

2) Or using the CSP Gateway mechanism. In order for this way to work, a web application has to be created first.
	   For example, create a new web app with the following minimum parameters:  
		Web App Name = /rest
		Namespace = yourNamespace
		Dispatch class = EnsLib.REST.Service

		http://IP:WebServerPort/rest/servicename/sum/2/3
]]></Description>
<Super>EnsLib.REST.Service</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63211,41324.236163</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.HTTP.InboundAdapter</Default>
</Parameter>

<Parameter name="EnsServicePrefix">
<Default>|sum</Default>
</Parameter>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
<Route Url="/:number1/:number2" Method="GET" Call="Sum"/>
</Routes>
]]></Data>
</XData>

<Method name="Sum">
<Description>

This method returns the sum of pnumber1 and pnumber2
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInput:%Library.AbstractStream,*pOutput:%Stream.Object,pnumber1:%Integer,pnumber2:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status = $$$OK
	try{
 		// Do whatever you need to do and get back an object
 		set result = pnumber1 + pnumber2
 		set tProxy = ##class(%ZEN.proxyObject).%New()
 		set tProxy.Sum = result
 		
 		// You could just write the output manually or use helper methods like ..ObjectToJSONStream() to generate JSON
 		do pOutput.SetAttribute("Content-Type","application/json")
 		do pOutput.Write("[")
 		
 		Set tOut=##class(%IO.StringStream).%New()
 		do ..ObjectToJSONStream(tProxy,.tOut)	
 		
 		do tOut.Rewind()
 		do pOutput.Write( tOut.Read() )
 		do pOutput.Write("]"_$C(13,10))
 		
	} catch (e) {
		set status = e.AsStatus()
	}
      quit status
]]></Implementation>
</Method>
</Class>


<Class name="Demo.REST.Production">
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62636,62570.295692</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.REST.Production" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Demo.REST.DirectoryService" Category="" ClassName="Demo.REST.DirectoryService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Adapter" Name="Port">9988</Setting>
    <Setting Target="Adapter" Name="JobPerConnection">0</Setting>
    <Setting Target="Adapter" Name="SSLConfig"></Setting>
  </Item>
  <Item Name="Demo.REST.DirectoryOperation" Category="" ClassName="Demo.REST.DirectoryOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Adapter" Name="HTTPPort">9988</Setting>
    <Setting Target="Adapter" Name="HTTPServer">localhost</Setting>
    <Setting Target="Adapter" Name="URL">/directory</Setting>
    <Setting Target="Adapter" Name="SSLConfig"></Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.RecordMap.Map.Delimited.Batch">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Demo.RecordMap.Map.Delimited'
on 2010-09-30 at 16:20:02.221 [2010-09-30 21:20:02.221 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Library.Persistent,EnsLib.RecordMap.SimpleBatch</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61999,62243.228569</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="XMLTYPE">
<Default>Demo_RecordMap_Map_Delimited_Batch</Default>
</Parameter>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="BatchHeader">
<Default>DELIMITED_BATCH_HEADER</Default>
</Parameter>

<Parameter name="HeaderTerm">
<Default>\x0d\x0a</Default>
</Parameter>

<Parameter name="BatchTrailer">
</Parameter>

<Parameter name="TrailerTerm">
<Default>\x0d\x0a\x00</Default>
</Parameter>

<Property name="Records">
<Type>Demo.RecordMap.Map.Delimited.Record</Type>
<Cardinality>many</Cardinality>
<Inverse>%ParentBatch</Inverse>
<Relationship>1</Relationship>
</Property>

<Trigger name="OnDelete">
<Code>	Set id = {ID}
	Set %ok = ..deleteRecords(id)</Code>
<Event>DELETE</Event>
</Trigger>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tID = $$$oidPrimary(oid)
	Quit ..deleteRecords(tID)
]]></Implementation>
</Method>

<Method name="deleteRecords">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>batchid:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tStmt = ##class(%SQL.Statement).%New()
	Set tStatus = tStmt.%Prepare("DELETE FROM Demo_RecordMap_Map_Delimited.Record WHERE %ParentBatch = ?")
	If $$$ISERR(tStatus) Quit tStatus
	Set tRS = tStmt.%Execute(batchid)
	If tRS.%SQLCODE && (tRS.%SQLCODE '= 100) Quit $$$ERROR($$$SQLCode, tRS.%SQLCODE, tRS.%Message)
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMap.Map.DC0CE.BatchD</DataLocation>
<DefaultData>BatchDefaultData</DefaultData>
<IdLocation>^Demo.RecordMap.Map.DC0CE.BatchD</IdLocation>
<IndexLocation>^Demo.RecordMap.Map.DC0CE.BatchI</IndexLocation>
<StreamLocation>^Demo.RecordMap.Map.DC0CE.BatchS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="BatchDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Source</Value>
</Value>
<Value name="3">
<Value>BatchHeader</Value>
</Value>
<Value name="4">
<Value>BatchTrailer</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMap.Map.Delimited.Record.HomeAddress">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMap.Map.Delimited'
on 2010-09-30 at 16:20:02.182 [2010-09-30 21:20:02.182 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61999,62402.182757</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="City">
<Type>%String</Type>
</Property>

<Property name="State">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2"/>
</Property>

<Property name="StreetLine1">
<Type>%String</Type>
</Property>

<Property name="ZipCode">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>HomeAddressState</State>
<StreamLocation>^Demo.RecordMap66BA.HomeAddressS</StreamLocation>
<Data name="HomeAddressState">
<Value name="1">
<Value>City</Value>
</Value>
<Value name="2">
<Value>State</Value>
</Value>
<Value name="3">
<Value>StreetLine1</Value>
</Value>
<Value name="4">
<Value>ZipCode</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMap.Map.Delimited.Record.WorkAddress">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMap.Map.Delimited'
on 2010-09-30 at 16:20:02.190 [2010-09-30 21:20:02.190 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61999,62402.190501</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="City">
<Type>%String</Type>
</Property>

<Property name="State">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2"/>
</Property>

<Property name="StreetLine1">
<Type>%String</Type>
</Property>

<Property name="ZipCode">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>WorkAddressState</State>
<StreamLocation>^Demo.RecordMap66BA.WorkAddressS</StreamLocation>
<Data name="WorkAddressState">
<Value name="1">
<Value>City</Value>
</Value>
<Value name="2">
<Value>State</Value>
</Value>
<Value name="3">
<Value>StreetLine1</Value>
</Value>
<Value name="4">
<Value>ZipCode</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMap.Map.Delimited.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMap.Map.Delimited'
on 2010-09-30 at 16:20:02.209 [2010-09-30 21:20:02.209 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61999,62402.209806</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="%ParentBatch">
<Type>Demo.RecordMap.Map.Delimited.Batch</Type>
<Cardinality>one</Cardinality>
<Inverse>Records</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="%ParentBatchIdx">
<Properties>%ParentBatch</Properties>
</Index>

<Index name="LastNameIdx">
<Properties>LastName</Properties>
</Index>

<Index name="PersonIDIdx">
<Properties>PersonID</Properties>
</Index>

<Index name="SSNIdx">
<Properties>SSN</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PersonID">
<Type>%Integer</Type>
</Property>

<Property name="Age">
<Type>%Integer</Type>
</Property>

<Property name="DateOfBirth">
<Type>%Date</Type>
<Parameter name="FORMAT" value="1"/>
</Property>

<Property name="FavoriteColor">
<Type>%String</Type>
</Property>

<Property name="LastName">
<Type>%String</Type>
</Property>

<Property name="FirstName">
<Type>%String</Type>
</Property>

<Property name="MiddleInitial">
<Type>%String</Type>
</Property>

<Property name="SSN">
<Type>%String</Type>
<Parameter name="PATTERN" value="3N1&quot;-&quot;2N1&quot;-&quot;4N"/>
</Property>

<Property name="HomeAddress">
<Type>Demo.RecordMap.Map.Delimited.Record.HomeAddress</Type>
</Property>

<Property name="WorkAddress">
<Type>Demo.RecordMap.Map.Delimited.Record.WorkAddress</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMap.MapC0CE.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.RecordMap.MapC0CE.RecordD</IdLocation>
<IndexLocation>^Demo.RecordMap.MapC0CE.RecordI</IndexLocation>
<StreamLocation>^Demo.RecordMap.MapC0CE.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Source</Value>
</Value>
<Value name="3">
<Value>Age</Value>
</Value>
<Value name="4">
<Value>DateOfBirth</Value>
</Value>
<Value name="5">
<Value>FavoriteColor</Value>
</Value>
<Value name="6">
<Value>LastName</Value>
</Value>
<Value name="7">
<Value>FirstName</Value>
</Value>
<Value name="8">
<Value>MiddleInitial</Value>
</Value>
<Value name="9">
<Value>SSN</Value>
</Value>
<Value name="10">
<Value>HomeAddress</Value>
</Value>
<Value name="11">
<Value>WorkAddress</Value>
</Value>
<Value name="12">
<Value>%ParentBatch</Value>
</Value>
<Value name="13">
<Value>PersonID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMap.Map.Delimited">
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61860,35926.903928</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.RecordMap.Map.Delimited" type="delimited" char_encoding="UTF-8" targetClassname="Demo.RecordMap.Map.Delimited.Record" batchClass="Demo.RecordMap.Map.Delimited.Batch" padFromLeft="0" recordTerminator="\x0d\x0a">
  <Separators>
    <Separator>;</Separator>
    <Separator>,</Separator>
    <Separator>\x20</Separator>
  </Separators>
  <Field name="PersonID" required="0" datatype="%Integer" index="1"></Field>
  <Field name="Age" required="0" datatype="%Integer"></Field>
  <Field name="DateOfBirth" required="0" datatype="%Date" params="FORMAT=1"></Field>
  <Field name="FavoriteColor" required="0" datatype="%String"></Field>
  <Composite name="Name" required="0">
    <Field name="LastName" required="0" datatype="%String" index="1"></Field>
    <Composite name="GivenNames" required="0">
      <Field name="FirstName" required="0" datatype="%String"></Field>
      <Field name="MiddleInitial" required="0" datatype="%String"></Field>
    </Composite>
  </Composite>
  <Field name="SSN" required="0" datatype="%String" index="1" params="PATTERN=3N1&quot;-&quot;2N1&quot;-&quot;4N"></Field>
  <Field name="HomeAddress.City" required="0" datatype="%String"></Field>
  <Field name="HomeAddress.State" required="0" datatype="%String" params="MAXLEN=2"></Field>
  <Field name="HomeAddress.StreetLine1" required="0" datatype="%String"></Field>
  <Field name="HomeAddress.ZipCode" required="0" datatype="%String"></Field>
  <Field name="WorkAddress.City" required="0" datatype="%String"></Field>
  <Field name="WorkAddress.State" required="0" datatype="%String" params="MAXLEN=2"></Field>
  <Field name="WorkAddress.StreetLine1" required="0" datatype="%String"></Field>
  <Field name="WorkAddress.ZipCode" required="0" datatype="%String"></Field>
</Record>
]]></Data>
</XData>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.RecordMap.Map.Delimited.Record</Default>
</Parameter>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write($select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).PersonIDLogicalToDisplay(pObject.PersonID), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).AgeLogicalToDisplay(pObject.Age), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).DateOfBirthLogicalToDisplay(pObject.DateOfBirth), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).FavoriteColorLogicalToDisplay(pObject.FavoriteColor), 1: ""),0)
	Do pStream.Write($char(59),0)
	Do pStream.Write($select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).LastNameLogicalToDisplay(pObject.LastName), 1: ""),0)
	Do pStream.Write($char(44),0)
	Do pStream.Write($select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).FirstNameLogicalToDisplay(pObject.FirstName), 1: ""),0)
	Do pStream.Write($char(32) _ $select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).MiddleInitialLogicalToDisplay(pObject.MiddleInitial), 1: ""),0)
	Do pStream.Write($char(59) _ $select(pHasTopFields: ##class(Demo.RecordMap.Map.Delimited.Record).SSNLogicalToDisplay(pObject.SSN), 1: ""),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.HomeAddress).CityLogicalToDisplay(pObject.HomeAddress.City),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.HomeAddress).StateLogicalToDisplay(pObject.HomeAddress.State),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.HomeAddress).StreetLine1LogicalToDisplay(pObject.HomeAddress.StreetLine1),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.HomeAddress).ZipCodeLogicalToDisplay(pObject.HomeAddress.ZipCode),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.WorkAddress).CityLogicalToDisplay(pObject.WorkAddress.City),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.WorkAddress).StateLogicalToDisplay(pObject.WorkAddress.State),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.WorkAddress).StreetLine1LogicalToDisplay(pObject.WorkAddress.StreetLine1),0)
	Do pStream.Write($char(59) _ ##class(Demo.RecordMap.Map.Delimited.Record.WorkAddress).ZipCodeLogicalToDisplay(pObject.WorkAddress.ZipCode),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(59),$char(44),$char(32))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.PersonID =  pObject.PersonIDDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.Age =  pObject.AgeDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.DateOfBirth =  pObject.DateOfBirthDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.FavoriteColor = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set tStrings(tStrings) = tCurrString
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(44), 1)
	Set tStrings = tStrings + 1
	If pGetTopFields {
		Set pObject.LastName = tStrings(tStrings)
	}
	Set tStrings = tStrings - 1
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(44), 2)
	Set tStrings = tStrings + 1
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(32), 1)
	Set tStrings = tStrings + 1
	If pGetTopFields {
		Set pObject.FirstName = tStrings(tStrings)
	}
	Set tStrings = tStrings - 1
	Set tStrings(tStrings+1) = $piece(tStrings(tStrings), $char(32), 2)
	Set tStrings = tStrings + 1
	If pGetTopFields {
		Set pObject.MiddleInitial = tStrings(tStrings)
	}
	Set tStrings = tStrings - 1
	Set tStrings = tStrings - 1
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	If pGetTopFields {
		Set pObject.SSN = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.HomeAddress.City = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.HomeAddress.State = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.HomeAddress.StreetLine1 = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.HomeAddress.ZipCode = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.WorkAddress.City = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.WorkAddress.State = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.WorkAddress.StreetLine1 = tCurrString
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(59), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(59), .tTopPiece)
	Set pObject.WorkAddress.ZipCode = tCurrString
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="Demo.RecordMap.Map.FixedWidth.Record.HomeAddress">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMap.Map.FixedWidth'
on 2010-09-30 at 17:42:18.372 [2010-09-30 22:42:18.372 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61999,67338.37226</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="StreetLine1">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Property name="City">
<Type>%String</Type>
<Parameter name="MAXLEN" value="25"/>
</Property>

<Property name="State">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2"/>
</Property>

<Property name="ZipCode">
<Type>%String</Type>
<Parameter name="MAXLEN" value="5"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>HomeAddressState</State>
<StreamLocation>^Demo.RecordMapA535.HomeAddressS</StreamLocation>
<Data name="HomeAddressState">
<Value name="1">
<Value>StreetLine1</Value>
</Value>
<Value name="2">
<Value>City</Value>
</Value>
<Value name="3">
<Value>State</Value>
</Value>
<Value name="4">
<Value>ZipCode</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMap.Map.FixedWidth.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMap.Map.FixedWidth'
on 2010-09-30 at 17:42:18.386 [2010-09-30 22:42:18.386 UTC]
by user DemoUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61999,67338.38603</TimeCreated>
<Inheritance>right</Inheritance>

<Index name="PersonIDIdx">
<Properties>PersonID</Properties>
</Index>

<Index name="SSNIdx">
<Properties>SSN</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PersonID">
<Type>%String</Type>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="FirstName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="25"/>
</Property>

<Property name="MiddleInitial">
<Type>%String</Type>
<Parameter name="MAXLEN" value="25"/>
</Property>

<Property name="LastName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Property name="DateOfBirth">
<Type>%Date</Type>
<Parameter name="FORMAT" value="3"/>
</Property>

<Property name="SSN">
<Type>%String</Type>
<Parameter name="MAXLEN" value="11"/>
<Parameter name="PATTERN" value="3N1&quot;-&quot;2N1&quot;-&quot;4N"/>
</Property>

<Property name="HomeAddress">
<Type>Demo.RecordMap.Map.FixedWidth.Record.HomeAddress</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMap.Map7F0B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.RecordMap.Map7F0B.RecordD</IdLocation>
<IndexLocation>^Demo.RecordMap.Map7F0B.RecordI</IndexLocation>
<StreamLocation>^Demo.RecordMap.Map7F0B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Source</Value>
</Value>
<Value name="3">
<Value>FirstName</Value>
</Value>
<Value name="4">
<Value>MiddleInitial</Value>
</Value>
<Value name="5">
<Value>LastName</Value>
</Value>
<Value name="6">
<Value>DateOfBirth</Value>
</Value>
<Value name="7">
<Value>SSN</Value>
</Value>
<Value name="8">
<Value>HomeAddress</Value>
</Value>
<Value name="9">
<Value>PersonID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMap.Map.FixedWidth">
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61860,38243.144482</TimeCreated>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.RecordMap.Map.FixedWidth" type="fixedwidth" char_encoding="UTF-8" targetClassname="Demo.RecordMap.Map.FixedWidth.Record" paddingChars="\x20" padFromLeft="0" recordTerminator="\x0d\x0a">
  <Field name="PersonID" required="0" datatype="%String" width="8" index="1"></Field>
  <Field name="FirstName" required="0" datatype="%String" width="25"></Field>
  <Field name="MiddleInitial" required="0" datatype="%String" width="25"></Field>
  <Field name="LastName" required="0" datatype="%String" width="30"></Field>
  <Field name="DateOfBirth" required="0" datatype="%Date" width="10" params="FORMAT=3"></Field>
  <Field name="SSN" required="0" datatype="%String" width="11" index="1" params="PATTERN=3N1&quot;-&quot;2N1&quot;-&quot;4N"></Field>
  <Composite name="HomeAddress" required="0">
    <Field name="HomeAddress.StreetLine1" required="0" datatype="%String" width="30"></Field>
    <Field name="HomeAddress.City" required="0" datatype="%String" width="25"></Field>
    <Field name="HomeAddress.State" required="0" datatype="%String" width="2"></Field>
    <Field name="HomeAddress.ZipCode" required="0" datatype="%String" width="5"></Field>
  </Composite>
</Record>
]]></Data>
</XData>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.RecordMap.Map.FixedWidth.Record</Default>
</Parameter>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pHasTopFields { Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record).PersonIDLogicalToDisplay(pObject.PersonID), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 8 > tLen {
		Set tPadding = $get(pPadArray(8 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (8 - tLen + 1)) = ""
			Set pPadArray(8-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record).FirstNameLogicalToDisplay(pObject.FirstName), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 25 > tLen {
		Set tPadding = $get(pPadArray(25 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (25 - tLen + 1)) = ""
			Set pPadArray(25-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record).MiddleInitialLogicalToDisplay(pObject.MiddleInitial), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 25 > tLen {
		Set tPadding = $get(pPadArray(25 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (25 - tLen + 1)) = ""
			Set pPadArray(25-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record).LastNameLogicalToDisplay(pObject.LastName), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 30 > tLen {
		Set tPadding = $get(pPadArray(30 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (30 - tLen + 1)) = ""
			Set pPadArray(30-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record).DateOfBirthLogicalToDisplay(pObject.DateOfBirth), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 10 > tLen {
		Set tPadding = $get(pPadArray(10 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (10 - tLen + 1)) = ""
			Set pPadArray(10-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	If pHasTopFields { Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record).SSNLogicalToDisplay(pObject.SSN), tLen = $length(tValue) }
	Else { Set tValue = "", tLen = 0}
	If 11 > tLen {
		Set tPadding = $get(pPadArray(11 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (11 - tLen + 1)) = ""
			Set pPadArray(11-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record.HomeAddress).StreetLine1LogicalToDisplay(pObject.HomeAddress.StreetLine1), tLen = $length(tValue)
	If 30 > tLen {
		Set tPadding = $get(pPadArray(30 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (30 - tLen + 1)) = ""
			Set pPadArray(30-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record.HomeAddress).CityLogicalToDisplay(pObject.HomeAddress.City), tLen = $length(tValue)
	If 25 > tLen {
		Set tPadding = $get(pPadArray(25 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (25 - tLen + 1)) = ""
			Set pPadArray(25-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record.HomeAddress).StateLogicalToDisplay(pObject.HomeAddress.State), tLen = $length(tValue)
	If 2 > tLen {
		Set tPadding = $get(pPadArray(2 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (2 - tLen + 1)) = ""
			Set pPadArray(2-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Set tValue = ##class(Demo.RecordMap.Map.FixedWidth.Record.HomeAddress).ZipCodeLogicalToDisplay(pObject.HomeAddress.ZipCode), tLen = $length(tValue)
	If 5 > tLen {
		Set tPadding = $get(pPadArray(5 - tLen))
		If tPadding = "" {
			Set $piece(tPadding, $char(32), (5 - tLen + 1)) = ""
			Set pPadArray(5-tLen) = tPadding
		}
		Set tValue = tValue_tPadding
	}
	Do pStream.Write(tValue, 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "" } 
	Set tMaxLen = 171
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, tMaxLen, pTimeout, $char(13,10), tRecLabel, pLookAhead)
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tCurrPos = 1
	Set tNewChunk = 1
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,8,"","","PersonID")
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.PersonID = pObject.PersonIDDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,25,"","","FirstName")
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.FirstName = pObject.FirstNameDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,25,"","","MiddleInitial")
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.MiddleInitial = pObject.MiddleInitialDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,30,"","","LastName")
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.LastName = pObject.LastNameDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,10,"","","DateOfBirth")
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.DateOfBirth = pObject.DateOfBirthDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,11,"","","SSN")
	If $$$ISERR(tStatus) Quit tStatus
	If pGetTopFields Set pObject.SSN = pObject.SSNDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,30,"","","HomeAddress.StreetLine1")
	If $$$ISERR(tStatus) Quit tStatus
	Set pObject.HomeAddress.StreetLine1 = pObject.HomeAddress.StreetLine1DisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,25,"","","HomeAddress.City")
	If $$$ISERR(tStatus) Quit tStatus
	Set pObject.HomeAddress.City = pObject.HomeAddress.CityDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,2,"","","HomeAddress.State")
	If $$$ISERR(tStatus) Quit tStatus
	Set pObject.HomeAddress.State = pObject.HomeAddress.StateDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Set tCurrVal = ..checkFixedWidthChunk(.tStatus,.tNewChunk,.tCurrChunk,.tRecordData,.tCurrString,.tCurrLen,.tCurrPos,5,"","","HomeAddress.ZipCode")
	If $$$ISERR(tStatus) Quit tStatus
	Set pObject.HomeAddress.ZipCode = pObject.HomeAddress.ZipCodeDisplayToLogical($ZStrip(tCurrVal, ">", $char(32)))
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="Demo.RecordMap.Production">
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>61860,58884.126262</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.RecordMap.Production" LogGeneralTraceEvents="false">
  <Description>Sample Production to illustrate a simple input/output transformation using generated RecordMaps. NOTE: The source file, RecordMap.Delimited.Input.txt, and a sample output file, RecordMap.Delimited.Output.txt, should be located in [install_dir]/dev/RecordMap/.</Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Delimited.RecordMap.FileService" Category="" ClassName="EnsLib.RecordMap.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="File service to process files containing delimited records" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="RecordMap">Demo.RecordMap.Map.Delimited</Setting>
    <Setting Target="Host" Name="TargetConfigNames">FixedWidth.RecordMap.FileOperation,Delimited.RecordMap.BatchOperation</Setting>
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\in\</Setting>
    <Setting Target="Adapter" Name="FileSpec">RecordMap_Delimited_*</Setting>
    <Setting Target="Adapter" Name="ArchivePath">C:\Practice\inarchive</Setting>
  </Item>
  <Item Name="FixedWidth.RecordMap.FileOperation" Category="" ClassName="EnsLib.RecordMap.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="File operation to write data out into fixed width records" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Filename">RecordMap_FixedWidth_Output.txt</Setting>
    <Setting Target="Host" Name="RecordMap">Demo.RecordMap.Map.FixedWidth</Setting>
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out\</Setting>
  </Item>
  <Item Name="Delimited.RecordMap.BatchOperation" Category="" ClassName="EnsLib.RecordMap.Operation.BatchFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Filename">RecordMap_DelimitedBatch_%Q</Setting>
    <Setting Target="Host" Name="UseDefaultBatch">1</Setting>
    <Setting Target="Host" Name="DefaultBatchClass">Demo.RecordMap.Map.Delimited.Batch</Setting>
    <Setting Target="Host" Name="RolloverSchedule">START:*-*-*T*:*:00</Setting>
    <Setting Target="Host" Name="RolloverLimit">6</Setting>
    <Setting Target="Host" Name="RecordMap">Demo.RecordMap.Map.Delimited</Setting>
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out\</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.RecordMapBatch.Map.TrainDataIn.BatchIn">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Demo.RecordMapBatch.Map.TrainDataIn'
on 2015-12-18 at 17:30:55.661 [2015-12-18 22:30:55.661 UTC]
by user UnknownUser</Description>
<Super>%Library.Persistent,EnsLib.RecordMap.SimpleBatch</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,49873.011091</TimeCreated>

<Parameter name="XMLNAME">
<Default>BatchIn</Default>
</Parameter>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="BatchHeader">
<Default>Line, Trip, PlatformKey, InformationType, Time, TimeRemaining, Revenue, Route</Default>
</Parameter>

<Parameter name="HeaderTerm">
<Default>\x0d\x0a</Default>
</Parameter>

<Parameter name="BatchTrailer">
</Parameter>

<Parameter name="TrailerTerm">
</Parameter>

<Parameter name="IgnoreLeadingData">
<Default>0</Default>
</Parameter>

<Property name="Records">
<Type>Demo.RecordMapBatch.Map.TrainDataIn.Record</Type>
<Cardinality>many</Cardinality>
<Inverse>%ParentBatch</Inverse>
<Relationship>1</Relationship>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ..deleteRecords({ID})
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="XMLTYPE">
<Default>Demo_RecordMapBatch_Map_TrainDataIn_BatchIn</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMapBatc3B98.BatchInD</DataLocation>
<DefaultData>BatchInDefaultData</DefaultData>
<IdLocation>^Demo.RecordMapBatc3B98.BatchInD</IdLocation>
<IndexLocation>^Demo.RecordMapBatc3B98.BatchInI</IndexLocation>
<StreamLocation>^Demo.RecordMapBatc3B98.BatchInS</StreamLocation>
<Data name="BatchInDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Source</Value>
</Value>
<Value name="3">
<Value>BatchHeader</Value>
</Value>
<Value name="4">
<Value>BatchTrailer</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMapBatch.Map.TrainDataIn.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMapBatch.Map.TrainDataIn'
on 2015-12-18 at 17:30:55.638 [2015-12-18 22:30:55.638 UTC]
by user UnknownUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,63055.638616</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="Line">
<Type>%String</Type>
</Property>

<Property name="Trip">
<Type>%Integer</Type>
</Property>

<Property name="PlatformKey">
<Type>%String</Type>
</Property>

<Property name="InformationType">
<Type>%String</Type>
</Property>

<Property name="Time">
<Type>%String</Type>
</Property>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="%ParentBatch">
<Type>Demo.RecordMapBatch.Map.TrainDataIn.BatchIn</Type>
<Cardinality>one</Cardinality>
<Inverse>Records</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="%ParentBatchIdx">
<Properties>%ParentBatch</Properties>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMapBatch3B98.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.RecordMapBatch3B98.RecordD</IdLocation>
<IndexLocation>^Demo.RecordMapBatch3B98.RecordI</IndexLocation>
<StreamLocation>^Demo.RecordMapBatch3B98.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Line</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>PlatformKey</Value>
</Value>
<Value name="5">
<Value>InformationType</Value>
</Value>
<Value name="6">
<Value>Time</Value>
</Value>
<Value name="7">
<Value>%ParentBatch</Value>
</Value>
<Value name="8">
<Value>Trip</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMapBatch.Map.TrainDataIn">
<Description>
ANNOTATION: Record Map describing the format of the data provided by MassDOT at http://developer.mbta.com/Data/Red.txt
RECORDMAP: Modified during compilation of RecordMap 'Demo.RecordMapBatch.Map.TrainDataIn'
on 2016-02-01 at 09:38:27.548 [2016-02-01 14:38:27.548 UTC]
by user UnknownUser</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,49876.23878</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.RecordMapBatch.Map.TrainDataIn.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(44,32))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44,32), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	If pGetTopFields {
		Set pObject.Line = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44,32), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	If pGetTopFields {
		Set pObject.Trip =  pObject.TripDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44,32), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	If pGetTopFields {
		Set pObject.PlatformKey = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44,32), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	If pGetTopFields {
		Set pObject.InformationType = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44,32), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	If pGetTopFields {
		Set pObject.Time = tCurrString
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44,32), .tTopPiece)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write($select(pHasTopFields: pObject.Line,1: ""),0)
	Do pStream.Write($char(44,32) _ $select(pHasTopFields: pObject.TripLogicalToDisplay(pObject.Trip),1: ""),0)
	Do pStream.Write($char(44,32) _ $select(pHasTopFields: pObject.PlatformKey,1: ""),0)
	Do pStream.Write($char(44,32) _ $select(pHasTopFields: pObject.InformationType,1: ""),0)
	Do pStream.Write($char(44,32) _ $select(pHasTopFields: pObject.Time,1: ""),0)
	Do pStream.Write($char(44,32),0)
	Do pStream.Write($char(44,32),0)
	Do pStream.Write($char(44,32),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.RecordMapBatch.Map.TrainDataIn.BatchIn")=""
	Set pClasses("Demo.RecordMapBatch.Map.TrainDataIn.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[""
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.RecordMapBatch.Map.TrainDataIn" type="delimited" char_encoding="UTF-8" targetClassname="Demo.RecordMapBatch.Map.TrainDataIn.Record" batchClass="Demo.RecordMapBatch.Map.TrainDataIn.BatchIn" complexBatchManaged="0" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>, </Separator>
  </Separators>
  <annotation>Record Map describing the format of the data provided by MassDOT at http://developer.mbta.com/Data/Red.txt</annotation>
  <Field name="Line" required="0" datatype="%String" repeating="0">
  </Field>
  <Field name="Trip" required="0" datatype="%Integer" repeating="0">
  </Field>
  <Field name="PlatformKey" required="0" datatype="%String" repeating="0">
  </Field>
  <Field name="InformationType" required="0" datatype="%String" repeating="0">
  </Field>
  <Field name="Time" required="0" datatype="%String" repeating="0">
  </Field>
  <Field name="TimeRemaining" required="0" ignored="1" datatype="%String" repeating="0">
    <annotation>This field appears in the incoming data, but is not mapped to a property in the record object.</annotation>
  </Field>
  <Field name="Revenue" required="0" ignored="1" datatype="%String" repeating="0">
    <annotation>This field appears in the incoming data, but is not mapped to a property in the record object.</annotation>
  </Field>
  <Field name="Route" required="0" ignored="1" datatype="%Boolean" repeating="0">
    <annotation>This field appears in the incoming data, but is not mapped to a property in the record object.</annotation>
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Demo.RecordMapBatch.Map.TrainDataOut.BatchOut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Demo.RecordMapBatch.Map.TrainDataOut'
on 2015-12-18 at 17:32:14.992 [2015-12-18 22:32:14.992 UTC]
by user UnknownUser</Description>
<Super>%Library.Persistent,EnsLib.RecordMap.SimpleBatch</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,49945.513392</TimeCreated>

<Parameter name="XMLNAME">
<Default>BatchOut</Default>
</Parameter>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Parameter name="BatchHeader">
<Default>Date,TrainID,Direction,Station,Time</Default>
</Parameter>

<Parameter name="HeaderTerm">
<Default>\x0d\x0a</Default>
</Parameter>

<Parameter name="BatchTrailer">
</Parameter>

<Parameter name="TrailerTerm">
</Parameter>

<Parameter name="IgnoreLeadingData">
<Default>0</Default>
</Parameter>

<Property name="Records">
<Type>Demo.RecordMapBatch.Map.TrainDataOut.Record</Type>
<Cardinality>many</Cardinality>
<Inverse>%ParentBatch</Inverse>
<Relationship>1</Relationship>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ..deleteRecords({ID})
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="XMLTYPE">
<Default>Demo_RecordMapBatch_Map_TrainDataOut_BatchOut</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMapBat7CD0.BatchOutD</DataLocation>
<DefaultData>BatchOutDefaultData</DefaultData>
<IdLocation>^Demo.RecordMapBat7CD0.BatchOutD</IdLocation>
<IndexLocation>^Demo.RecordMapBat7CD0.BatchOutI</IndexLocation>
<StreamLocation>^Demo.RecordMapBat7CD0.BatchOutS</StreamLocation>
<Data name="BatchOutDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Source</Value>
</Value>
<Value name="3">
<Value>BatchHeader</Value>
</Value>
<Value name="4">
<Value>BatchTrailer</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMapBatch.Map.TrainDataOut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Demo.RecordMapBatch.Map.TrainDataOut'
on 2015-12-18 at 17:32:14.985 [2015-12-18 22:32:14.985 UTC]
by user UnknownUser</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,63134.985523</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="Date">
<Type>%Date</Type>
</Property>

<Property name="TrainID">
<Type>%Integer</Type>
</Property>

<Property name="Direction">
<Type>%String</Type>
</Property>

<Property name="Station">
<Type>%String</Type>
</Property>

<Property name="Time">
<Type>%Time</Type>
<Parameter name="XMLTIMEZONE" value="IGNORE"/>
</Property>

<Property name="%ParentBatch">
<Type>Demo.RecordMapBatch.Map.TrainDataOut.BatchOut</Type>
<Cardinality>one</Cardinality>
<Inverse>Records</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="%ParentBatchIdx">
<Properties>%ParentBatch</Properties>
</Index>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.RecordMapBatch7CD0.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Demo.RecordMapBatch7CD0.RecordD</IdLocation>
<IndexLocation>^Demo.RecordMapBatch7CD0.RecordI</IndexLocation>
<StreamLocation>^Demo.RecordMapBatch7CD0.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Date</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>Direction</Value>
</Value>
<Value name="5">
<Value>Station</Value>
</Value>
<Value name="6">
<Value>Time</Value>
</Value>
<Value name="7">
<Value>%ParentBatch</Value>
</Value>
<Value name="8">
<Value>TrainID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.RecordMapBatch.Map.TrainDataOut">
<Description>
ANNOTATION: Record Map describing the data which will be output by Demo.RecordMapBatch.Production.
RECORDMAP: Modified during compilation of RecordMap 'Demo.RecordMapBatch.Map.TrainDataOut'
on 2015-12-18 at 17:32:15.000 [2015-12-18 22:32:15.000 UTC]
by user UnknownUser</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,49955.47353</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Demo.RecordMapBatch.Map.TrainDataOut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(13,10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tSeps = $listbuild($char(44))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44), .tTopPiece)
	If pGetTopFields {
		Set pObject.Date =  pObject.DateDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44), .tTopPiece)
	If pGetTopFields {
		Set pObject.TrainID =  pObject.TrainIDDisplayToLogical(tCurrString)
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44), .tTopPiece)
	If pGetTopFields {
		Set pObject.Direction = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44), .tTopPiece)
	If pGetTopFields {
		Set pObject.Station = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(44), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(44), .tTopPiece)
	If pGetTopFields {
		Set pObject.Time =  pObject.TimeDisplayToLogical(tCurrString)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Do pStream.Write($select(pHasTopFields: pObject.DateLogicalToDisplay(pObject.Date),1: ""),0)
	Do pStream.Write($char(44) _ $select(pHasTopFields: pObject.TrainIDLogicalToDisplay(pObject.TrainID),1: ""),0)
	Do pStream.Write($char(44) _ $select(pHasTopFields: pObject.Direction,1: ""),0)
	Do pStream.Write($char(44) _ $select(pHasTopFields: pObject.Station,1: ""),0)
	Do pStream.Write($char(44) _ $select(pHasTopFields: pObject.TimeLogicalToDisplay(pObject.Time),1: ""),0)
	Do pStream.Write($char(13,10), 0, .tStatus)
	If $$$ISERR(tStatus) Quit tStatus
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Demo.RecordMapBatch.Map.TrainDataOut.BatchOut")=""
	Set pClasses("Demo.RecordMapBatch.Map.TrainDataOut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[""
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Demo.RecordMapBatch.Map.TrainDataOut" type="delimited" char_encoding="UTF-8" targetClassname="Demo.RecordMapBatch.Map.TrainDataOut.Record" batchClass="Demo.RecordMapBatch.Map.TrainDataOut.BatchOut" complexBatchManaged="0" padFromLeft="0" recordTerminator="\x0d\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>,</Separator>
  </Separators>
  <annotation>Record Map describing the data which will be output by Demo.RecordMapBatch.Production.</annotation>
  <Field name="Date" required="0" datatype="%Date" repeating="0">
  </Field>
  <Field name="TrainID" required="0" datatype="%Integer" repeating="0">
  </Field>
  <Field name="Direction" required="0" datatype="%String" repeating="0">
  </Field>
  <Field name="Station" required="0" datatype="%String" repeating="0">
  </Field>
  <Field name="Time" required="0" datatype="%Time" params="XMLTIMEZONE = IGNORE" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Demo.RecordMapBatch.Production">
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63895,50814.189304</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.RecordMapBatch.Production" LogGeneralTraceEvents="false">
  <Description>Sample Production to illustrate an input/output transformation using Record Map batches.  The input batch contains data about arrival times and expected arrival times for trains.  The output batch filters to include only actual arrival times and reformats the data. This data is provided by MassDOT at http://developer.mbta.com/Data/Red.txt.  NOTE: The source file, TrainDataIn_Sample.txt and a sample output file, TrainDataOut_Sample.txt, are located in [install_dir]/dev/RecordMapBatch/.</Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="BatchFileService" Category="" ClassName="EnsLib.RecordMap.Service.BatchFileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="BatchClass">Demo.RecordMapBatch.Map.TrainDataIn.BatchIn</Setting>
    <Setting Target="Host" Name="BatchHandling">Whole</Setting>
    <Setting Target="Host" Name="RecordMap">Demo.RecordMapBatch.Map.TrainDataIn</Setting>
    <Setting Target="Adapter" Name="FileAccessTimeout">10</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\in</Setting>
    <Setting Target="Adapter" Name="FileSpec">TrainDataIn_*</Setting>
    <Setting Target="Host" Name="TargetConfigNames">Router</Setting>
  </Item>
  <Item Name="BatchFileOperation" Category="" ClassName="EnsLib.RecordMap.Operation.BatchFileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Filename">TrainDataOut_%Q.txt</Setting>
    <Setting Target="Host" Name="RecordMap">Demo.RecordMapBatch.Map.TrainDataOut</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Practice\out</Setting>
  </Item>
  <Item Name="Router" Category="" ClassName="EnsLib.MsgRouter.RoutingEngine" PoolSize="1" Enabled="true" Foreground="false" Comment="test" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Validation"></Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.RecordMapBatch.Rule.BatchRoutingRule</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.RecordMapBatch.Rule.BatchRoutingRule">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,50165.623267</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.MsgRouter.RoutingEngine" production="Demo.RecordMapBatch.Production">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="" disabled="false">
<constraint name="source" value="BatchFileService"></constraint>
<constraint name="msgClass" value="Demo.RecordMapBatch.Map.TrainDataIn.BatchIn"></constraint>
<when condition="1">
<send transform="Demo.RecordMapBatch.Transform" target="BatchFileOperation"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.RecordMapBatch.Transform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>63904,50063.71048</TimeCreated>
<DependsOn>Demo.RecordMapBatch.Map.TrainDataIn.BatchIn,Demo.RecordMapBatch.Map.TrainDataOut.BatchOut</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Demo.RecordMapBatch.Map.TrainDataIn.BatchIn' targetClass='Demo.RecordMapBatch.Map.TrainDataOut.BatchOut' create='new' language='objectscript' >
<assign value='950000' property='$ZSTORAGE' action='set' >
<annotation>Do this to avoid running into &lt;STORE&gt; errors when processing large batches.</annotation>
</assign>
<assign value='source.%Source' property='target.%Source' action='set' />
<assign value='0' property='count' action='set' />
<foreach property='source.Records()' key='k1' >
<annotation>Loop through the records in the batch</annotation>
<if condition='source.Records.(k1).InformationType = "Arrived"' >
<true>
<assign value='count + 1' property='count' action='set' />
<assign value='source.Records.(k1).Trip' property='target.Records.(count).TrainID' action='set' />
<assign value='..If($E(source.Records.(k1).PlatformKey,*) ="N","North","South")' property='target.Records.(count).Direction' action='set' />
<assign value='..ConvertDateTime(source.Records.(k1).Time,"%#m/%#d/%Y %#I:%M:%S %#P","%q(4)")' property='tTime' action='set' />
<assign value='..Piece(tTime,",",1)' property='target.Records.(count).Date' action='set' />
<assign value='..Piece(tTime,",",2)' property='target.Records.(count).Time' action='set' />
<code>
<![CDATA[ Set tStation = $Case($E(source.Records.GetAt(k1).PlatformKey,2,*-1),"ALE":"Alewife","AND":"Andrew","ASH":"Ashmont","BRA":"Braintree","BRO":"Broadway","CEN":"Central Square","MGH":"Charles/MGH","DAV":"Davis","DTC":"Downtown Crossing","FIE":"Fields Corner","HAR":"Harvard Square","JFK":"JFK/UMass","KEN":"Kendall","NQU":"North Quincy","PRK":"Park Street","POR":"Porter Square","QUA":"Quincy Adams","QUC":"Quincy Center","SAV":"Savin Hill","SHA":"Shawmut","SOU":"South Station","WOL":"Wollaston",:$E(source.Records.GetAt(k1).PlatformKey,2,*-1))]]]]><![CDATA[></code>
<assign value='tStation' property='target.Records.(count).Station' action='set' />
<code>
<annotation>Remove the current records from memory to reduce the memory used by this process.</annotation>
<![CDATA[ Do source.Records.%UnSwizzleAt(k1)
 Do target.Records.GetAt(count).%Save(0)
 Do target.Records.%UnSwizzleAt(count)]]]]><![CDATA[></code>
</true>
</if>
</foreach>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.SAP.Production.BootStrap">
<Description>
This production enables the customer to bootstrap the SAPJCO facility by providing a JavaGateway
which enables importation and proxy generation for the Java Classes which enable the connectivity.

These production settings must be configured before starting the production:-

'JavaHome' is the path to the local java installation
'ClassPath' is the java class path which must include the path to the sapjco3.jar file.

(Note: sapjco3.jar is provided by SAP, ISC does not re-distribute this file and supporting libraries so 
must be sourced independently)

Once the production is started, the class method ##class(EnsLib.SAP.BootStrap).ImportSAP() must be called
at a terminal prompt in the namespace where the production is running. The method will utilize the JavaGateway
to import the Java Classes and generate the JavaGateway proxies which  provide the SAP connectivity.

TODO: Remove the JavaHome and ClassPath settings from the production before release</Description>
<Super>Ens.Production</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>62395,48777.771111</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.SAP.Production.BootStrap" TestingEnabled="false" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="JG" Category="" ClassName="EnsLib.JavaGateway.Service" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="JavaHome">C:\Program Files\Java\jdk1.6.0_24</Setting>
    <Setting Target="Host" Name="Port">55554</Setting>
    <Setting Target="Host" Name="ClassPath">C:\perforce\dev\latest\thirdparty\sap\sapjco3-NTintel-3.0.7\sapjco3.jar</Setting>
    <Setting Target="Host" Name="Address">127.0.0.1</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Demo.SAP.Prod5BDB.BootStrapD</DataLocation>
<DefaultData>BootStrapDefaultData</DefaultData>
<IdLocation>^Demo.SAP.Prod5BDB.BootStrapD</IdLocation>
<IndexLocation>^Demo.SAP.Prod5BDB.BootStrapI</IndexLocation>
<StreamLocation>^Demo.SAP.Prod5BDB.BootStrapS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="BootStrapDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.SAP.Production.Minimal">
<Description><![CDATA[
This production demonstrates a minimal configuration of JavaGateway and the SAPJCO operation
These production settings must be configured before starting the production:-

'JavaHome' is the path to the local java installation

'ClassPath' is the java class path which must include the path to the sapjco3.jar file.

'JavaGatewayConfigItemName' is the name of the configuration item within THIS production
which defines the JavaGateway instance to be used to communicate with SAP. The operation
will access this configured item to determine the JavaGateWay Host Address and Port.

'SAPHost' is the TCP address of the host system which houses the SAP implementation
'SAPClient' is the SAP assigned client identifier (See SAP JCO documentation)
'SAPLanguage' is the 2 character language identifer used by SAP (See SAP JCO documentation)
'SAPSystemNumber' is the SAP assigned system identifier (See SAP JCO documentation)

'SAPCredentials' is the name of credentials (configured in the EMP, Ensemble->Configure->Credentials). These include
the user name and password which will provided to the SAP instance. For our demo instance these are:
SAPUser -> MMSAP,MINISAP

TODO: Remove the settings from the production before release]]></Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>62395,50253.036802</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.SAP.Production.Minimal" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="JG" Category="" ClassName="EnsLib.JavaGateway.Service" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="JavaHome">C:\Program Files\Java\jdk1.6.0_24</Setting>
    <Setting Target="Host" Name="Port">55554</Setting>
    <Setting Target="Host" Name="ClassPath">C:\perforce\dev\latest\thirdparty\sap\sapjco3-NTintel-3.0.7\sapjco3.jar</Setting>
    <Setting Target="Host" Name="Address">127.0.0.1</Setting>
  </Item>
  <Item Name="SAP" Category="" ClassName="EnsLib.SAP.Operation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="SAPHost">192.168.68.138</Setting>
    <Setting Target="Host" Name="JavaGatewayConfigItemName">JG</Setting>
    <Setting Target="Host" Name="SAPClient">000</Setting>
    <Setting Target="Host" Name="SAPCredentials">SAPUser</Setting>
    <Setting Target="Host" Name="SAPLanguage">EN</Setting>
    <Setting Target="Host" Name="SAPSystemNumber">00</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.Util.CleanupSet">
<Description>
The methods in this class are intended as an example for remediation of situations where your message classes do not have appropriate delete triggers to clean up after themselves.
Their operation depends on how your class definitions are constructed. They are not able to purge every conceivable class structure.</Description>
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>%occInclude</IncludeGenerator>
<Super>%RegisteredObject</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59262,38857.143</TimeCreated>

<Method name="GetDeepPurgeSet">
<Description>
Caution: this method is intended only for remediation of situations where your message classes do not have appropriate delete triggers to clean up after themselves. Its operation depends on your class definitions and is not able to purge every conceivable class structure. It is up to you to examine and test the operation of this method to verify that it is useful in your environment.
Return an array of all persistent or stream classes referred to as property or collection types in any of the body classes
identified to be purged in the date range given by pDaysToKeep, or in any of their properties' properties, etc.
Also include message headers and identify the range of message ids to be deleted for each class based on pDaysToKeep.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSet,pDaysToKeep:%Integer=7,pUseIdRange:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pSet  Set SQLCODE=0, tSC=$$$OK
	#; Find the highest header ID that is lower than the given time cutoff
	Set tTopKillHdr="", tDoNotDeleteDate = $$$timeUTCHtoUTC($s($ZTimezone'<0:($H-pDaysToKeep+1)_","_($ZTimezone*60),1:($H-pDaysToKeep)_","_($ztimezone*60+86400)))
	&sql(Select Top 1 ID Into :tTopKillHdr From Ens.MessageHeader Where (TimeCreated < :tDoNotDeleteDate) Order By ID Desc)
	If SQLCODE=100 { Set tTopKillHdr="" }
	ElseIf SQLCODE { Quit $$$ERROR($$$EnsErrGeneral,"Couldn't find DaysToKeep ("_pDaysToKeep_") message header Id in GetMessagePurgeSet, sqlcode="_SQLCODE) }
	Set tSC=..GetBodiesCleanupSet(.pSet,1,tTopKillHdr,pUseIdRange)
	Set:$$$ISOK(tSC) pSet("Ens.MessageHeader")=tTopKillHdr
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetBodiesCleanupSet">
<Description>
Caution: this method is intended only for remediation of situations where your message classes do not have appropriate delete triggers to clean up after themselves. Its operation depends on your class definitions and is not able to purge every conceivable class structure. It is up to you to examine and test the operation of this method to verify that it is useful in your environment.
Return an array of all persistent or stream classes used as message bodies.
If pIncludeProps=1, include persistent or stream classes referred to as property or collection types in any of the body classes, or in any of their properties' properties, etc.
Also note that no cleanup at all is possible if the message body class has a custom IDKEY because we can't depend on these to be allocated sequentially.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSet,pIncludeProps:%Boolean=1,pTopKillHdr:%Integer="",pUseIdRange:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pSet  Set SQLCODE=0, tSC=$$$OK
	#; Find all the body classes referenced in the target 
	If ""=pTopKillHdr {
		#; No top header Id to kill is given - search them all (The target headers have already been purged; we're relying on the remaining ones to reference the same classes)
		&sql(Declare C1 Cursor For Select %Exact(MessageBodyClassname) Into :tBodyClass From Ens.MessageHeader Group By MessageBodyClassname)
		&sql(OPEN C1) For { &sql(FETCH C1)  Quit:SQLCODE  Continue:""=tBodyClass
			Set tCustomIDKEY=..findCustomIDKEY(tBodyClass)
			If ""'=tCustomIDKEY Set pSet("_CustomIDKEY")=1, pSet(tBodyClass)="_CustomIDKEY:"_tCustomIDKEY  Continue
			#; Find the top remaining ID of this class NOT referenced from any header (we want to delete all unreferenced ones)
			Set:'$$$IsdefObject(tRS) tRS = ##class(%ResultSet).%New("%DynamicQuery:SQL")
			Set tSC=tRS.Prepare("Select Top 1 ID From "_$$$ClassSQLTable(tBodyClass)_" b Where (Select ID from Ens.MessageHeader h Where h.MessageBodyClassname = '"_tBodyClass_"' And h.MessageBodyId = b.ID) Is Null Order By b.ID Desc")
			Set:$$$ISOK(tSC) tSC=tRS.Execute()
			If $$$ISOK(tSC) && tRS.Next(.tSC) && $$$ISOK(tSC) {
				Set tTopKillId=tRS.Data("ID")
			}
			If $$$ISERR(tSC) Set tSC=$$$ERROR($$$EnsErrGeneral,"Couldn't find message body Id for class "_tBodyClass_" in GetClassCleanupSet: "_$$$StatusDisplayString(tSC))  Quit
			Set tSC1=tRS.Close()  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			Quit:$$$ISERR(tSC)
			Continue:+tTopKillId'=tTopKillId ; classes with IDKEYs that are not integers can't be ordered properly
			Set tSC=..cleanupHelper(.pSet,tBodyClass,pIncludeProps,tTopKillId,pUseIdRange,"")  Quit:$$$ISERR(tSC)
		} Set tCode=SQLCODE &sql(CLOSE C1) Set:'SQLCODE SQLCODE=tCode
	} Else {
		#; A top header Id is given, meaning the highest header ID to be purged. Only search the headers lower than or equal to it
		&sql(Declare C2 Cursor For Select %Exact(MessageBodyClassname) Into :tBodyClass From Ens.MessageHeader Where ID<=:pTopKillHdr Group By MessageBodyClassname)
		&sql(OPEN C2) For { &sql(FETCH C2)  Quit:SQLCODE  Continue:""=tBodyClass
			Set tCustomIDKEY=..findCustomIDKEY(tBodyClass)
			If ""'=tCustomIDKEY Set pSet("_CustomIDKEY")=1, pSet(tBodyClass)="_CustomIDKEY:"_tCustomIDKEY  Continue
			#; Find the top remaining ID of this class referenced from a header to be purged (we want to delete that body and all earlier bodies)
			&sql(Select Top 1 MessageBodyId Into :tTopKillId From Ens.MessageHeader Where MessageBodyClassname = :tBodyClass And ID<=:pTopKillHdr Order By MessageBodyId Desc)
			; there must be one for a header being purged or we wouldn't have found the classname
			Quit:SQLCODE
			Continue:+tTopKillId'=tTopKillId ; classes with IDKEYs that are not integers can't be ordered properly

			Set tSC=..cleanupHelper(.pSet,tBodyClass,pIncludeProps,tTopKillId,pUseIdRange,"")  Quit:$$$ISERR(tSC)
		} Set tCode=SQLCODE &sql(CLOSE C2) Set:'SQLCODE SQLCODE=tCode
	}
	If SQLCODE&&(SQLCODE'=100) Set tSC1=$$$ERROR($$$EnsErrGeneral,"Couldn't find message body class and Id in GetBodiesCleanupSet, sqlcode="_SQLCODE), tSC=$$$ADDSC(tSC,tSC1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetClassCleanupSet">
<Description>
Caution: this method is intended only for remediation of situations where your message classes do not have appropriate delete triggers to clean up after themselves. Its operation depends on your class definitions and is not able to purge every conceivable class structure. It is up to you to examine and test the operation of this method to verify that it is useful in your environment.
Return an array of all persistent or stream classes referred to as property or collection types in the given body classes, or in any of its properties' properties, etc.
If pUseIdRange is true, also annotate the array with the top ID to be killed for each class. If this ID is not supplied, this method will record the highest ID of the given class not referred to by any header.
Also note that no cleanup at all is possible if the message body class has a custom IDKEY because we can't depend on these to be allocated sequentially.
pClass may be a single classname, a comma separated list of classnames, or an array of classnames indexed either by ordinal or by name.
pTopKillId is a corresponding structure containing the highest ID to be killed / purged for each class. If pClass is an array indexed by classname, this ID may be supplied instead as the node value in pClass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSet,pClass:%String,pTopKillId=0,pUseIdRange:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pSet  Set SQLCODE=0, tSC=$$$OK
	Set tKey="" For { If $D(pClass)=10 {      Set tTop="", tKey=$O(pClass(tKey),1,tTop)  Quit:""=tKey  Set tBodyClass=tKey, tTopId=$G(pTopKillId(tKey),tTop) }
					ElseIf (+pClass=pClass) {         Set tKey=tKey+1            Quit:tKey>pClass    Set tBodyClass=$G(pClass(tKey)), tTopId=$G(pTopKillId(tKey)) }
					Else { Set:""=tKey nClasses=$L(pClass,",")  Set tKey=tKey+1  Quit:tKey>nClasses  Set tBodyClass=$P(pClass,",",tKey), tTopId=$P(pTopKillId,",",tKey) }
		Set tBodyClass=$ZStrip(tBodyClass,"<>WC")  Continue:""=tBodyClass
		Set tCustomIDKEY=..findCustomIDKEY(tBodyClass)
		If ""'=tCustomIDKEY Set pSet(tBodyClass)="_CustomIDKEY:"_tCustomIDKEY, tSC=$$$ERROR($$$EnsErrGeneral,"Class "_tBodyClass_" has a custom IDKEY '"_tCustomIDKEY_"'; cannot use order to find orphaned IDs")  Quit
		If 'tTopId && pUseIdRange {
			#; Find the top remaining ID of this class NOT referenced from any header (we want to delete all unreferenced ones)
			Set:'$$$IsdefObject(tRS) tRS = ##class(%ResultSet).%New("%DynamicQuery:SQL")
			Set tSC=tRS.Prepare("Select Top 1 ID From "_$$$ClassSQLTable(tBodyClass)_" b Where (Select ID from Ens.MessageHeader h Where h.MessageBodyClassname = '"_tBodyClass_"' And h.MessageBodyId = b.ID) Is Null Order By b.ID Desc")
			Set:$$$ISOK(tSC) tSC=tRS.Execute()
			If $$$ISOK(tSC) && tRS.Next(.tSC) && $$$ISOK(tSC) {
				Set tTopId=tRS.Data("ID")
			}
			If $$$ISERR(tSC) Set tSC=$$$ERROR($$$EnsErrGeneral,"Couldn't find message body Id for class "_tBodyClass_" in GetClassCleanupSet: "_$$$StatusDisplayString(tSC))  Quit
			Set tSC1=tRS.Close()  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			Quit:$$$ISERR(tSC)
		}
		Set tSC=..cleanupHelper(.pSet,.tBodyClass,1,tTopId,pUseIdRange,"")  Quit:$$$ISERR(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PurgeCleanupSet">
<Description>
Caution: this method is intended only for remediation of situations where your message classes do not have appropriate delete triggers to clean up after themselves. Its operation depends on your class definitions and is not able to purge every conceivable class structure. It is up to you to examine and test the operation of this method to verify that it is useful in your environment.
This method's operation is guided by 'cleanup set' array.  The methods GetDeepPurgeSet(), GetBodiesCleanupSet(), and GetClassCleanupSet() each represent a different way of constructing such a 'cleanup set'.
NB! After using one of those methods to construct a 'cleanup set', you or your code should examine it to remove any entries for classes that should not be purged.  For example if a message refers to a permanent patient record, you should remove the patient record class from the 'cleanup set' array before invoking this method.  Otherwise it will delete any patient records referred to by messages being purged.
Removes all persistent object instances of classes used as message bodies that have IDs lower than the first one used as a message body.
This can clean up bodies that were 'orphaned' by purging headers without the 'BodiesToo' option.
It also removes persistent objects referred to as property or collection types in any of the classes being cleaned, or in any of their properties' properties.
Note that pKeepIntegrity is ignored for a cleanup set produced by GetBodiesCleanupSet because it does not include headers to purge.
If possible it will do bulk deletes of each class in the set. Otherwise it will delete all the properties of each object by recursive descent.
Bulk ID Range delete will be used if pUseIdRange=1 and:
- pKeepIntegrity is false or MessageHeaders are not included (i.e. GetDeepPurgeSet was not used)
- the set has no node set("_hasStream")=1
- the set has no node set("_customIDKEY")=1
- No class node present has a "Top ID to purge" value
NB! Bulk ID Range delete only makes sense if all the child property objects in your messages are allocated and stored in sequence with the message headers themselves. This will be nearly true if all message objects are created fresh and then immediately sent as Ensemble message bodies.
Bulk ID Range delete might be faster or slower than recursive object property deleting, depending on your class definitions and the indices they define.
Also note: no cleanup at all is possible if the message body class is a stream or has a custom IDKEY because we can't depend on these to be ordered sequentially.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSet,*pDeletedCount:%Integer,pKeepIntegrity:%Boolean=0,pUseIdRange:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:$D(pSet)<10 $$$ERROR($$$EnsErrGeneral,"Empty cleanup set")
	Quit:$D(pSet("Ens.MessageHeader"))&&pKeepIntegrity ..purgeDeepIntegrity(.pSet,.pDeletedCount)
	Kill pDeletedCount  Set tSC=$$$OK, pDeletedCount=0, pDeletedCount("bodies")=0, tTopKillHdr=""

	If $D(pSet("Ens.MessageHeader"),tTopKillHdr) {
		#; Loop over headers, purge bodies and then header
		If pUseIdRange {
			Set tRS=##class(%ResultSet).%New("%DynamicQuery:SQL") ; reusable RS
			Set bod="" For { Set tTopKillId="", bod=$O(pSet("_body",bod),1,tTopKillId)  Quit:""=bod
				Set:""=tTopKillId tTopKillId=$G(pSet(bod))
				Set tSC=..purgeIdRange(.pSet,.pDeletedCount,bod,tTopKillId,.tRS)  Quit:$$$ISERR(tSC)
			} Quit:$$$ISERR(tSC) tSC
		}
		&sql(DECLARE C5 CURSOR FOR
			Select ID,MessageBodyId,MessageBodyClassName Into :tID,:tBodyId,:tBodyClass From Ens.MessageHeader Where ID <= :tTopKillHdr)
		&sql(OPEN C5) For { &sql(FETCH C5)  Quit:SQLCODE
			If ""'=tBodyClass&&'pUseIdRange&&'$G(pSet(tBodyClass,"_done")) {
				//Set tObj=$zobjclassmethod(tBodyClass,"%OpenId",tID,,.tSC)  Quit:$$$ISERR(tSC)
				Set tSC=..purgePropObj(.pSet,.pDeletedCount,tBodyClass,tBodyId,0)
				Quit:($$$ISERR(tSC)&&'$$$StatusEquals(tSC,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError))
				Set tSC=$$$OK, pDeletedCount("bodies")=pDeletedCount("bodies")+1
			}
			Set %ROWCOUNT=0
			&sql(Delete From Ens.MessageHeader Where ID=:tID)
			Set pDeletedCount=pDeletedCount+%ROWCOUNT
		} Set tCode=SQLCODE &sql(CLOSE C5) Set:'SQLCODE SQLCODE=tCode
		Set:SQLCODE&&(SQLCODE'=100) tSC=$$$ADDSC(tSC,$$$ERROR($$$EnsErrGeneral,"Purge error at ID "_tID_"; SQLCODE = "_SQLCODE))
	} Else { ; no MessageHeader range
		#; We have no header to iterate; this is a cleanup and we must have ID ranges for the top body classes
		Set tRS=##class(%ResultSet).%New("%DynamicQuery:SQL") ; reusable RS
		Set bod="" For { Set tTopKillId="", bod=$O(pSet("_body",bod),1,tTopKillId)  Quit:""=bod
			Set:""=tTopKillId tTopKillId=$G(pSet(bod))
			If 'tTopKillId Set tSC=$$$ERROR($$$EnsErrGeneral,"Body must have a numeric value for top '"_bod_"' ID to purge, got '"_tTopKillId_"'")  Quit
			If pUseIdRange {
				Set tSC=..purgeIdRange(.pSet,.pDeletedCount,bod,tTopKillId,.tRS)  Quit:$$$ISERR(tSC)
			} Else {
				#; Loop over all bodies to be purged for this body class
				//Set tSC=..purgeSetLoop(.pSet,.pDeletedCount,bod,pUseIdRange,tTopKillId,.tRS)  Quit:$$$ISERR(tSC)		
				#; Delete objects one-by-one (until we get down to a level where we can purge by ID if pUseIdRange=1)
				Set tSC=tRS.Prepare("Select %ID From "_$$$ClassSQLTable(bod)_" Where %ID <= "_tTopKillId)
				Set:$$$ISOK(tSC) tSC=tRS.Execute()
				While $$$ISOK(tSC) && tRS.Next(.tSC) && $$$ISOK(tSC) {
					Set tID=tRS.Data("%ID")
					Set tSC=..purgePropObj(.pSet,.pDeletedCount,bod,tID,0)
					Quit:($$$ISERR(tSC)&&'$$$StatusEquals(tSC,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError))
					Set tSC=$$$OK, pDeletedCount("bodies",bod)=$G(pDeletedCount("bodies",bod))+1
				} Set tSC1=tRS.Close()  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="purgeDeepIntegrity">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSet,*pDeletedCount:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tTopKillId=$G(pSet("Ens.MessageHeader"))  Quit:'tTopKillId $$$ERROR($$$EnsErrGeneral,"Must have purge limit id for purge with KeepIntegrity and UseIdRange")
	
	&sql(DECLARE C6 CURSOR FOR
		Select ID,MessageBodyId,MessageBodyClassName Into :tID,:tBodyId,:tBodyClass From Ens.MessageHeader h
			Where (ID <= :tTopKillId)
				And 0 = ( Select Count(*) From Ens.MessageHeader
							Where (SessionId = h.SessionId)
								And (Status<>$$$eMessageStatusCompleted)
								And (Status<>$$$eMessageStatusAborted)
								And (Status<>$$$eMessageStatusError)
								And (Status<>$$$eMessageStatusDiscarded) )
		)
	&sql(OPEN C6)
	Set tSC=$$$OK  For { &sql(FETCH C6)  Quit:SQLCODE
		If ""'=tBodyClass&&'$G(pSet(tBodyClass,"_done")) {
			Set tSC=..purgePropObj(.pSet,.pDeletedCount,tBodyClass,tBodyId,0)  Quit:$$$ISERR(tSC)
			Set pDeletedCount("bodies")=pDeletedCount("bodies")+1
		}
		Set %ROWCOUNT=0
		&sql(Delete From Ens.MessageHeader Where ID=:tID)
		Set pDeletedCount=pDeletedCount+%ROWCOUNT
	} Set tCode=SQLCODE &sql(CLOSE C6) Set:'SQLCODE SQLCODE=tCode
	Quit tSC
]]></Implementation>
</Method>

<Method name="purgePropObj">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSet,&pDeletedCount,pClass:%String,pID:%String="",pUseIdRange:%Boolean,pRS:%ResultSet]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'$D(pSet(pClass),tTopKillId)||$G(pSet(pClass,"_done")) $$$OK
	Set tSC=$$$OK
	If pUseIdRange&&tTopKillId {
		Quit ..purgeIdRange(.pSet,.pDeletedCount,pClass,tTopKillId,.pRS)
	}
	#; First delete the object's persistent properties
	Set tObj=$$$NULLOREF,prop=""  For { Set prop=$O(pSet(pClass,"_props",prop),1,proptype)  Quit:""=prop
		Continue:""=proptype||$G(pSet(proptype,"_done"))
		#; Open object
		Set:'$IsObject(tObj) tObj=$zobjclassmethod(pClass,"%OpenId",pID,,.tSC)  Quit:$$$ISERR(tSC)

		Set tTopKillPropId=$G(pSet(proptype))
		If ""'=$G(pSet(pClass,"_props",prop,"_collection")) {
			Set tPropObj=$property(tObj,prop)
			Set tKey="" For { Set tItemId=tPropObj.GetObjectIdNext(.tKey)  Quit:""=tKey
				Set tSC1=..purgePropObj(.pSet,.pDeletedCount,proptype,tItemId,pUseIdRange,pRS)
				Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			}
		} ElseIf $Case($E(tTopKillPropId,1,$L("_CustomIDKEY:")),"_Stream":1,"_CustomIDKEY:":1,:'(pUseIdRange&&tTopKillPropId)) {
			Set tPropObj=$property(tObj,prop)
			Set:$IsObject(tPropObj) tSC=..purgePropObj(.pSet,.pDeletedCount,proptype,tPropObj.%Id(),pUseIdRange,pRS)
		} Else { ; purge range not just one instance
			Set tSC=..purgePropObj(.pSet,.pDeletedCount,proptype,"",pUseIdRange,pRS)
		}
	} Quit:($$$ISERR(tSC)&'$$$StatusEquals(tSC,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError)) tSC 
	
	; Done with the properties, now do the object
	Kill tObj  Set tSC=$$$OK
	Set:""'=pID tSC=$zobjclassmethod(pClass,"%DeleteId",pID)
	If $$$ISERR(tSC) {
		Set tOK=$$$StatusEquals(tSC,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError) ; || ($$$StatusEquals(tSC,$$$NotAnInstanceError) && '$zobjclassmethod(aClass(pClass,"extent"),"%ExistsId",pId))
		If tOK { Set tSC=$$$OK }
		ElseIf '$G(aClass(pClass,"doneErr")) { Set aClass(pClass,"doneErr")=1  $$$LOGWARNING("Failed to purge body with BodyClassname='"_pClass_"', ID="_pID_" :"_$$$StatusDisplayString(tSC)) }
	} Else {
		Set pDeletedCount("bodies",pClass)=$G(pDeletedCount("bodies",pClass))+1
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="purgeIdRange">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSet,*pDeletedCount:%Integer,pClass:%String,pTopKillId:%Integer,pRS:%ResultSet]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'pTopKillId $$$ERROR($$$EnsErrGeneral,"Must have a numeric value for top '"_pClass_"' ID to purge, got '"_pTopKillId_"'")
	
	#; Go through the property classes of this class and delete the range for them all
	Set tSC=$$$OK
	Set chi="" For { Set tChildTopKillId="", chi=$O(pSet(pClass,"_child",chi))  Quit:""=chi
		Set tChildTopKillId=$G(pSet(chi))  Continue:'tChildTopKillId||$G(pSet(chi,"_done"))
		Set tSC=..purgeIdRange(.pSet,.pDeletedCount,chi,tChildTopKillId,.pRS)  Quit:$$$ISERR(tSC)
	}
	Quit:$$$ISERR(tSC) tSC
	Quit:$G(pSet(pClass,"_done")) $$$OK
	
	#; Now do this class and delete the range for it
	Set tSC=pRS.Prepare("Select %ID From "_$$$ClassSQLTable(pClass)_" Where %ID <= "_pTopKillId)
	Set:$$$ISOK(tSC) tSC=pRS.Execute()
	If $$$ISOK(tSC) {
		While pRS.Next(.tSC) { Quit:$$$ISERR(tSC)
			Set tID=pRS.GetData(1)
			Set tSC1=$zobjclassmethod(pClass,"%DeleteId",tID)
			If $$$ISERR(tSC1)&&'$G(pSet(pClass,"_doneErr")) {
				Set tOK=$$$StatusEquals(tSC1,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError) ; || ($$$StatusEquals(tSC1,$$$NotAnInstanceError) && '$zobjclassmethod(aClass(%tBodyClassname,"extent"),"%ExistsId",%tBodyId))
				If 'tOK { Set pSet(pClass,"_doneErr")=1, tSC=$$$ADDSC(tSC,tSC1)  $$$LOGWARNING("Failed to purge body "_tID_", BodyClassname='"_chi_"':"_$$$StatusDisplayString(tSC1)) }
			}
			Set pDeletedCount("bodies",pClass)=$G(pDeletedCount("bodies",pClass))+1
		}
	}
	Set tSC1=pRS.Close()  Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
	If $$$ISERR(tSC) Set tSC=$$$ERROR($$$EnsErrGeneral,"%DeleteID From "_pClass_" Where %ID <= "_pTopKillId_" failed: "_$$$StatusDisplayString(tSC))  Quit tSC
	Set pSet(pClass,"_done")=1
	Quit tSC
]]></Implementation>
</Method>

<Method name="cleanupHelper">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSet,pClass:%String,pIncludeProps:%Boolean,pTopKillId:%Integer,pUseIdRange:%Boolean,pParent:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#Dim tProp As %Dictionary.CompiledProperty
	Set SQLCODE=0, tSC=$$$OK, $ZT="Trap"
	Set:""=pTopKillId pUseIdRange=0
	If ""=pParent {
		Quit:$D(pSet("_body",pClass)) $$$ERROR($$$EnsErrGeneral,"Body class '"_pSet_"' already exists in Cleanup Set")
		If $D(pSet(pClass))&&'pUseIdRange Set pSet("_body",pClass)=pTopKillId  Quit $$$OK
	} ElseIf 'pUseIdRange&&pIncludeProps {
		Quit:$D(pSet(pParent,"_child",pClass)) $$$OK
		If $D(pSet(pClass)) {
			Merge pSet(pParent,"_child")=pSet(pClass,"_child")
			Set pSet(pParent,"_child",pClass)=""
			Quit $$$OK
		}
	}
	Set tDef=##class(%Dictionary.CompiledClass).%OpenId(pClass,,.tSC)  Quit:$$$ISERR(tSC) tSC
	If tDef.ClassType'="persistent" {
		If (""=pParent)&&(tDef.ClassType="stream") {
			$$$ASSERT($zobjclassmethod(pClass,"%Extends","%Stream.Object"))
			Set tHasStream=1
			Set pSet(pClass)="_Stream"
		}
		Quit $$$OK ; ignore classes with no storage
	}
	Set:pTopKillId>$G(pSet(pClass),pTopKillId-1) pSet(pClass)=pTopKillId
	Set (tHasStream,tHasIDKEY)=0
	If pIncludeProps {
		Set propkey="" For { Set tProp=tDef.Properties.GetNext(.propkey)  Quit:""=propkey||'$IsObject(tProp)
			Continue:""=tProp.Type 
			Set tIsCollection=..isCollection(tProp)
			Continue:3=tIsCollection ; Relationship properties fend for themselves

			Set tPropType=$$$comClassKeyGet(tProp.Type,$$$cCLASSclasstype)
			Set tTableName=$$$comClassKeyGet(tProp.Type,$$$cCLASSsqltablename)
			Set tUseIdRange=pUseIdRange

			If ""'=tTableName&&tProp.Storable&&(tPropType="persistent") {
				Set tCustomIDKEY=..findCustomIDKEY(tProp.Type)
				If ""'=tCustomIDKEY {
					Set tPropTopKillId="", tUseIdRange=0, pSet(tProp.Type)="_CustomIDKEY:"_tCustomIDKEY
					Set tHasIDKEY=1
				} ElseIf pUseIdRange&&(""'=tProp.SqlFieldName) {
					#; Find the top remaining ID of the property class NOT referenced from this class (we want to delete all unreferenced ones)
					Set:'$D(tTopKillObj) tTopKillObj=$zobjclassmethod(pClass,"%OpenId",pTopKillId,,.tSC)  Quit:$$$ISERR(tSC)
					Set tPropObj=$property(tTopKillObj,tProp.Name)
					If '$IsObject(tPropObj) {
						Set tPropTopKillId=""
					} Else {
						If tIsCollection {
							Set tKey="",tPropTopKillId="" For { Set tItemId=tPropObj.GetObjectIdNext(.tKey)  Quit:""=tKey
								Set:tPropTopKillId<tItemId tPropTopKillId=tItemId
							}
						} Else {
							$$$ASSERT(tPropObj.%Extends("%Library.Persistent"))
							Set tPropTopKillId=tPropObj.%Id()
						}
					}
				} Else {
					Set tPropTopKillId=""
				}
				Set tSC=..cleanupHelper(.pSet,tProp.Type,pIncludeProps,tPropTopKillId,tUseIdRange,pClass)  Quit:$$$ISERR(tSC)
				Set pSet(pClass,"_child",tProp.Type)=""
				Set pSet(pClass,"_props",tProp.Name)=tProp.Type
				Set:tIsCollection pSet(pClass,"_props",tProp.Name,"_collection")=tProp.RuntimeType
			}
			ElseIf tPropType="stream" {
				$$$ASSERT($zobjclassmethod(tProp.Type,"%Extends","%Stream.Object"))
				Set tHasStream=1
				Set pSet(tProp.Type)="_Stream"
				Set pSet(pClass,"_props",tProp.Name)=tProp.Type
				Set:tIsCollection pSet(pClass,"_props",tProp.Name,"_collection")=tProp.RuntimeType
			}
		} ; For { propkey
	} ; If pIncludeProps
	If ""=pParent {
		Set pSet("_body",pClass)=""
	} Else {
		If pIncludeProps Merge pSet(pParent,"_child")=pSet(pClass,"_child")  Set pSet(pParent,"_child",pClass)=""
	}
Exit
	Quit tSC
Trap
	Set tSC=$$$SystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="findCustomIDKEY">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
#Dim tIndex As %Dictionary.CompiledIndex
	Set tDef=##class(%Dictionary.CompiledClass).%OpenId(pClass,,.tSC)  Quit:$$$ISERR(tSC)||'$IsObject(tDef) ""
	Set tKey="" For { Set tIndex=tDef.Indices.GetNext(.tKey)  Quit:""=tKey||'$IsObject(tIndex)
		Quit:tIndex.IdKey&&'tIndex.CompilerGenerated
	}
	Quit:""'=tKey&&$IsObject(tIndex) tIndex.Name
	Quit ""
]]></Implementation>
</Method>

<Method name="isCollection">
<Description>
Return 0 for not collection, 1 for list, 2 for array, 3 for relationship</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProp:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Quit:""=tProp.RuntimeType||(tProp.RuntimeType=tProp.Type)||'$zobjclassmethod(tProp.RuntimeType,"%Extends","%Collection.AbstractIterator") 0
	Quit:""=pProp.Collection 0
	Quit:$zobjclassmethod(pProp.RuntimeType,"%Extends","%Library.RelationshipObject") 3
	Quit:"array"=pProp.Collection 2
	Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Demo.Workflow.Dashboard">
<Description>
Dashboard class for the Workflow Demo
</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Dashboard</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56777</TimeCreated>

<XData name="Dashboard">
<Data><![CDATA[
<Dashboard 
	Label="Role: {Instance}" 
	RefreshRate="2000" 
	Metric="Demo.Workflow.WFMetric({Instance})" 
	InstanceMenu="Roles"
>

<LightBar Label="ActiveTasks" Property="ActiveTasks"
	Link="WFTasksForRole.csp?$FRAME=Info&amp;$ID1={Instance}"
	Width="75"
/>

<LightBar Label="Load" Property="Load" 
	Link="WFTasksForRole.csp?$FRAME=Info&amp;$ID1={Instance}"
	Width="75"
/>

<LineChart Label="Tasks for Current Role" 
	Width="150" Height="100"
	AutoScale="true"
	XGridLines="20" YGridLines="9"
	>
<Series Label="Active" Property="ActiveTasks" Color="yellow" />
<Series Label="Completed" Property="CompletedTasks" Color="red" />
</LineChart>

</Dashboard>
]]></Data>
</XData>
</Class>


<Class name="Demo.Workflow.HelpDesk">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>59688,56840</TimeCreated>

<XData name="BPL">
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' height='2000' width='2000' request='Demo.Workflow.ProblemReport' response='Ens.Response' >
<context>
<property name='Resolved' type='%Boolean' initialexpression='0' />
<property name='DevelopmentAction' type='%String' />
<property name='TestingAction' type='%String' />
</context>
<sequence xpos='500' ypos='100' xend='500' yend='300' >
<while 
name='while' xpos='500' ypos='200' xend='504' yend='1190' condition='context.Resolved=0' >
<annotation>Work on this problem until it is resolved.
(Click on the loop icon to see details of this while loop.)</annotation>
<call name='Notify Development' xpos='500' ypos='200' target='Demo-Development' async='1' >
<annotation>Send the problem report to 
Development for review.</annotation>
<request type='EnsLib.Workflow.TaskRequest' >
<assign property='callrequest.%Actions' value='"Corrected,Ignored"' action='set' />
<assign property='callrequest.%Subject' value='"Problem reported by " _ request.ReportedBy' action='set' />
<assign property='callrequest.%Message' value='request.Problem' action='set' />
<assign property='callrequest.%FormFields' value='"Comments"' action='set' />
</request>
<response type='EnsLib.Workflow.TaskResponse' >
<assign property='context.DevelopmentAction' value='callresponse.%Action' action='set' />
</response>
</call>
<sync name='WaitForDevelopment' xpos='500' ypos='300' calls='Notify Development' type='all' />
<if name='Fixed?' xpos='500' ypos='400' xend='504' yend='1090' condition='context.DevelopmentAction="Corrected"' >
<annotation>If Development fixed the problem, test it.</annotation>
<true>
<call name='Notify Testing' xpos='629' ypos='543' target='Demo-Testing' async='1' >
<annotation>Send the problem 
 to Testing for
confirmation.</annotation>
<request type='EnsLib.Workflow.TaskRequest' >
<assign property='callrequest.%Actions' value='"Corrected,Retest"' action='set' />
<assign property='callrequest.%Subject' value='"Test this problem from " _ request.ReportedBy' action='set' />
<assign property='callrequest.%Message' value='request.Problem' action='set' />
</request>
<response type='EnsLib.Workflow.TaskResponse' >
<assign property='context.TestingAction' value='callresponse.%Action' action='set' />
</response>
</call>
<sync name='WaitForTesting' xpos='629' ypos='643' calls='Notify Testing' type='all' />
<if name='Corrected?' xpos='629' ypos='743' xend='629' yend='996' condition='context.TestingAction="Corrected"' >
<annotation>Has the problem been corrected?</annotation>
<true>
<assign name='Resolved' xpos='756' ypos='876' property='context.Resolved' value='1' action='set' />
</true>
</if>
</true>
<false>
<assign name='Not a problem' xpos='370' ypos='543' property='context.Resolved' value='1' action='set' />
</false>
</if>
</while>
</sequence>
</process>

]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.Workflow.ProblemReport">
<Description>
This is a ProblemReport message.
It is used by the Workflow demo to represent a technical
problem submitted by a customer.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56777</TimeCreated>

<Property name="ReportedBy">
<Description>
Name of customer reporting the problem.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="60"/>
</Property>

<Property name="Problem">
<Description>
Description of the problem.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ProblemReportDefaultData</DefaultData>
<Data name="ProblemReportDefaultData">
<Structure>listnode</Structure>
<Subscript>"ProblemReport"</Subscript>
<Value name="1">
<Value>Problem</Value>
</Value>
<Value name="2">
<Value>ReportedBy</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.Workflow.Production">
<Description>
This production demonstrates the Ensemble Workflow Engine.</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56777</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.Workflow.Production" TestingEnabled="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="HelpDesk" ClassName="Demo.Workflow.HelpDesk" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
  <Item Name="Demo-Development" ClassName="EnsLib.Workflow.Operation" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
    <Setting Target="Host" Name="AutoCreateRole">1</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
  </Item>
  <Item Name="Demo-Testing" ClassName="EnsLib.Workflow.Operation" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
    <Setting Target="Host" Name="AutoCreateRole">1</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
  </Item>
  <Item Name="Demo.Workflow.WFMetric" ClassName="Demo.Workflow.WFMetric" PoolSize="1" Enabled="true" Foreground="false" InactivityTimeout="0">
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.Workflow.WFMetric">
<Description>
Sample business metric class for Workflow demo</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessMetric</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>60423,56777</TimeCreated>

<Property name="ActiveTasks">
<Description>
Active Tasks</Description>
<Type>Ens.DataType.Metric</Type>
<MultiDimensional>1</MultiDimensional>
<Parameter name="AUTOHISTORY" value="10"/>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="50"/>
<Parameter name="UNITS" value="Tasks"/>
</Property>

<Property name="Load">
<Description>
Active Load</Description>
<Type>Ens.DataType.Metric</Type>
<MultiDimensional>1</MultiDimensional>
<Parameter name="AUTOHISTORY" value="10"/>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="100"/>
<Parameter name="THRESHOLDUPPER" value="90"/>
<Parameter name="UNITS" value="%"/>
</Property>

<Property name="CompletedTasks">
<Description>
Completed Tasks (since previous day)</Description>
<Type>Ens.DataType.Metric</Type>
<MultiDimensional>1</MultiDimensional>
<Parameter name="AUTOHISTORY" value="10"/>
<Parameter name="RANGELOWER" value="0"/>
<Parameter name="RANGEUPPER" value="100"/>
<Parameter name="UNITS" value="Tasks"/>
</Property>

<Method name="OnCalculateMetrics">
<Description>
Calculate and update the set of metrics for this class</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// set the values of our metrics
	// %Instance is the current instance (RoleName in this case)
	Set tRole = ..%Instance

	Set ..ActiveTasks = ##class(EnsLib.Workflow.Engine).BamActiveTasks(tRole)
	Set ..Load = ##class(EnsLib.Workflow.Engine).BamActiveLoad(tRole)

	// Get task since start of previous day
	Set tStart = $ZDT($H-1,3)

	Set ..CompletedTasks = ##class(EnsLib.Workflow.Engine).BamCompletedTasks(tRole,tStart)

	Quit $$$OK
]]></Implementation>
</Method>

<Query name="MetricInstances">
<Description><![CDATA[
Set of instances for this metric class<br>
There is one instance for every defined role.]]></Description>
<Type>%SQLQuery</Type>
<SqlQuery>	SELECT Name FROM EnsLib_Workflow.RoleDefinition</SqlQuery>
</Query>
</Class>


<Class name="Demo.X12.BatchSortProduction">
<ClassType/>
<IncludeCode>EnsEDIX12</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>59883,81726.580565</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.X12.BatchSortProduction" TestingEnabled="false" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>1</ActorPoolSize>
  <Item Name="FileService" Category="" ClassName="EnsLib.EDI.X12.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" DisableErrorTraps="false" InactivityTimeout="20" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="ReplyTargetConfigNames"></Setting>
    <Setting Target="Host" Name="TargetConfigNames">SorterProcess</Setting>
    <Setting Target="Host" Name="SearchTableClass">EnsLib.EDI.X12.SearchTable</Setting>
    <Setting Target="Host" Name="DocSchemaCategory">837=837_X098, Interchange=ISC_00401, Group=ISC_00401</Setting>
    <Setting Target="Host" Name="Validation"></Setting>
    <Setting Target="Host" Name="ReplyMode">Never</Setting>
    <Setting Target="Host" Name="BatchHandling">1Session</Setting>
    <Setting Target="Host" Name="BatchErrorAction">Indiv</Setting>
    <Setting Target="Host" Name="BatchReplyType">None</Setting>
    <Setting Target="Host" Name="LocalApplicationID">EnsembleX12Service:03</Setting>
    <Setting Target="Host" Name="TolerateNewlines">1</Setting>
    <Setting Target="Host" Name="DefCharEncoding"></Setting>
    <Setting Target="Host" Name="AlertGracePeriod">0</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Test\X12\In</Setting>
    <Setting Target="Adapter" Name="FileSpec">*</Setting>
    <Setting Target="Adapter" Name="ArchivePath">C:\Test\X12\In\Old</Setting>
    <Setting Target="Adapter" Name="WorkPath">C:\Test\X12\In\Old</Setting>
    <Setting Target="Adapter" Name="Charset">binary</Setting>
    <Setting Target="Adapter" Name="FileAccessTimeout">10</Setting>
    <Setting Target="Adapter" Name="AppendTimestamp">1</Setting>
    <Setting Target="Adapter" Name="CallInterval">2.5</Setting>
  </Item>
  <Item Name="FileOperation1" Category="" ClassName="EnsLib.EDI.X12.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" DisableErrorTraps="false" InactivityTimeout="0" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="AutoBatchParentSegs">1</Setting>
    <Setting Target="Host" Name="SearchTableClass"></Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Test\X12\out</Setting>
    <Setting Target="Adapter" Name="Overwrite">1</Setting>
    <Setting Target="Adapter" Name="Charset">Default</Setting>
    <Setting Target="Adapter" Name="OpenTimeout">5</Setting>
  </Item>
  <Item Name="SorterProcess" Category="" ClassName="Demo.X12.SorterProcess" PoolSize="1" Enabled="true" Foreground="false" DisableErrorTraps="false" InactivityTimeout="0" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Host" Name="ReplyCodeActions"></Setting>
    <Setting Target="Host" Name="RetryInterval">5</Setting>
    <Setting Target="Host" Name="AlertRetryGracePeriod">0</Setting>
    <Setting Target="Host" Name="FailureTimeout">15</Setting>
    <Setting Target="Host" Name="AlertOnError">0</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.ByGroup.Production">
<Super>Ens.Production</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63277,54000.369125</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.X12.SorterDTL.ByGroup.Production" LogGeneralTraceEvents="false">
  <Description>This production sorts the Transaction Sets within an X12 Interchange into Groups.    While doing so it performs transforms on the Interchange, Groups, and Transaction Sets.</Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="SimpleRouter" Category="" ClassName="EnsLib.MsgRouter.VDocRoutingEngine" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Validation"></Setting>
    <Setting Target="Host" Name="BusinessRuleName">Demo.X12.SorterDTL.ByGroup.SimpleRule</Setting>
  </Item>
  <Item Name="ByGroupFileService" Category="" ClassName="EnsLib.EDI.X12.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="TargetConfigNames">SimpleRouter</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Test\X12\In</Setting>
    <Setting Target="Adapter" Name="ArchivePath"></Setting>
    <Setting Target="Adapter" Name="FileSpec">*</Setting>
    <Setting Target="Host" Name="BatchHandling">Whole</Setting>
    <Setting Target="Host" Name="DocSchemaCategory">HIPAA_5010</Setting>
    <Setting Target="Host" Name="BatchReplyType">None</Setting>
    <Setting Target="Host" Name="ReplyMode">Never</Setting>
  </Item>
  <Item Name="ByGroupFileOperation" Category="" ClassName="EnsLib.EDI.X12.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="FilePath">C:\Test\X12\Out</Setting>
    <Setting Target="Host" Name="Filename">GroupSort_%Q</Setting>
    <Setting Target="Host" Name="Separators">*!:~\r\n</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.ByGroup.SimpleRule">
<Description>
This Rule sends an Interchange to the transform before sending the newly transformed Interchange on to the File Operation.</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,47986.800188</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.VDocRuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.MsgRouter.VDocRoutingEngine" production="Demo.X12.SorterDTL.ByGroup.Production">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="Interchange Transform" disabled="false">
<constraint name="source" value="ByGroupFileService"></constraint>
<constraint name="msgClass" value="EnsLib.EDI.X12.Document"></constraint>
<constraint name="docCategory" value="HIPAA_5010"></constraint>
<constraint name="docName" value="Interchange"></constraint>
<when condition="1">
<send transform="Demo.X12.SorterDTL.ByGroup.SorterTransform" target="ByGroupFileOperation"></send>
<return></return>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.ByGroup.SorterTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,48126.995523</TimeCreated>
<DependsOn>EnsLib.EDI.X12.Document</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>0</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.EDI.X12.Document' targetClass='EnsLib.EDI.X12.Document' sourceDocType='HIPAA_5010:Interchange' targetDocType='HIPAA_5010:Interchange' create='copy' language='objectscript' >
<annotation>This sorts the Transaction Sets from an Interchange into Groups.  It also performs a few transforms on the Interchanges, Groups, and Transaction Sets which make use of the ability to easily access values from the Interchange, Group, and Transaction Set all in one place.</annotation>
<assign value='0' property='target.{GroupDocsRef:ChildCount}' action='set' >
<annotation>Initiate the child count in the Interchange to zero</annotation>
</assign>
<assign value='0' property='target.{IEA:NumberofIncludedFunctionalGr}' action='set' >
<annotation>Initiate the child count in the Interchange to zero</annotation>
</assign>
<assign value='$E($ZDATE($HOROLOG,8),3,*)' property='target.{ISA:InterchangeDate}' action='set' >
<annotation>Transform a value in the Interchange</annotation>
</assign>
<assign value='##class(%Library.ArrayOfObjects).%New()' property='ArrayOfGroups' action='set' >
<annotation>Create the array of Groups</annotation>
</assign>
<foreach property='source.{GroupDocsRef}' key='GroupIn' >
<annotation>Loop over the Groups in the Interchange</annotation>
<foreach property='GroupIn.{TransactionSetDocsRef}' key='TSIn' >
<annotation>Loop over the Transaction Sets in the Group</annotation>
<subtransform class='Demo.X12.SorterDTL.TSTransform' targetObj='TSOut' sourceObj='TSIn' >
<annotation>Transform the Transaction Set</annotation>
</subtransform>
<assign value='TSOut.{BPR:TransactionHandlingCode}' property='key' action='set' >
<annotation>This key is used in sorting the Transaction Sets into Groups</annotation>
</assign>
<assign value='##class(Demo.X12.SorterDTL.HelperMethods).FindParents(TSOut,GroupIn,ArrayOfGroups,,key)' property='tSC' action='set'  />
<assign value='TSOut.{BPR:AccountNumber}' property='target.{ISA:AuthorizationInformation}' action='set' >
<annotation>Use a value from the Transaction Set to determine a value in the Interchange</annotation>
</assign>
<assign value='ArrayOfGroups.GetAt(key)' property='GroupOut' action='set'  />
<assign value='target.{ISA:InterchangeReceiverId}_"_"_TSOut.{BPR:TransactionHandlingCode}' property='GroupOut.{GS:ApplicationReceiversCode}' action='set' >
<annotation>Use values from the Interchange and the Transaction Set to determine a value in the Group</annotation>
</assign>
</foreach>
</foreach>
<foreach property='ArrayOfGroups' key='tKey' >
<assign value='ArrayOfGroups.GetAt(tKey)' property='tGroupOut' action='set'  />
<subtransform class='Demo.X12.SorterDTL.GroupTransform' targetObj='tGroupOut' sourceObj='tGroupOut' >
<annotation>Transform the Group</annotation>
</subtransform>
<assign value='##class(Demo.X12.SorterDTL.HelperMethods).AddChildToDocsRef(tGroupOut,target,"GroupDocsRef")' property='tSC' action='set'  />
</foreach>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.ByInterchange.InterchangeTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,50340.453018</TimeCreated>
<DependsOn>EnsLib.EDI.X12.Document</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.EDI.X12.Document' targetClass='EnsLib.EDI.X12.Document' sourceDocType='HIPAA_5010:Interchange' targetDocType='HIPAA_5010:Interchange' create='existing' language='objectscript' >
<annotation>Copy the existing Interchange, but transform one value within it</annotation>
<assign value='$E($ZDATE($HOROLOG,8),3,*)' property='target.{ISA:InterchangeDate}' action='set' >
<annotation>Transform a value in the Interchange</annotation>
</assign>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.ByInterchange.Production">
<Super>Ens.Production</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63277,56170.827703</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.X12.SorterDTL.ByInterchange.Production" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="SortProcess" Category="" ClassName="Demo.X12.SorterDTL.ByInterchange.SimpleProcess" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="ByInterchangeFileService" Category="" ClassName="EnsLib.EDI.X12.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="TargetConfigNames">SortProcess</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\Test\X12\In</Setting>
    <Setting Target="Adapter" Name="ArchivePath"></Setting>
    <Setting Target="Adapter" Name="FileSpec">*</Setting>
    <Setting Target="Host" Name="DocSchemaCategory">HIPAA_5010</Setting>
    <Setting Target="Host" Name="ReplyTargetConfigNames"></Setting>
    <Setting Target="Host" Name="BatchHandling">Whole</Setting>
    <Setting Target="Host" Name="ReplyMode">Never</Setting>
    <Setting Target="Host" Name="BatchReplyType">None</Setting>
  </Item>
  <Item Name="ByInterchangeFileOperation" Category="" ClassName="EnsLib.EDI.X12.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="FilePath">C:\Test\X12\Out</Setting>
    <Setting Target="Host" Name="Filename">InterchangeSort_%Q</Setting>
    <Setting Target="Host" Name="Separators">*!:~\r\n</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.ByInterchange.SimpleProcess">
<Description>
This process calls for the sorting transform and then sends each resulting Interchange to the file operation.</Description>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,36602.361276</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='EnsLib.EDI.X12.Document' response='Ens.Response' height='2000' width='2000' >
<context>
<property name='ArrayOfGroups' type='EnsLib.EDI.X12.Document' collection='array' instantiate='0' >
</property>
<property name='key' type='%String' instantiate='0' >
<parameters>
<parameter name='MAXLEN'  value='50' />
</parameters>
</property>
<property name='ArrayOfInterchanges' type='EnsLib.EDI.X12.Document' collection='array' instantiate='0' >
</property>
</context>
<sequence xend='200' yend='450' >
<transform name='Split Transform' class='Demo.X12.SorterDTL.ByInterchange.SorterTransform' source='request' target='context.ArrayOfInterchanges' xpos='200' ypos='250' >
<annotation><![CDATA[The transform does the sorting.]]]]><![CDATA[></annotation>
</transform>
<foreach name='Interchange Loop' property='context.ArrayOfInterchanges' key='context.key' xpos='200' ypos='350' xend='200' yend='350' >
<annotation><![CDATA[Loop over the resulting Interchanges and send each to the file operation.]]]]><![CDATA[></annotation>
<call name='Output Interchange' target='ByInterchangeFileOperation' async='1' xpos='200' ypos='250' >
<request type='EnsLib.EDI.X12.Document' >
<assign property="callrequest" value="context.ArrayOfInterchanges.GetAt(context.key)" action="set" />
</request>
</call>
</foreach>
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.X12.SorterDTL.ByInterchange.SorterTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,37870.672548</TimeCreated>
<DependsOn>EnsLib.EDI.X12.Document,%ArrayOfObjects</DependsOn>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.EDI.X12.Document' targetClass='%ArrayOfObjects' sourceDocType='HIPAA_5010:Interchange' create='new' language='objectscript' >
<annotation>This sorts the Transaction Sets within an X12 Interchange into Groups and sorts those Groups into new Interchanges.  It also performs a few transforms on the Interchanges, Groups, and Transaction Sets which make use of the ability to easily access values from the Interchange, Group, and Transaction Set all in one place.</annotation>
<assign value='##class(%Library.ArrayOfObjects).%New()' property='ArrayOfGroups' action='set' >
<annotation>Create the array of Groups</annotation>
</assign>
<foreach property='source.{GroupDocsRef}' key='Group' >
<annotation>Loop over Groups in the Interchange</annotation>
<foreach property='Group.{TransactionSetDocsRef}' key='TSIn' >
<annotation>Loop over Transaction Sets in the Group</annotation>
<subtransform class='Demo.X12.SorterDTL.TSTransform' targetObj='TSOut' sourceObj='TSIn' >
<annotation>Transform the Transaction Set</annotation>
</subtransform>
<assign value='TSOut.{BPR:TransactionHandlingCode}' property='key1' action='set' >
<annotation>This key is used in sorting Transaction Sets into Groups.</annotation>
</assign>
<assign value='$Case(key1,"C":"C","H":"HP","P":"HP","I":"HP",:"UX")' property='key2' action='set' >
<annotation>This key is used in sorting Groups into Interchanges.</annotation>
</assign>
<assign value='##class(Demo.X12.SorterDTL.HelperMethods).FindParents(TSOut,Group,ArrayOfGroups,target,key1,key2)' property='tSC' action='set' >
<annotation>Note that target is the array of interchanges</annotation>
</assign>
<assign value='target.GetAt(key2)' property='InterOut' action='set'  />
<subtransform class='Demo.X12.SorterDTL.ByInterchange.InterchangeTransform' targetObj='InterOut' sourceObj='InterOut' >
<annotation>Transform the Interchange</annotation>
</subtransform>
<assign value='TSOut.{BPR:AccountNumber}' property='InterOut.{ISA:AuthorizationInformation}' action='set' >
<annotation>Use a Transaction Set value to transform a value in the Interchange</annotation>
</assign>
<assign value='source.{ISA:InterchangeReceiverID}_"_"_key2' property='InterOut.{ISA:InterchangeReceiverID}' action='set' >
<annotation>Transform a value in the Interchange</annotation>
</assign>
<assign value='##class(Demo.X12.SorterDTL.HelperMethods).SaveChanges(InterOut)' property='tSC' action='set'  />
<assign value='ArrayOfGroups.GetAt(key1)' property='GroupOut' action='set'  />
<subtransform class='Demo.X12.SorterDTL.GroupTransform' targetObj='GroupOut' sourceObj='GroupOut' >
<annotation>Transform the Group</annotation>
</subtransform>
<assign value='InterOut.{ISA:InterchangeReceiverID}_"-"_TSOut.{BPR:TransactionHandlingCode}' property='GroupOut.{GS:ApplicationReceiversCode}' action='set' >
<annotation>Use values from the Interchange and the Transaction Set to transform a value in the Group</annotation>
</assign>
<assign value='##class(Demo.X12.SorterDTL.HelperMethods).SaveChanges(GroupOut)' property='tSC' action='set'  />
</foreach>
</foreach>
</transform>
]]></Data>
</XData>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>
</Class>


<Class name="Demo.X12.SorterDTL.GroupTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,39208.373043</TimeCreated>
<DependsOn>EnsLib.EDI.X12.Document</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.EDI.X12.Document' targetClass='EnsLib.EDI.X12.Document' sourceDocType='HIPAA_5010:Group' targetDocType='HIPAA_5010:Group' create='existing' language='objectscript' >
<annotation>Copy the existing Group, but transform one value within it</annotation>
<assign value='$ZDATE($HOROLOG,8)' property='target.{GS:Date}' action='set' >
<annotation>Transform a value in the Group</annotation>
</assign>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterDTL.HelperMethods">
<Description>
This class consists of a number of helper methods which are used in the X12 Interchange and Group Sorting demos.
The purpose of these methods is to keep the DTL's in the demos as clean looking as possible so that the important
details can be more easily visible. </Description>
<IncludeCode>Ensemble</IncludeCode>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63277,49834.406857</TimeCreated>

<Method name="CreateNewGroupFromOld">
<Description><![CDATA[
Takes in an X12 Group <var>oldGroup</var> and returns a new Group with an identical 
GS segment and the same schema category. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oldGroup:EnsLib.EDI.X12.Document</FormalSpec>
<ReturnType>EnsLib.EDI.X12.Document</ReturnType>
<Implementation><![CDATA[
	Set tGroup = ##class(EnsLib.EDI.X12.Document).%New($LB("",oldGroup.Separators))
	Do tGroup.PokeDocType(oldGroup.DocType)
	Set tGS = oldGroup.GetSegmentAt("GS").%ConstructClone()
	Set tSC=tGroup.AppendSegment(tGS)
	Set tDataElementSeparator=$E(oldGroup.Separators,1)
	Set tPlaceholder=##class(EnsLib.EDI.X12.Segment).%New($LB("",1,"",$E(oldGroup.Separators,1,3)_"TransactionSetDocsRef"_tDataElementSeparator_2_tDataElementSeparator))
	Set tSC=tGroup.AppendSegment(tPlaceholder)
	Set tSC = tGroup.AddEndSegment()
	Quit tGroup
]]></Implementation>
</Method>

<Method name="CreateNewInterchangeFromOld">
<Description><![CDATA[
Takes in an X12 Interchange <var>oldInterchange</var> and returns a new Interchange with an identical
ISA segment (and TA1 segment, if relevant) and the same schema category. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oldInterchange:EnsLib.EDI.X12.Document</FormalSpec>
<ReturnType>EnsLib.EDI.X12.Document</ReturnType>
<Implementation><![CDATA[
	Set tInterchange = ##class(EnsLib.EDI.X12.Document).%New($LB("",oldInterchange.Separators))
	Do tInterchange.PokeDocType(oldInterchange.DocType)
	Set tISA = oldInterchange.GetSegmentAt("ISA").%ConstructClone()
	Set tSC=tInterchange.AppendSegment(tISA)
	Set tTA1 = oldInterchange.GetSegmentAt("TA1")
	If $IsObject(tTA1) {
		Set tTA1 = tTA1.%ConstructClone()
		Set tSC=tInterchange.AppendSegment(tTA1)
	}
	Set tDataElementSeparator=$E(oldInterchange.Separators,1)
	Set tPlaceholder=##class(EnsLib.EDI.X12.Segment).%New($LB("",1,"",$E(oldInterchange.Separators,1,3)_"GroupDocsRef"_tDataElementSeparator_(2+$IsObject(tTA1))_tDataElementSeparator))
	Set tSC=tInterchange.AppendSegment(tPlaceholder)
	Set tSC = tInterchange.AddEndSegment()
	Quit tInterchange
]]></Implementation>
</Method>

<Method name="CreateNewParentFromOld">
<Description><![CDATA[
Takes in an X12 Interchange or Group <var>oldParent</var> and creates from it a new Interchange or Group
in the Output variable <var>newParent</var>. Returns a status code.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oldParent:EnsLib.EDI.X12.Document,*newParent:EnsLib.EDI.X12.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If "Interchange"=oldParent.Name {
		Set newParent = ..CreateNewInterchangeFromOld(oldParent)
	} Elseif "Group"=oldParent.Name {
		Set newParent = ..CreateNewGroupFromOld(oldParent)
	} Else {
		Quit $$$ERROR($$$EnsErrGeneral,"Parent document must be Group or Interchange, not a "_oldParent.Name_".")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="AddChildToDocsRef">
<Description><![CDATA[
Adds a child X12 document <var>pChild</var>, (a Transaction Set or a Group) as the child of a Group or Interchange
<var>pParent</var>'s DocsRef segment.  <var>pDocsRefSeg</var> is the segment name for the DocsRef segment
("TransactionSetDocsRef" for a Group or "GroupDocsRef" for an Interchange).  Returns a status code.   ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pChild:EnsLib.EDI.X12.Document,pParent:EnsLib.EDI.X12.Document,pDocsRefSeg:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tSC = pParent.BuildMap()  Quit:$$$ISERR(tSC) tSC
 	Set index = pParent.GetSegmentIndex(pDocsRefSeg,.tSC) Quit:$$$ISERR(tSC) tSC
  	Set tSC = pParent.AddChild(index,pChild)  Quit:$$$ISERR(tSC) tSC
  	Set tSC = pParent.SetValueAt(1+pParent.GetValueAt((index+1)_":1"),(index+1)_":1")  Quit:$$$ISERR(tSC) tSC
  	Set tSC = pParent.%Save()
  	Quit tSC
]]></Implementation>
</Method>

<Method name="SaveChanges">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDoc:EnsLib.EDI.X12.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tSC = pDoc.BuildMap()  Quit:$$$ISERR(tSC) tSC
	Set tSC = pDoc.%Save()
	Quit tSC
]]></Implementation>
</Method>

<Method name="FindParents">
<Description><![CDATA[
Adds a child X12 document <var>pChild</var> as the child of the appropriate Group or Interchange document(s). 
<var>Parent1Array</var> is the array containing X12 documents of the docType that serves as a direct parent to <var>pChild</var>.
This means that if <var>pChild</var> is a Transaction Set, then <var>Parent1Array</var> should be an array of Groups,
but if <var>pChild</var> is a Group, then <var>Parent1Array</var> should be an array of Interchanges.
If relevant, <var>Parent2Array</var> is an array containing X12 documents of the docType that serves as a parent to the parent
of <var>pChild</var>.  This means that if <var>pChild</var> is a Transaction Set document, the <var>Parent2Array</var> should
be an array of Interchangess, but will otherwise be empty. 
<var>key1</var> determines which parent document in <var>Parent1Array</var>, <var>pChild</var> should be a child of. 
If no existing parent document is a match, a new parent document based on <var>pOldParent1</var> is created.  In the demos,
<var>pOldParent1</var> is the parent document to the original (non-transformed) document.
If relevant, <var>key2</var> determines which parent document in <var>Parent2Array</var>, the newly determined parent of 
<var>pChild</var> should be a child of.  This parent of the parent may also be created if no document in <var>Parent2Array</var>
already matches <var>key2</var>.  Returns status code.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pChild:EnsLib.EDI.X12.Document,pOldParent1:EnsLib.EDI.X12.Document,Parent1Array:%ArrayOfObjects,Parent2Array:%ArrayOfObjects,key1:%String="",key2:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If (""=key1)||(""=Parent1Array) {
		Quit $$$ERROR($$$EnsErrGeneral,"Both key and array of parents needed to find the parent for this child document")
	}
	Set parent1 = Parent1Array.GetAt(key1)
	If $$$NULLOREF = parent1 {
		Set tSC = ..CreateNewParentFromOld(pOldParent1, .parent1) Quit:$$$ISERR(tSC) tSC
		Set tSC = Parent1Array.SetAt(parent1,key1) Quit:$$$ISERR(tSC) tSC
		If ""'=key2 {
			Set tSC = ..FindParents(parent1,pOldParent1.Parent,Parent2Array,,key2)
		}
	}
	Quit:'$IsObject(parent1) $$$ERROR($$$EnsErrGeneral,"Parent document not found")
	Quit:(parent1.Name'="Interchange")&&(parent1.Name'="Group") $$$ERROR($$$EnsErrGeneral,"Parent document must be Group or Interchange, not a "_parent1.Name_".")
	Quit ..AddChildToDocsRef(pChild,parent1,$Case(parent1.Name,"Interchange":"GroupDocsRef","Group":"TransactionSetDocsRef",:""))
]]></Implementation>
</Method>
</Class>


<Class name="Demo.X12.SorterDTL.TSTransform">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>63305,39175.500779</TimeCreated>
<DependsOn>EnsLib.EDI.X12.Document</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.EDI.X12.Document' targetClass='EnsLib.EDI.X12.Document' sourceDocType='HIPAA_5010:835' targetDocType='HIPAA_5010:835' create='new' language='objectscript' >
<annotation>Transform the Transaction Set, making use of values from the Group and Interchange.</annotation>
<assign value='source.{ST}' property='target.{ST}' action='set'  />
<assign value='source.{BPR}' property='target.{BPR}' action='set'  />
<assign value='source.{TRN}' property='target.{TRN}' action='set'  />
<assign value='source.{CUR}' property='target.{CUR}' action='set'  />
<assign value='source.{REF()}' property='target.{REF()}' action='set'  />
<assign value='source.{DTM}' property='target.{DTM}' action='set'  />
<assign value='source.{loop1000A}' property='target.{loop1000A}' action='set'  />
<assign value='source.{loop1000B}' property='target.{loop1000B}' action='set'  />
<assign value='source.{loop2000()}' property='target.{loop2000()}' action='set'  />
<assign value='source.{PLB()}' property='target.{PLB()}' action='set'  />
<assign value='source.{SE}' property='target.{SE}' action='set'  />
<assign value='$zdate($horolog,8)' property='target.{DTM:Date}' action='set' >
<annotation>Transform a value in the Transaction Set</annotation>
</assign>
<assign value='source.Parent.Parent.{ISA:InterchangeSenderID}' property='target.{BPR:OriginatingCompanyIdentifier}' action='set' >
<annotation>Use a value from the Interchange to determine a value in the Transaction Set</annotation>
</assign>
<assign value='source.Parent.{GS:ApplicationSendersCode}' property='target.{BPR:OriginatingCompanySupplement}' action='set' >
<annotation>Use a value in the Group to determine a value in the Transaction Set</annotation>
</assign>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.X12.SorterProcess">
<ClassType>persistent</ClassType>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>65825,24675</TimeChanged>
<TimeCreated>61339,81492.54036</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='EnsLib.EDI.X12.Document' response='Ens.Response' height='2500' width='2500' >
<context>
<property name='Document' type='EnsLib.EDI.X12.Document' />
<property name='Payors' type='%ArrayOfObjects' />
<property name='CurrentPayor' type='%String' />
<property name='InterchangeId' type='%Integer' />
<property name='GroupId' type='%Integer' />
</context>
<sequence xend='550' yend='2330' >
<switch name='Document type' xpos='550' ypos='200' xend='550' yend='2230' >
<case condition='"Interchange"=request.Name' name='Interchange' >
<code name='Send payor Interchanges to their Operations' xpos='938' ypos='419' >
<annotation>The Interchange parent document arrives last; when it arrives we know to push out the parent Interchange documents we created</annotation>
<![CDATA[
	// construct a context array of objects from the global array of ids
	Set tPayor="" For { Set tPayor=$O(^CacheTemp.Sorter(request.%Id(),tPayor),1,tInterchangeId)  Quit:""=tPayor
		Do:""'=tInterchangeId context.Payors.SetAt(##class(EnsLib.EDI.X12.Document).%OpenId(tInterchangeId),tPayor)
	}
]]]]><![CDATA[>
</code>
<foreach name='Send payor Interchanges to their Operations' property='context.Payors' key='context.CurrentPayor' xpos='938' ypos='519' xend='550' yend='300' >
<call name='Send Interchange' target='FileOperation1' async='1' xpos='550' ypos='200' >
<request type='EnsLib.EDI.X12.Document' >
<assign property='callrequest' value='context.Payors.GetAt(context.CurrentPayor)' action='set' />
</request>
</call>
</foreach>
</case>
<case condition='"Group"=request.Name' name='Group' >
<code name='Send payor Groups to their Operations' xpos='550' ypos='394' >
<annotation>The Group parent document arrives last; when it arrives we know to push out the parent Group documents we created</annotation>
<![CDATA[
	// construct a context array of objects from the global array of ids
	Set tPayor="" For { Set tPayor=$O(^CacheTemp.Sorter($P(request.ParentId,":"),tPayor))  Quit:""=tPayor
		Set tGroupId=$G(^CacheTemp.Sorter($P(request.ParentId,":"),tPayor,"%Group"))
		Do:""'=tGroupId context.Payors.SetAt(##class(EnsLib.EDI.X12.Document).%OpenId(tGroupId),tPayor)
	}
]]]]><![CDATA[>
</code>
<foreach name='Send payor Groups to their Operations' property='context.Payors' key='context.CurrentPayor' xpos='550' ypos='494' xend='550' yend='300' >
<call name='Send Group' target='FileOperation1' async='1' xpos='550' ypos='200' >
<request type='EnsLib.EDI.X12.Document' >
<assign property='callrequest' value='context.Payors.GetAt(context.CurrentPayor)' action='set' />
</request>
</call>
</foreach>
</case>
<default name='TransactionSet' >
<assign name='Clone Request Doc' property='context.Document' value='request.%ConstructClone()' action='set' xpos='418' ypos='1470' />
<assign name='Get Payor' property='context.CurrentPayor' value='$ZConvert(request.{2000B(1).2010BB.NM1-34:3},"U")' action='set' xpos='148' ypos='370' >
<annotation>Send the TransactionSet to the right Payor batch</annotation>
</assign>
<assign name='Check Payor' property='context.CurrentPayor' value='$S(""=context.CurrentPayor:"Unknown",1:context.CurrentPayor)' action='set' xpos='148' ypos='470' />
<if name='Need New Interchange?' condition='""=$G(^CacheTemp.Sorter($P(request.TopParentId,":"),context.CurrentPayor))' xpos='148' ypos='570' xend='148' yend='1220' >
<true>
<assign name='Create new target Interchange' property='tNewInterchange' value='request.ParentInterchange.%ConstructClone()' action='set' xpos='418' ypos='1470' >
<annotation>Create a fresh parent Interchange for documents to this payor</annotation>
</assign>
<assign name='Set DocType' property='tNewInterchange.DocType' value='"ISC_00401:Interchange"' action='set' xpos='418' ypos='820' />
<assign name='Set IEA w/ Control Number' property='tNewInterchange.{IEA-4}' value='"IEA"_tNewInterchange.ElementSeparator_"0"_tNewInterchange.ElementSeparator_tNewInterchange.{ISA-1:InterchangeControlNumber}' action='set' xpos='418' ypos='820' />
<assign name='Set ISA receiver qualifier:' property='tNewInterchange.{ISA-1:InterchangeIDQualifier2}' value='"01"' action='set' xpos='418' ypos='820' />
<assign name='Set Payor Into ISA receiver:' property='tNewInterchange.{ISA-1:InterchangeReceiverID}' value='$$$PAD(context.CurrentPayor,15)' action='set' xpos='418' ypos='820' />
<assign name='Set Interchange Source' property='tNewInterchange.Source' value='context.CurrentPayor_$C(13)_$P(tNewInterchange.Source,$C(13),2,99)' action='set' xpos='418' ypos='1120' />
<assign name='Save Interchange' property='tStatus' value='tNewInterchange.%Save()' action='set' xpos='418' ypos='820' />
<assign name='Get Interchange Id' property='context.InterchangeId' value='tNewInterchange.%Id()' action='set' xpos='418' ypos='920' />
<assign name='Store Interchange Id' property='^CacheTemp.Sorter($P(request.TopParentId,":"),context.CurrentPayor)' value='context.InterchangeId' action='set' xpos='418' ypos='1020' />
</true>
<false>
<assign name='Get stored Interchange Id' property='context.InterchangeId' value='^CacheTemp.Sorter($P(request.TopParentId,":"),context.CurrentPayor)' action='set' xpos='148' ypos='720' />
</false>
</if>
<if name='Need New Group?' condition='""=$G(^CacheTemp.Sorter($P(request.TopParentId,":"),context.CurrentPayor,"%Group"))' xpos='148' ypos='1320' xend='148' yend='1970' >
<true>
<assign name='Create new target Group' property='tNewGroup' value='request.Parent.%ConstructClone()' action='set' xpos='418' ypos='1470' >
<annotation>Create a fresh parent group for documents of this type to this payor</annotation>
</assign>
<assign name='Set DocType' property='tNewGroup.DocType' value='"ISC_00401:Group"' action='set' xpos='418' ypos='820' />
<assign name='Set GE w/ Control Number' property='tNewGroup.{GE-3}' value='"GE"_tNewGroup.ElementSeparator_"0"_tNewGroup.ElementSeparator_tNewGroup.{GS-1:GroupControlNumber}' action='set' xpos='418' ypos='820' />
<assign name='Add Group to Interchange' property='tNewGroup.ParentId' value='context.InterchangeId_":2"' action='set' xpos='418' ypos='1570' />
<assign name='Save Group' property='tStatus' value='tNewGroup.%Save()' action='set' xpos='418' ypos='1670' />
<assign name='Get Group Id' property='context.GroupId' value='tNewGroup.%Id()' action='set' xpos='418' ypos='1770' />
<assign name='Store Group Id' property='^CacheTemp.Sorter($P(request.TopParentId,":"),context.CurrentPayor,"%Group")' value='context.GroupId' action='set' xpos='418' ypos='1870' />
</true>
<false>
<assign name='Get stored Group Id' property='context.GroupId' value='^CacheTemp.Sorter($P(request.TopParentId,":"),context.CurrentPayor,"%Group")' action='set' xpos='148' ypos='1470' />
</false>
</if>
<assign name='Add to Group' property='context.Document.ParentId' value='context.GroupId_":2"' action='set' xpos='148' ypos='2053' />
<call name='Send to Operation' target='FileOperation1' async='1' xpos='149' ypos='2148' >
<request type='EnsLib.EDI.X12.Document' >
<assign property='callrequest' value='context.Document' action='set' />
</request>
</call>
</default>
</switch>
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.ZENReports.MessageReport">
<Description>
Demo.ZENReports.MessageReport</Description>
<Super>%ZEN.Report.reportPage</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62887,60437.148709</TimeCreated>

<Parameter name="APPLICATION">
<Description>
Class name of application this report belongs to.</Description>
</Parameter>

<Parameter name="DEFAULTMODE">
<Description><![CDATA[
Specifies the default display mode used for this report if
the URL parameter, <var>$MODE</var>, is not present.]]></Description>
<Type>STRING</Type>
<Constraint>,html,tohtml,toxslfo,pdf,xml,xslfo,excel,toexcel,ps,pdfprint,xlsx</Constraint>
<Default>pdf</Default>
<Flags>ENUM</Flags>
</Parameter>

<Parameter name="REPORTXMLNAMESPACE">
<Description>
This is the optional XML namespace used for the report.</Description>
</Parameter>

<Property name="Units">
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"DAYS"</InitialExpression>
<Parameter name="VALUELIST" value=",DAYS,HOURS"/>
<Parameter name="ZENURL" value="UNITS"/>
</Property>

<Property name="Value">
<Type>%ZEN.Datatype.float</Type>
<InitialExpression>"-1"</InitialExpression>
<Parameter name="ZENURL" value="VALUE"/>
</Property>

<XData name="ReportDefinition">
<Description>
This XML defines the logical contents of this report.</Description>
<XMLNamespace>http://www.intersystems.com/zen/report/definition</XMLNamespace>
<Data><![CDATA[
<report xmlns="http://www.intersystems.com/zen/report/definition"
 name="MyReport" runonce="true">
 <group name="RunReport">
 <attribute name="TimeStamp" expression="$ZDT($H)"/>
 </group>
<group name="Sources" OnCreateResultSet="GetMessages">
<group name="Source">
<attribute name="SourceCount" field="SourceCount"/>
<attribute name="MessageSource" field="SourceConfigName"/>
</group>
</group>
</report>
]]></Data>
</XData>

<XData name="ReportDisplay">
<Description>
This XML defines the display for this report.
This is used to generate the XSLT stylesheets for both HTML and XSL-FO.</Description>
<XMLNamespace>http://www.intersystems.com/zen/report/display</XMLNamespace>
<Data><![CDATA[
<report xmlns="http://www.intersystems.com/zen/report/display"
 name="MyReport">
<!-- Optional Init element inserts custom XSLT instructions at the top level of the generated XSLT stylesheet. -->
<init ></init>
<!-- Optional Document element specifies page layout and style characteristics. -->
<document width="8.5in" height="11in" marginLeft="1.25in" marginRight="1.25in" marginTop="1.0in" marginBottom="1.0in" footerHeight="1.0in"  ></document>
<!-- Optional Pageheader element. -->
<pageheader >
</pageheader>
<!-- Optional Pagefooter element. Does not apply in HTML output. -->
<pagefooter >
<item special="page-count"/>
</pagefooter>
<!-- Required Body element. -->
<body>
<header>
<p class="banner1">Message Sources and Their Count</p>
<fo><line pattern="empty"/><line pattern="empty"/></fo>
<table orient="row" align="center">
<item field="RunReport/@TimeStamp">
<caption value="Report Time Stamp:"/>
</item>
</table>
<line pattern="empty"/>

</header>
<!-- add display definition of the report here. -->
<group name="Sources">
<table group="Source" class="table2">
<item field="@SourceCount" width="2in">
<caption value="Count"/>
</item>
<item field="@MessageSource" width="5in">
<caption value="Source"/>
</item>
</table>
</group>
</body>
</report>
]]></Data>
</XData>

<Method name="GetMessages">
<FormalSpec><![CDATA[&pSC,&tParams]]></FormalSpec>
<Implementation><![CDATA[
	set statement=##class(%SQL.Statement).%New() 
	If ..Units="DAYS" {
		Set sql = "select count(*) As SourceCount, SourceConfigName from Ens.MessageHeader where timecreated>DATEADD('day',"_..Value_",GETUTCDATE()) and timecreated<GETUTCDATE() group by SourceConfigName"
	} Elseif ..Units="HOURS" {
		Set sql = "select count(*) As SourceCount, SourceConfigName from Ens.MessageHeader where timecreated>DATEADD('hour',"_..Value_",GETUTCDATE()) and timecreated<GETUTCDATE() group by SourceConfigName"

	} Else {
		Set pSC=$$$ERROR($$$GeneralError,"Units property was not valid")
		Quit ""
	}
	Set pSC=statement.%Prepare(sql)
	Set statement.%SelectMode=2
	If $$$ISERR(pSC) Quit ""
	If $D(tParams) {
		Set rs=statement.%Execute(tParams)
	} else {
		Set rs=statement.%Execute()
	}
   	Quit rs
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ZenService.Boper.ConvertTemp">
<Description>
Business operation responsible for converting temperature bewteen Celsius and Fahrenheit.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>62110,44225.056837</TimeChanged>
<TimeCreated>61748,4117.658684</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Use our own simple adapter since this business operation does not call outside Ensemble</Description>
<Default>Ens.OutboundAdapter</Default>
</Parameter>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Method name="Convert">
<Description>
Accept an incoming Demo.ZenService.Msg.ConvertTempRequest which contains properties Direction and InputTemp.
Direction may have a case-sensitive value of "CToF" (Celsius to Fahrenheit) or "FToC" (Fahrenheit to Celsius).
Convert the incoming InputTemp in the indicated Direction and store the result in the outgoing
Demo.ZenService.Msg.ConvertTempResponse which contains an OutputTemp property to hold the result.</Description>
<FormalSpec>pRequest:Demo.ZenService.Msg.ConvertTempRequest,*pResponse:Demo.ZenService.Msg.ConvertTempResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Call a method on this business operation (just an example; usually you would call outside Ensemble)
	set response = ..ConvertTemp(pRequest.Direction,pRequest.InputTemp)

	// Instantiate the response message object
	set pResponse = ##class(Demo.ZenService.Msg.ConvertTempResponse).%New()
	
	// Assign the response to the response message property
	set pResponse.OutputTemp = response

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ConvertTemp">
<Description>
Convert a temperature from Celsius to Fahrenheit (direction="CToF") or 
Fahrenheit to Centigrade (direction="FToC"). The dir argument
gives the direction to convert in ("CToF" or "FToC") and the
temp argument gives the temperature value.</Description>
<FormalSpec>dir:%String,temp:%Integer</FormalSpec>
<Implementation><![CDATA[
	If (dir = "CToF") {
		Quit ..CToF(temp)
	}
	ElseIf (dir = "FToC") {
		Quit ..FToC(temp)
	}
	Else {
		Quit temp
	}
]]></Implementation>
</Method>

<Method name="CToF">
<FormalSpec>input:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit (input*1.8)+32
]]></Implementation>
</Method>

<Method name="FToC">
<FormalSpec>input:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit (input-32)/1.8
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Demo.ZenService.Msg.ConvertTempRequest"> 
		<Method>Convert</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Boper.GetTranslation">
<Description>
Business operation responsible for providing a translation to/from the requested languages.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>62110,44235.821616</TimeChanged>
<TimeCreated>61762,2832.029151</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Use our own simple adapter since this business operation does not call outside Ensemble</Description>
<Default>Ens.OutboundAdapter</Default>
</Parameter>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Method name="Translate">
<Description>
Get the information out of the request message to translate the weather report into another language.
The request message Demo.ZenService.Msg.TranslationRequest has three properties, FromLanguage, ToLanguage, and
TextToTranslate. The response message Demo.ZenService.Msg.TranslationResponse has one property, TranslatedText.</Description>
<FormalSpec>pRequest:Demo.ZenService.Msg.TranslationRequest,*pResponse:Demo.ZenService.Msg.TranslationResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Call a method on this business operation (just an example; usually you would call outside Ensemble)
	Set response = ..GetTranslation(pRequest.FromLanguage,pRequest.ToLanguage,pRequest.TextToTranslate)
	
	// Instantiate the response message object
	Set pResponse = ##class(Demo.ZenService.Msg.TranslationResponse).%New()

	// Get the translated text and put it into the response message
	Set pResponse.TranslatedText = response

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetTranslation">
<Description>
Translate from the identified language (first argument) to the identified language (second argument). 
The text to translate is the last argument, text. Since this is a sample, this is actually a static method so that only
the value for the "to" argument has meaning. If it is "French" or "Italian" or "Spanish" or "German" there is a
statically identified translation (the same translation for any input value).</Description>
<FormalSpec>from:%String,to:%String,text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set response = $CASE(to,"French":"Je suis une porte",
							"Italian":"Questo caldo mi fa stanco",
							"Spanish":"Creo que va a llover",
							"German":"Wo ist das Treffen?",
							:"No translation is available")
	Quit response
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Demo.ZenService.Msg.TranslationRequest"> 
		<Method>Translate</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Boper.GetWeatherReport">
<Description>
Business operation responsible for obtaining a string that tells the weather, based on an input string that gives a location.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<TimeChanged>62110,44250.33186</TimeChanged>
<TimeCreated>61747,84757.590883</TimeCreated>

<Parameter name="ADAPTER">
<Description>
Use our own simple adapter since this business operation does not call outside Ensemble</Description>
<Default>Ens.OutboundAdapter</Default>
</Parameter>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Method name="GetWeatherReport">
<FormalSpec>pRequest:Ens.StringRequest,*pResponse:Demo.ZenService.Msg.WeatherOperationResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Call a method on this business operation (just an example; usually you would call outside Ensemble)
	Set response = ..GetTheWeather(pRequest.StringValue)
	
	// Instantiate the response message object
	Set pResponse = ##class(Demo.ZenService.Msg.WeatherOperationResponse).%New()
	
	// Break apart the response string and assign values to properties
	Set pResponse.Forecast = $P(response,"|",1)
	Set pResponse.MinTemperature = $P(response,"|",2)
	Set pResponse.MaxTemperature = $P(response,"|",3)
	
	// If there was a problem with the response string, get defaults 
	If ""=pResponse.Forecast { set pResponse.Forecast = "Mostly sunny with the occasional shower" }
	If ""=pResponse.MinTemperature { set pResponse.MinTemperature = 22 }
	If ""=pResponse.MaxTemperature { set pResponse.MaxTemperature = 35 }

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetTheWeather">
<FormalSpec>location:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set response = $CASE(location,"":"No weather|0|0",
								  "London":"Raining|-2|1",
								  "UK":"Raining|-2|1",
								  "England":"Raining|-2|1",
								  :"Scorching|25|35")
	Quit response
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Ens.StringRequest"> 
		<Method>GetWeatherReport</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Bproc.WeatherReport.LanguageFromLocation">
<Description>
Business rule responsible for mapping an input location to an output language.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62105,54404.980969</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>Ens.Rule.GeneralBusinessRuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="Demo.ZenService.Bproc.WeatherReport.Context">
<ruleSet effectiveBegin="" effectiveEnd="">
<rule name="" disabled="false">
<when condition="(Location = &quot;US&quot;)||(Location = &quot;USA&quot;)||(Location = &quot;England&quot;)||(Location = &quot;London&quot;)||(Location = &quot;UK&quot;)">
<return>"English"</return>
</when>
<when condition="(Location = &quot;Spain&quot;)||(Location = &quot;Mexico&quot;)">
<return>"Spanish"</return>
</when>
<when condition="Location = &quot;France&quot;">
<return>"French"</return>
</when>
<when condition="Location = &quot;Italy&quot;">
<return>"Italian"</return>
</when>
<when condition="Location = &quot;Germany&quot;">
<return>"German"</return>
</when>
<otherwise>
<return>"Unknown"</return>
</otherwise>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Bproc.WeatherReport.TempScale">
<Description>
Business rule responsible for mapping an input location to "F" for Fahrenheit or "C" for Celsius temperature scale.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62105,48801.023522</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>Ens.Rule.GeneralBusinessRuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="Demo.ZenService.Bproc.WeatherReport.Context">
<ruleSet effectiveBegin="" effectiveEnd="">
<rule name="" disabled="false">
<when condition="(Location=&quot;US&quot;)||(Location=&quot;USA&quot;)">
<return>"F"</return>
</when>
<otherwise>
<return>"C"</return>
</otherwise>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Bproc.WeatherReport">
<Description>
BPL business process responsible for getting a weather report and providing the results
in the appropriate language and temperature scale for the locale.</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>62110,49095.038594</TimeChanged>
<TimeCreated>62104,56118.94526</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Ens.StringRequest' response='Demo.ZenService.Msg.WeatherReportResponse' height='2000' width='2000' >
<context>
<property name='Location' type='%String' >
</property>
<property name='OperationReport' type='Demo.ZenService.Msg.WeatherOperationResponse' >
</property>
<property name='TempScale' type='%Library.String' >
</property>
<property name='OutputTemp' type='%String' >
</property>
<property name='Language' type='%Library.String' >
</property>
</context>
<sequence xend='200' yend='850' >
<assign name="Store Location" property="context.Location" value="request.StringValue" action="set" xpos='200' ypos='250' >
<annotation><![CDATA[Assign the StringValue from the request to the business process context property called Location.]]]]><![CDATA[></annotation>
</assign>
<call name='Get Weather Report' target='Get Weather Report' async='0' xpos='200' ypos='350' >
<annotation>Make a synchronous call to the business operation Get Weather Report, sending it the context property Location and placing the response in the context property OperationReport.</annotation>
<request type='Ens.StringRequest' >
<assign property="callrequest.StringValue" value="context.Location" action="set" />
</request>
<response type='Demo.ZenService.Msg.WeatherOperationResponse' >
<assign property="context.OperationReport" value="callresponse" action="set" />
</response>
</call>
<sequence name='Convert Temp' xpos='200' ypos='450' xend='200' yend='800' >
<annotation>Invoke the TempScale rule. Depending on location the temperature should be reported in Fahrenheit or Celsius. Store the result in the context property TempScale. </annotation>
<rule name='Temp Scale' rule='TempScale'  resultLocation='context.TempScale' xpos='200' ypos='250' >
<annotation>Invoke the TempScale rule. If the Location is US or USA then the temperature scale is F; otherwise it is C. Put the result in the context property TempScale. </annotation>
</rule>
<if name='Convert?' condition='context.TempScale="F"' xpos='200' ypos='350' xend='200' yend='700' >
<annotation>Test whether the context property TempScale is F. If so, do the conversion to Fahrenheit. </annotation>
<true>
<call name='Convert Min Temp' target='Convert Temperature' async='0' xpos='335' ypos='500' >
<annotation>Call the Convert Temperature business operation to convert the day&#39;s minimum temperature from Celsius to Fahrenheit. Put the result in the context property OperationReport.</annotation>
<request type='Demo.ZenService.Msg.ConvertTempRequest' >
<assign property="callrequest.Direction" value="&quot;CToF&quot;" action="set" />
<assign property="callrequest.InputTemp" value="context.OperationReport.MinTemperature" action="set" />
</request>
<response type='Demo.ZenService.Msg.ConvertTempResponse' >
<assign property="context.OperationReport.MinTemperature" value="callresponse.OutputTemp" action="set" />
</response>
</call>
<call name='Convert Max Temp' target='Convert Temperature' async='0' xpos='335' ypos='600' >
<annotation>Call the Convert Temperature business operation to convert the day&#39;s maximum temperature from Celsius to Fahrenheit. Put the result in the context property OperationReport.</annotation>
<request type='Demo.ZenService.Msg.ConvertTempRequest' >
<assign property="callrequest.Direction" value="&quot;CToF&quot;" action="set" />
<assign property="callrequest.InputTemp" value="context.OperationReport.MaxTemperature" action="set" />
</request>
<response type='Demo.ZenService.Msg.ConvertTempResponse' >
<assign property="context.OutputTemp" value="callresponse.OutputTemp" action="set" />
<assign property="context.OperationReport.MaxTemperature" value="callresponse.OutputTemp" action="set" />
</response>
</call>
</true>
</if>
</sequence>
<sequence name='Translate' xpos='200' ypos='550' xend='200' yend='700' >
<annotation>Invoke the LanguageFromLocation rule which maps a country name to the language spoken there. If the language is other than English, translate the weather report.</annotation>
<rule name='Language?' rule='LanguageFromLocation'  resultLocation='context.Language' xpos='200' ypos='250' >
<annotation>Invoke the LanguageFromLocation rule to map the location to English, French, Spanish, Italian, orGerman. The result goes in the context property Language.</annotation>
</rule>
<if name='English?' condition='context.Language="English"' xpos='200' ypos='350' xend='200' yend='600' >
<annotation>If the language is not English then translate the weather response text from English into the language we got from the rule.</annotation>
<false>
<call name='Translate' target='Get Translation' async='0' xpos='335' ypos='500' >
<annotation>Do the translation and put the result into the context property OperationReport.</annotation>
<request type='Demo.ZenService.Msg.TranslationRequest' >
<assign property="callrequest.FromLanguage" value="&quot;English&quot;" action="set" />
<assign property="callrequest.TextToTranslate" value="context.OperationReport.Forecast" action="set" />
<assign property="callrequest.ToLanguage" value="context.Language" action="set" />
</request>
<response type='Demo.ZenService.Msg.TranslationResponse' >
<assign property="context.OperationReport.Forecast" value="callresponse.TranslatedText" action="set" />
</response>
</call>
</false>
</if>
</sequence>
<transform name='Transform Response' class='Demo.ZenService.Dtl.OperationToResponseReport' source='context.OperationReport' target='response' xpos='200' ypos='650' >
<annotation>Begin transforming the context property OperationReport into the response object required by the business service that invoked this business process.</annotation>
</transform>
<code name='Add Scale' xpos='200' ypos='750' >
<annotation>Complete the creation of the response object required by the business service by invoking code to place the TempScale value in the object.</annotation>
<![CDATA[ set response.TempScale = context.TempScale]]]]><![CDATA[>
</code>
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Demo.ZenService.Bserv.ZenService">
<Description>
This business service takes an Ens.StringContainer as input and returns
a Demo.ZenService.Msg.WeatherReportResponse to the caller as output.
It is invoked from the Zen page Demo.ZenService.Zen.WeatherReportForm and invokes the business process that
has been configured in the production with the name "Weather Report".</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService</Super>
<TimeChanged>62109,63206.204728</TimeChanged>
<TimeCreated>61781,44695.019298</TimeCreated>

<Method name="OnProcessInput">
<FormalSpec>pInput:Ens.StringContainer,pOutput:Demo.ZenService.Msg.WeatherReportResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Create the request message
	Set request = ##class(Ens.StringRequest).%New()
	
	// Place a value in the request message property
	Set request.StringValue = pInput.StringValue
	
	// Make a synchronous call to the business process and use the response message as our response 
	Set tSC = ..SendRequestSync("Weather Report", request, .pOutput)

	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Demo.ZenService.Dtl.OperationToResponseReport">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65825,24674</TimeChanged>
<TimeCreated>62105,53225.79101</TimeCreated>
<DependsOn>Demo.ZenService.Msg.WeatherReportResponse,Demo.ZenService.Msg.WeatherOperationResponse</DependsOn>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<?xml version="1.0" ?>
<transform targetClass='Demo.ZenService.Msg.WeatherReportResponse' sourceClass='Demo.ZenService.Msg.WeatherOperationResponse' create='new' language='objectscript'>
<assign property='target.Report' value='source.Forecast' action='set'/>
<assign property='target.MinTemp' value='source.MinTemperature' action='set'/>
<assign property='target.MaxTemp' value='source.MaxTemperature' action='set'/>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Msg.ConvertTempRequest">
<Super>Ens.Request</Super>
<TimeChanged>62109,63226.197689</TimeChanged>
<TimeCreated>61748,4117.88244</TimeCreated>

<Property name="Direction">
<Type>%String</Type>
</Property>

<Property name="InputTemp">
<Type>%Integer</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ConvertTempRequestDefaultData</DefaultData>
<Data name="ConvertTempRequestDefaultData">
<Structure>listnode</Structure>
<Subscript>"ConvertTempRequest"</Subscript>
<Value name="1">
<Value>Direction</Value>
</Value>
<Value name="2">
<Value>InputTemp</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ZenService.Msg.ConvertTempResponse">
<Super>Ens.Response</Super>
<TimeChanged>62109,63231.982313</TimeChanged>
<TimeCreated>61748,4176.17565</TimeCreated>

<Property name="OutputTemp">
<Type>%Integer</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ConvertTempResponseDefaultData</DefaultData>
<Data name="ConvertTempResponseDefaultData">
<Structure>listnode</Structure>
<Subscript>"ConvertTempResponse"</Subscript>
<Value name="1">
<Value>OutputTemp</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ZenService.Msg.TranslationRequest">
<Super>Ens.Request</Super>
<TimeChanged>62109,63238.370345</TimeChanged>
<TimeCreated>61762,2680.06232</TimeCreated>

<Property name="FromLanguage">
<Type>%String</Type>
</Property>

<Property name="ToLanguage">
<Type>%String</Type>
</Property>

<Property name="TextToTranslate">
<Type>%String</Type>
<Parameter name="MAXLEN" value="32000"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>TranslationRequestDefaultData</DefaultData>
<Data name="TranslationRequestDefaultData">
<Structure>listnode</Structure>
<Subscript>"TranslationRequest"</Subscript>
<Value name="1">
<Value>FromLanguage</Value>
</Value>
<Value name="2">
<Value>ToLanguage</Value>
</Value>
<Value name="3">
<Value>TextToTranslate</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ZenService.Msg.TranslationResponse">
<Super>Ens.Response</Super>
<TimeChanged>62109,63244.713763</TimeChanged>
<TimeCreated>61762,2680.391883</TimeCreated>

<Property name="TranslatedText">
<Type>%String</Type>
<Parameter name="MAXLEN" value="32000"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>TranslationResponseDefaultData</DefaultData>
<Data name="TranslationResponseDefaultData">
<Structure>listnode</Structure>
<Subscript>"TranslationResponse"</Subscript>
<Value name="1">
<Value>TranslatedText</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ZenService.Msg.WeatherOperationResponse">
<Super>Ens.Response</Super>
<TimeChanged>62109,63250.928366</TimeChanged>
<TimeCreated>61747,84889.646396</TimeCreated>

<Property name="Forecast">
<Type>%String</Type>
<Parameter name="MAXLEN" value="32000"/>
</Property>

<Property name="MinTemperature">
<Type>%Integer</Type>
</Property>

<Property name="MaxTemperature">
<Type>%Integer</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>WeatherOperationResponseDefaultData</DefaultData>
<Data name="WeatherOperationResponseDefaultData">
<Structure>listnode</Structure>
<Subscript>"WeatherOperationResponse"</Subscript>
<Value name="1">
<Value>Forecast</Value>
</Value>
<Value name="2">
<Value>MinTemperature</Value>
</Value>
<Value name="3">
<Value>MaxTemperature</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ZenService.Msg.WeatherReportResponse">
<Description>
This is the message used to respond to the caller of the Zen Service business service
which in this case is the Zen page Demo.ZenService.Zen.WeatherReportForm.</Description>
<Super>Ens.Response</Super>
<TimeChanged>62109,63257.730053</TimeChanged>
<TimeCreated>61747,84889.646396</TimeCreated>

<Property name="Report">
<Description>
Some arbitrary string of words</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="32000"/>
</Property>

<Property name="MinTemp">
<Description>
Minimum temperature for the day</Description>
<Type>%Integer</Type>
</Property>

<Property name="MaxTemp">
<Description>
Maximum temperature for the day</Description>
<Type>%Integer</Type>
</Property>

<Property name="TempScale">
<Description>
Fahrenheit or Celsius</Description>
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>WeatherReportResponseDefaultData</DefaultData>
<Data name="WeatherReportResponseDefaultData">
<Subscript>"WeatherReportResponse"</Subscript>
<Value name="1">
<Value>Report</Value>
</Value>
<Value name="2">
<Value>MinTempF</Value>
</Value>
<Value name="3">
<Value>MaxTempF</Value>
</Value>
<Value name="4">
<Value>MinTemp</Value>
</Value>
<Value name="5">
<Value>MaxTemp</Value>
</Value>
<Value name="6">
<Value>TempScale</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Demo.ZenService.Prod.GetTheWeather">
<Description>
Production for getting the weather. Note that the business service in this production is invoked from a Zen page.
For details, see Demo.ZenService.Zen.WeatherReportForm, a Zen class that provides the main application page.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>62109,63265.67037</TimeChanged>
<TimeCreated>61765,56805.965937</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Demo.ZenService.Prod.GetTheWeather" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Setting Target="Production" Name="ShutdownTimeout">120</Setting>
  <Setting Target="Production" Name="UpdateTimeout">10</Setting>
  <Item Name="Get Weather Report" Category="" ClassName="Demo.ZenService.Boper.GetWeatherReport" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Convert Temperature" Category="" ClassName="Demo.ZenService.Boper.ConvertTemp" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Get Translation" Category="" ClassName="Demo.ZenService.Boper.GetTranslation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Zen Service" Category="" ClassName="Demo.ZenService.Bserv.ZenService" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="InactivityTimeout">0</Setting>
  </Item>
  <Item Name="Weather Report" Category="" ClassName="Demo.ZenService.Bproc.WeatherReport" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Zen.Application">
<Description>
Demo.ZenService.Zen.Application provides general information about the Zen application, including the translation domain.
For the main application page, see Demo.ZenService.Zen.WeatherReportForm.</Description>
<Super>%ZEN.application</Super>
<TimeChanged>62109,63273.086024</TimeChanged>
<TimeCreated>61780,80986.56371</TimeCreated>

<Parameter name="APPLICATIONNAME">
<Description>
This is the name of this application.</Description>
<Default>Weather Application</Default>
</Parameter>

<Parameter name="HOMEPAGE">
<Description>
This is the URL of the main starting page of this application.</Description>
<Default>Demo.ZenService.Zen.WeatherReportForm.cls</Default>
</Parameter>

<Parameter name="DOMAIN">
<Description>
Domain used for localization.</Description>
<Default>MyDomain</Default>
</Parameter>

<XData name="Style">
<Description>
This Style block contains application-wide CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
</style>
]]></Data>
</XData>
</Class>


<Class name="Demo.ZenService.Zen.WeatherReportForm">
<Description><![CDATA[
This Zen page displays an interface to the user who wants a weather report.
It shows seven days' worth of static images. When the user clicks the
Get Report button, the page calls its showWeather() client method which in turn calls its
GetWeatherReport() server method to invoke the Zen Service business service to get the weather.
The weather report returns as the output of the GetWeatherReport() method and
the display changes accordingly.
<p>
This simple demonstration depends on some static values that have already been prepared. The most
meaningful values to enter for location are "US" "USA" "UK" "England" "London" "Germany" "France" "Spain" "Mexico" and "Italy".
You may enter other locations but will not get very meaningful results.]]></Description>
<Super>%ZEN.Component.page</Super>
<TimeChanged>62110,50789.644908</TimeChanged>
<TimeCreated>61780,85098.166425</TimeCreated>

<Parameter name="APPLICATION">
<Description>
Class name of application this page belongs to.</Description>
<Default>Demo.ZenService.Zen.Application</Default>
</Parameter>

<Parameter name="PAGENAME">
<Description>
Displayed name of this page.</Description>
<Default>WeatherReportForm</Default>
</Parameter>

<XData name="Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
/* set style used for html element */
#html1 {
	border: 1px solid darkblue;
	background: DFEFFF;
	padding: 5px;
	width: 500px;
}
/* Style for labelText component. */
.labelText {
	font-size: x-large;
}

</style>
]]></Data>
</XData>

<XData name="Contents">
<Description>
This XML block defines the contents of this page, which consists of Zen components and groups.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" title="Ensemble Weather Report">
<hgroup align="left">
<spacer width="50"/>
<vgroup>
<spacer height="30"/>
<label id="title" align="center" value="Welcome to the Ensemble Weather Report"/>
<spacer height="5"/>
<hgroup align="center">
<image align="center" src="/csp/ensdemo/images/rain.gif"/>
<image align="center" src="/csp/ensdemo/images/clearday.gif"/>
<image align="center" src="/csp/ensdemo/images/mcloudyday.gif"/>
<image align="center" src="/csp/ensdemo/images/rain.gif"/>
<image align="center" src="/csp/ensdemo/images/clearday.gif"/>
<image align="center" src="/csp/ensdemo/images/mcloudyday.gif"/>
<image align="center" src="/csp/ensdemo/images/rain.gif"/>
</hgroup>
<spacer height="10"/>
<hgroup align="center">
<combobox align="center" id="txtLocation" label="Location"  
         valueList="England,France,Germany,Italy,London,Mexico,Spain,UK,USA" 
          onchange="zenPage.showWeather();" />
</hgroup>
<spacer height="25"/>
<html id="html1"><!-- initially empty -->
</html>

</vgroup>
</hgroup>
</page>
]]></Data>
</XData>

<Method name="showWeather">
<Description>
Client method showWeather() is called when the user selects a location from the drop-down list.
showWeather() gets the value from the list
and sends it as the location argument to be used with server method GetWeatherReport().</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	try {
		var location = zen('txtLocation').getValue();
		zenPage.GetWeatherReport(location);
	}
	catch (ex) {
		zenExceptionHandler(ex,arguments);
	}
]]></Implementation>
</Method>

<Method name="GetWeatherReport">
<Description><![CDATA[
GetWeatherReport() is a server side ZenMethod. It starts processing by invoking the ProcessInput() method of the
business service called Zen Service in the production. The output of this call
is a message of a particular type, Demo.ZenService.Msg.WeatherReportResponse. GetWeatherReport()
inserts the properties of this message into a string which it displays as the
HTML-formatted contents of an <html> component that already existed, previously empty, on the Zen page.
Each time GetWeatherReport() is called, 
if there is a new output string, the contents of the <html> component change.]]></Description>
<FormalSpec>Location:%String</FormalSpec>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// declare the type of the output variable as the response message type
	#dim output as Demo.ZenService.Msg.WeatherReportResponse
	
	Try {
		// Create the business service
		Set tSC=##class(Ens.Director).CreateBusinessService("Zen Service",.tService)
		If ($$$ISERR(tSC)) Quit
		
		// Create the request message and give its property a value
		set strContainer=##class(Ens.StringContainer).%New()
		set strContainer.StringValue=Location
		
		// Call the ProcessInput method of the business service
		Set tSC=tService.ProcessInput(strContainer,.output)
		If ($$$ISERR(tSC)) Quit
		
		// Use the result to output messages to the screen using our Zen <html> component with the id "html1"
		If $IsObject($G(output)) {
			Set htmlOutput = %page.%GetComponentById("html1")
			Set htmlOutput.content = "The Current Weather is:<p> Low:"_
				output.MinTemp_output.TempScale_"<p> High:"_
				output.MaxTemp_output.TempScale_"<p><p> Today's weather report:<p>"_
				output.Report
		}
	}
	Catch(ex) { 
		// Display the server side error to the client
		&js<alert('Error in Server method:\n#($ZCVT(ex.DisplayString(),"O","JS"))#');>
	}
	Quit
]]></Implementation>
</Method>
</Class>
</Export>
